{"version":3,"sources":["webpack:///./node_modules/postprocessing/build/postprocessing.esm.js"],"names":["_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","from","test","_unsupportedIterableToArray","length","i","F","s","done","value","e","_e","f","TypeError","err","normalCompletion","didErr","step","next","_e2","return","arr","len","arr2","_createSuper","Derived","hasNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","_isNativeReflectConstruct","result","Super","NewTarget","this","arguments","apply","ColorChannel","shader_default2","shader_default3","shader_default5","shader_default6","shader_default7","shader_default8","kernelPresets","Float32Array","KernelSize","VERY_SMALL","SMALL","MEDIUM","LARGE","VERY_LARGE","HUGE","CopyMaterial","_ShaderMaterial6","_super6","_this6","type","uniforms","inputBuffer","opacity","fragmentShader","vertexShader","blending","depthWrite","depthTest","toneMapped","shader_default10","shader_default11","EdgeDetectionMode","DEPTH","LUMA","COLOR","Section","FRAGMENT_HEAD","FRAGMENT_MAIN_UV","FRAGMENT_MAIN_IMAGE","VERTEX_HEAD","VERTEX_MAIN_SUPPORT","shader_default18","shader_default19","MaskFunction","DISCARD","MULTIPLY","MULTIPLY_RGB_SET_ALPHA","shader_default20","shader_default21","shader_default22","shader_default23","dummyCamera","geometry","Pass","undefined","scene","camera","screen","rtt","needsSwap","needsDepthTexture","enabled","key","get","set","material","getFullscreenMaterial","needsUpdate","vertices","uvs","setAttribute","addAttribute","getFullscreenTriangle","frustumCulled","add","depthTexture","renderer","outputBuffer","deltaTime","stencilTest","Error","width","height","alpha","frameBufferType","dispose","_i3","_Object$keys","keys","property","ClearMaskPass","_Pass4","_super21","_this21","stencil","state","buffers","setLocked","setTest","color","ClearPass","_Pass5","_super22","_this22","color2","depth","overrideClearColor","overrideClearAlpha","clearAlpha","getClearAlpha","hasOverrideClearColor","hasOverrideClearAlpha","copy","getClearColor","setClearColor","setClearAlpha","setRenderTarget","renderToScreen","clear","workaroundEnabled","OverrideMaterialManager","_this23","originalMaterials","Map","materials","materialsBackSide","materialsDoubleSide","setMaterial","meshCount","replaceMaterial","node","isMesh","side","isSkinnedMesh","isInstancedMesh","disposeMaterials","clone","_i4","_materials","m2","assign","skinning","map","c2","shadowMapEnabled","shadowMap","traverse","render","_step3","_iterator3","entry","size","overrideMaterial","_step4","_iterator4","concat","RenderPass","_Pass6","_super23","_this24","clearPass","overrideMaterialManager","manager","background","renderTarget","BlendFunction","blendFunctions","BlendMode","_EventDispatcher","_super26","blendFunction","_this27","dispatchEvent","EffectAttribute","NONE","CONVOLUTION","MaskPass","_Pass12","_super31","_this33","inverse","context","getContext","writeValue","clearValue","setMask","setOp","REPLACE","setFunc","ALWAYS","setClear","EQUAL","KEEP","ShaderPass","_Pass14","_super33","_this35","input","setFullscreenMaterial","uniform","setInput","texture","EffectComposer","_ref8","_ref8$depthBuffer","depthBuffer","_ref8$stencilBuffer","stencilBuffer","_ref8$multisampling","multisampling","autoClear","createBuffer","enableExtensions","copyPass","passes","autoRenderToScreen","samples","buffer","capabilities","isWebGL2","getExtension","updateDOM","oldRenderer","oldSize","getSize","newSize","parent","domElement","parentNode","equals","setSize","removeChild","appendChild","format","_step16","_iterator16","setDepthTexture","getDrawingBufferSize","options","getContextAttributes","minFilter","magFilter","generateMipmaps","pass","index","drawingBufferSize","initialize","splice","push","_step17","createDepthTexture","_iterator17","indexOf","reduce","a","b","getDepthTexture","deleteDepthTexture","_step18","_iterator18","NOTEQUAL","updateStyle","_step19","_iterator19","_step20","_iterator20","Set","getNoise","data","channels","has","console","error","l","Uint8Array","Math","random","_i6","_l","createCanvas","canvas","document","createElementNS","Image","drawImage","imageData","createImageData","putImageData","RawImageData","image","getImageData","LUTOperation","lut_default","c","LookupTexture3D","_DataTexture3D","_super50","_this46","encoding","wrapS","wrapT","wrapR","unpackAlignment","domainMin","domainMax","promise","_this47","transferData","Promise","reject","workerURL","URL","createObjectURL","Blob","worker","Worker","resolve","addEventListener","event","lut","revokeObjectURL","transferList","postMessage","operation","img0","img1","size0","min","data0","data1","pow","i3","r","g","iRGB","round","floatData","uint8Data","Uint8ClampedArray","stride","fromArray","convertLinearToSRGB","toArray","convertSRGBToLinear","rgbData","rgbaData","maxValue","j","rearrangedData","z","y","x","i4","_i7","_i8","searchImageDataURL_default","PI","areaImageDataURL_default","bilinear","lerp2","p","e0","e1","e2","e3"],"mappings":"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","file":"4bdf9057-d303b8046e38196dc20e.js","sourcesContent":["import \"core-js/modules/es.array.reduce.js\";\nimport _slicedToArray from \"/Users/stefannowak/steken.dev/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _wrapNativeSuper from \"/Users/stefannowak/steken.dev/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nimport _set from \"/Users/stefannowak/steken.dev/node_modules/@babel/runtime/helpers/esm/set\";\nimport _get from \"/Users/stefannowak/steken.dev/node_modules/@babel/runtime/helpers/esm/get\";\nimport _assertThisInitialized from \"/Users/stefannowak/steken.dev/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/stefannowak/steken.dev/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/Users/stefannowak/steken.dev/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/stefannowak/steken.dev/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _classCallCheck from \"/Users/stefannowak/steken.dev/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/stefannowak/steken.dev/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * postprocessing v6.20.3 build Mon Feb 01 2021\n * https://github.com/vanruesc/postprocessing\n * Copyright 2021 Raoul van RÃ¼schen\n * @license Zlib\n */\n// src/core/ColorChannel.js\nvar ColorChannel = {\n  RED: 0,\n  GREEN: 1,\n  BLUE: 2,\n  ALPHA: 3\n}; // src/core/Disposable.js\n\nvar Disposable = /*#__PURE__*/function () {\n  function Disposable() {\n    _classCallCheck(this, Disposable);\n  }\n\n  _createClass(Disposable, [{\n    key: \"dispose\",\n    value: function dispose() {}\n  }]);\n\n  return Disposable;\n}(); // src/core/EffectComposer.js\n\n\nimport { DepthStencilFormat, DepthTexture, LinearFilter as LinearFilter4, RGBAFormat as RGBAFormat3, RGBFormat as RGBFormat4, UnsignedByteType as UnsignedByteType3, UnsignedIntType, UnsignedInt248Type, Vector2 as Vector212, WebGLMultisampleRenderTarget, WebGLRenderTarget as WebGLRenderTarget8 } from \"three\"; // src/passes/AdaptiveLuminancePass.js\n\nimport { HalfFloatType, NearestFilter, RGBAFormat, WebGLRenderTarget as WebGLRenderTarget2 } from \"three\"; // src/materials/AdaptiveLuminanceMaterial.js\n\nimport { NoBlending, ShaderMaterial, Uniform } from \"three\"; // src/materials/glsl/adaptive-luminance/shader.frag\n\nvar shader_default = \"uniform mediump sampler2D luminanceBuffer0;\\r\\nuniform sampler2D luminanceBuffer1;\\r\\n\\r\\nuniform float minLuminance;\\r\\nuniform float deltaTime;\\r\\nuniform float tau;\\r\\n\\r\\nvarying vec2 vUv;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\t// This 1x1 buffer contains the previous luminance.\\r\\n\tfloat l0 = texture2D(luminanceBuffer0, vUv).r;\\r\\n\\r\\n\t// Get the current average scene luminance.\\r\\n\t#if __VERSION__ < 300\\r\\n\\r\\n\t\tfloat l1 = texture2DLodEXT(luminanceBuffer1, vUv, MIP_LEVEL_1X1).r;\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tfloat l1 = textureLod(luminanceBuffer1, vUv, MIP_LEVEL_1X1).r;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tl0 = max(minLuminance, l0);\\r\\n\tl1 = max(minLuminance, l1);\\r\\n\\r\\n\t// Adapt the luminance using Pattanaik's technique.\\r\\n\tfloat adaptedLum = l0 + (l1 - l0) * (1.0 - exp(-deltaTime * tau));\\r\\n\\r\\n\tgl_FragColor.r = adaptedLum;\\r\\n\\r\\n}\\r\\n\"; // src/materials/glsl/common/shader.vert\n\nvar shader_default2 = \"varying vec2 vUv;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\tvUv = position.xy * 0.5 + 0.5;\\r\\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\\r\\n\\r\\n}\\r\\n\"; // src/materials/AdaptiveLuminanceMaterial.js\n\nvar AdaptiveLuminanceMaterial = /*#__PURE__*/function (_ShaderMaterial) {\n  _inherits(AdaptiveLuminanceMaterial, _ShaderMaterial);\n\n  var _super = _createSuper(AdaptiveLuminanceMaterial);\n\n  function AdaptiveLuminanceMaterial() {\n    var _this;\n\n    _classCallCheck(this, AdaptiveLuminanceMaterial);\n\n    _this = _super.call(this, {\n      type: \"AdaptiveLuminanceMaterial\",\n      defines: {\n        MIP_LEVEL_1X1: \"0.0\"\n      },\n      uniforms: {\n        luminanceBuffer0: new Uniform(null),\n        luminanceBuffer1: new Uniform(null),\n        minLuminance: new Uniform(0.01),\n        deltaTime: new Uniform(0),\n        tau: new Uniform(1)\n      },\n      fragmentShader: shader_default,\n      vertexShader: shader_default2,\n      blending: NoBlending,\n      depthWrite: false,\n      depthTest: false,\n      extensions: {\n        shaderTextureLOD: true\n      }\n    });\n    _this.toneMapped = false;\n    return _this;\n  }\n\n  return AdaptiveLuminanceMaterial;\n}(ShaderMaterial); // src/materials/BokehMaterial.js\n\n\nimport { NoBlending as NoBlending2, ShaderMaterial as ShaderMaterial2, Uniform as Uniform2, Vector2, Vector4 } from \"three\"; // src/materials/glsl/bokeh/shader.frag\n\nvar shader_default3 = \"uniform sampler2D inputBuffer;\\r\\nuniform sampler2D cocBuffer;\\r\\n\\r\\nuniform vec2 texelSize;\\r\\nuniform float scale;\\r\\n\\r\\n#if PASS == 1\\r\\n\\r\\n\tuniform vec4 kernel64[32];\\r\\n\\r\\n#else\\r\\n\\r\\n\tuniform vec4 kernel16[8];\\r\\n\\r\\n#endif\\r\\n\\r\\nvarying vec2 vUv;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\t#ifdef FOREGROUND\\r\\n\\r\\n\t\tvec2 CoCNearFar = texture2D(cocBuffer, vUv).rg;\\r\\n\t\tfloat CoC = CoCNearFar.r * scale;\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tfloat CoC = texture2D(cocBuffer, vUv).g * scale;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tif(CoC == 0.0) {\\r\\n\\r\\n\t\t// Skip blurring.\\r\\n\t\tgl_FragColor = texture2D(inputBuffer, vUv);\\r\\n\\r\\n\t} else {\\r\\n\\r\\n\t\t#ifdef FOREGROUND\\r\\n\\r\\n\t\t\t// Use far CoC to avoid weak blurring around foreground objects.\\r\\n\t\t\tvec2 step = texelSize * max(CoC, CoCNearFar.g * scale);\\r\\n\\r\\n\t\t#else\\r\\n\\r\\n\t\t\tvec2 step = texelSize * CoC;\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t\t#if PASS == 1\\r\\n\\r\\n\t\t\tvec4 acc = vec4(0.0);\\r\\n\\r\\n\t\t\t// Each vector contains two sampling points (64 in total).\\r\\n\t\t\tfor(int i = 0; i < 32; ++i) {\\r\\n\\r\\n\t\t\t\tvec4 kernel = kernel64[i];\\r\\n\\r\\n\t\t\t\tvec2 uv = step * kernel.xy + vUv;\\r\\n\t\t\t\tacc += texture2D(inputBuffer, uv);\\r\\n\\r\\n\t\t\t\tuv = step * kernel.zw + vUv;\\r\\n\t\t\t\tacc += texture2D(inputBuffer, uv);\\r\\n\\r\\n\t\t\t}\\r\\n\\r\\n\t\t\tgl_FragColor = acc / 64.0;\\r\\n\\r\\n\t\t#else\\r\\n\\r\\n\t\t\tvec4 maxValue = texture2D(inputBuffer, vUv);\\r\\n\\r\\n\t\t\t// Each vector contains two sampling points (16 in total).\\r\\n\t\t\tfor(int i = 0; i < 8; ++i) {\\r\\n\\r\\n\t\t\t\tvec4 kernel = kernel16[i];\\r\\n\\r\\n\t\t\t\tvec2 uv = step * kernel.xy + vUv;\\r\\n\t\t\t\tmaxValue = max(texture2D(inputBuffer, uv), maxValue);\\r\\n\\r\\n\t\t\t\tuv = step * kernel.zw + vUv;\\r\\n\t\t\t\tmaxValue = max(texture2D(inputBuffer, uv), maxValue);\\r\\n\\r\\n\t\t\t}\\r\\n\\r\\n\t\t\tgl_FragColor = maxValue;\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t}\\r\\n\\r\\n}\\r\\n\"; // src/materials/BokehMaterial.js\n\nvar BokehMaterial = /*#__PURE__*/function (_ShaderMaterial2) {\n  _inherits(BokehMaterial, _ShaderMaterial2);\n\n  var _super2 = _createSuper(BokehMaterial);\n\n  function BokehMaterial() {\n    var _this2;\n\n    var fill = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var foreground = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    _classCallCheck(this, BokehMaterial);\n\n    _this2 = _super2.call(this, {\n      type: \"BokehMaterial\",\n      defines: {\n        PASS: fill ? \"2\" : \"1\"\n      },\n      uniforms: {\n        kernel64: new Uniform2(null),\n        kernel16: new Uniform2(null),\n        inputBuffer: new Uniform2(null),\n        cocBuffer: new Uniform2(null),\n        texelSize: new Uniform2(new Vector2()),\n        scale: new Uniform2(1)\n      },\n      fragmentShader: shader_default3,\n      vertexShader: shader_default2,\n      blending: NoBlending2,\n      depthWrite: false,\n      depthTest: false\n    });\n    _this2.toneMapped = false;\n\n    if (foreground) {\n      _this2.defines.FOREGROUND = \"1\";\n    }\n\n    _this2.generateKernel();\n\n    return _this2;\n  }\n\n  _createClass(BokehMaterial, [{\n    key: \"generateKernel\",\n    value: function generateKernel() {\n      var GOLDEN_ANGLE = 2.39996323;\n      var points64 = new Float32Array(128);\n      var points16 = new Float32Array(32);\n      var i64 = 0,\n          i16 = 0;\n\n      for (var i = 0; i < 80; ++i) {\n        var theta = i * GOLDEN_ANGLE;\n        var r = Math.sqrt(i) / Math.sqrt(80);\n        var u = r * Math.cos(theta),\n            v3 = r * Math.sin(theta);\n\n        if (i % 5 === 0) {\n          points16[i16++] = u;\n          points16[i16++] = v3;\n        } else {\n          points64[i64++] = u;\n          points64[i64++] = v3;\n        }\n      }\n\n      var kernel64 = [];\n      var kernel16 = [];\n\n      for (var _i = 0; _i < 128;) {\n        kernel64.push(new Vector4(points64[_i++], points64[_i++], points64[_i++], points64[_i++]));\n      }\n\n      for (var _i2 = 0; _i2 < 32;) {\n        kernel16.push(new Vector4(points16[_i2++], points16[_i2++], points16[_i2++], points16[_i2++]));\n      }\n\n      this.uniforms.kernel64.value = kernel64;\n      this.uniforms.kernel16.value = kernel16;\n    }\n  }, {\n    key: \"setTexelSize\",\n    value: function setTexelSize(x, y) {\n      this.uniforms.texelSize.value.set(x, y);\n    }\n  }]);\n\n  return BokehMaterial;\n}(ShaderMaterial2); // src/materials/CircleOfConfusionMaterial.js\n\n\nimport { NoBlending as NoBlending3, PerspectiveCamera, ShaderMaterial as ShaderMaterial3, Uniform as Uniform3 } from \"three\"; // src/materials/glsl/circle-of-confusion/shader.frag\n\nvar shader_default4 = \"#include <common>\\r\\n#include <packing>\\r\\n\\r\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\r\\n\\r\\n\tuniform highp sampler2D depthBuffer;\\r\\n\\r\\n#else\\r\\n\\r\\n\tuniform mediump sampler2D depthBuffer;\\r\\n\\r\\n#endif\\r\\n\\r\\nuniform float focusDistance;\\r\\nuniform float focalLength;\\r\\nuniform float cameraNear;\\r\\nuniform float cameraFar;\\r\\n\\r\\nvarying vec2 vUv;\\r\\n\\r\\nfloat readDepth(const in vec2 uv) {\\r\\n\\r\\n\t#if DEPTH_PACKING == 3201\\r\\n\\r\\n\t\treturn unpackRGBAToDepth(texture2D(depthBuffer, uv));\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\treturn texture2D(depthBuffer, uv).r;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\tfloat depth = readDepth(vUv);\\r\\n\\r\\n\t#ifdef PERSPECTIVE_CAMERA\\r\\n\\r\\n\t\tfloat viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\\r\\n\t\tfloat linearDepth = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tfloat linearDepth = depth;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tfloat signedDistance = linearDepth - focusDistance;\\r\\n\tfloat magnitude = smoothstep(0.0, focalLength, abs(signedDistance));\\r\\n\\r\\n\tgl_FragColor.rg = vec2(\\r\\n\t\tstep(signedDistance, 0.0) * magnitude,\\r\\n\t\tstep(0.0, signedDistance) * magnitude\\r\\n\t);\\r\\n\\r\\n}\\r\\n\"; // src/materials/CircleOfConfusionMaterial.js\n\nvar CircleOfConfusionMaterial = /*#__PURE__*/function (_ShaderMaterial3) {\n  _inherits(CircleOfConfusionMaterial, _ShaderMaterial3);\n\n  var _super3 = _createSuper(CircleOfConfusionMaterial);\n\n  function CircleOfConfusionMaterial(camera) {\n    var _this3;\n\n    _classCallCheck(this, CircleOfConfusionMaterial);\n\n    _this3 = _super3.call(this, {\n      type: \"CircleOfConfusionMaterial\",\n      defines: {\n        DEPTH_PACKING: \"0\"\n      },\n      uniforms: {\n        depthBuffer: new Uniform3(null),\n        focusDistance: new Uniform3(0),\n        focalLength: new Uniform3(0),\n        cameraNear: new Uniform3(0.3),\n        cameraFar: new Uniform3(1e3)\n      },\n      fragmentShader: shader_default4,\n      vertexShader: shader_default2,\n      blending: NoBlending3,\n      depthWrite: false,\n      depthTest: false\n    });\n    _this3.toneMapped = false;\n\n    _this3.adoptCameraSettings(camera);\n\n    return _this3;\n  }\n\n  _createClass(CircleOfConfusionMaterial, [{\n    key: \"depthPacking\",\n    get: function get() {\n      return Number(this.defines.DEPTH_PACKING);\n    },\n    set: function set(value) {\n      this.defines.DEPTH_PACKING = value.toFixed(0);\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"adoptCameraSettings\",\n    value: function adoptCameraSettings() {\n      var camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (camera !== null) {\n        this.uniforms.cameraNear.value = camera.near;\n        this.uniforms.cameraFar.value = camera.far;\n\n        if (camera instanceof PerspectiveCamera) {\n          this.defines.PERSPECTIVE_CAMERA = \"1\";\n        } else {\n          delete this.defines.PERSPECTIVE_CAMERA;\n        }\n\n        this.needsUpdate = true;\n      }\n    }\n  }]);\n\n  return CircleOfConfusionMaterial;\n}(ShaderMaterial3); // src/materials/ColorEdgesMaterial.js\n\n\nimport { NoBlending as NoBlending4, ShaderMaterial as ShaderMaterial4, Uniform as Uniform4, Vector2 as Vector22 } from \"three\"; // src/materials/glsl/edge-detection/shader.frag\n\nvar shader_default5 = \"varying vec2 vUv;\\r\\nvarying vec2 vUv0;\\r\\nvarying vec2 vUv1;\\r\\n\\r\\n#if EDGE_DETECTION_MODE != 0\\r\\n\\r\\n\tvarying vec2 vUv2;\\r\\n\tvarying vec2 vUv3;\\r\\n\tvarying vec2 vUv4;\\r\\n\tvarying vec2 vUv5;\\r\\n\\r\\n#endif\\r\\n\\r\\n#if EDGE_DETECTION_MODE == 1\\r\\n\\r\\n\t#include <common>\\r\\n\\r\\n#endif\\r\\n\\r\\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\\r\\n\\r\\n\t#ifdef GL_FRAGMENT_PRECISION_HIGH\\r\\n\\r\\n\t\tuniform highp sampler2D depthBuffer;\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tuniform mediump sampler2D depthBuffer;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tfloat readDepth(const in vec2 uv) {\\r\\n\\r\\n\t\t#if DEPTH_PACKING == 3201\\r\\n\\r\\n\t\t\treturn unpackRGBAToDepth(texture2D(depthBuffer, uv));\\r\\n\\r\\n\t\t#else\\r\\n\\r\\n\t\t\treturn texture2D(depthBuffer, uv).r;\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t}\\r\\n\\r\\n\tvec3 gatherNeighbors() {\\r\\n\\r\\n\t\tfloat p = readDepth(vUv);\\r\\n\t\tfloat pLeft = readDepth(vUv0);\\r\\n\t\tfloat pTop = readDepth(vUv1);\\r\\n\\r\\n\t\treturn vec3(p, pLeft, pTop);\\r\\n\\r\\n\t}\\r\\n\\r\\n#elif PREDICATION_MODE == 2\\r\\n\\r\\n\tuniform sampler2D predicationBuffer;\\r\\n\\r\\n\tvec3 gatherNeighbors() {\\r\\n\\r\\n\t\tfloat p = texture2D(predicationBuffer, vUv).r;\\r\\n\t\tfloat pLeft = texture2D(predicationBuffer, vUv0).r;\\r\\n\t\tfloat pTop = texture2D(predicationBuffer, vUv1).r;\\r\\n\\r\\n\t\treturn vec3(p, pLeft, pTop);\\r\\n\\r\\n\t}\\r\\n\\r\\n#endif\\r\\n\\r\\n#if PREDICATION_MODE != 0\\r\\n\\r\\n\tvec2 calculatePredicatedThreshold() {\\r\\n\\r\\n\t\tvec3 neighbours = gatherNeighbors();\\r\\n\t\tvec2 delta = abs(neighbours.xx - neighbours.yz);\\r\\n\t\tvec2 edges = step(PREDICATION_THRESHOLD, delta);\\r\\n\\r\\n\t\treturn PREDICATION_SCALE * EDGE_THRESHOLD * (1.0 - PREDICATION_STRENGTH * edges);\\r\\n\\r\\n\t}\\r\\n\\r\\n#endif\\r\\n\\r\\n#if EDGE_DETECTION_MODE != 0\\r\\n\\r\\n\tuniform sampler2D inputBuffer;\\r\\n\\r\\n#endif\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\t#if EDGE_DETECTION_MODE == 0\\r\\n\\r\\n\t\tconst vec2 threshold = vec2(DEPTH_THRESHOLD);\\r\\n\\r\\n\t#elif PREDICATION_MODE != 0\\r\\n\\r\\n\t\tvec2 threshold = calculatePredicatedThreshold();\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tconst vec2 threshold = vec2(EDGE_THRESHOLD);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\t#if EDGE_DETECTION_MODE == 0\\r\\n\\r\\n\t\t// Depth-based edge detection.\\r\\n\\r\\n\t\tvec3 neighbors = gatherNeighbors();\\r\\n\t\tvec2 delta = abs(neighbors.xx - vec2(neighbors.y, neighbors.z));\\r\\n\t\tvec2 edges = step(threshold, delta);\\r\\n\\r\\n\t\tif(dot(edges, vec2(1.0)) == 0.0) {\\r\\n\\r\\n\t\t\tdiscard;\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t\tgl_FragColor = vec4(edges, 0.0, 1.0);\\r\\n\\r\\n\t#elif EDGE_DETECTION_MODE == 1\\r\\n\\r\\n\t\t// Luma-based edge detection.\\r\\n\\r\\n\t\tfloat l = linearToRelativeLuminance(texture2D(inputBuffer, vUv).rgb);\\r\\n\t\tfloat lLeft = linearToRelativeLuminance(texture2D(inputBuffer, vUv0).rgb);\\r\\n\t\tfloat lTop  = linearToRelativeLuminance(texture2D(inputBuffer, vUv1).rgb);\\r\\n\\r\\n\t\tvec4 delta;\\r\\n\t\tdelta.xy = abs(l - vec2(lLeft, lTop));\\r\\n\\r\\n\t\tvec2 edges = step(threshold, delta.xy);\\r\\n\\r\\n\t\tif(dot(edges, vec2(1.0)) == 0.0) {\\r\\n\\r\\n\t\t\tdiscard;\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t\t// Calculate right and bottom deltas.\\r\\n\t\tfloat lRight = linearToRelativeLuminance(texture2D(inputBuffer, vUv2).rgb);\\r\\n\t\tfloat lBottom  = linearToRelativeLuminance(texture2D(inputBuffer, vUv3).rgb);\\r\\n\t\tdelta.zw = abs(l - vec2(lRight, lBottom));\\r\\n\\r\\n\t\t// Calculate the maximum delta in the direct neighborhood.\\r\\n\t\tvec2 maxDelta = max(delta.xy, delta.zw);\\r\\n\\r\\n\t\t// Calculate left-left and top-top deltas.\\r\\n\t\tfloat lLeftLeft = linearToRelativeLuminance(texture2D(inputBuffer, vUv4).rgb);\\r\\n\t\tfloat lTopTop = linearToRelativeLuminance(texture2D(inputBuffer, vUv5).rgb);\\r\\n\t\tdelta.zw = abs(vec2(lLeft, lTop) - vec2(lLeftLeft, lTopTop));\\r\\n\\r\\n\t\t// Calculate the final maximum delta.\\r\\n\t\tmaxDelta = max(maxDelta.xy, delta.zw);\\r\\n\t\tfloat finalDelta = max(maxDelta.x, maxDelta.y);\\r\\n\\r\\n\t\t// Local contrast adaptation.\\r\\n\t\tedges.xy *= step(finalDelta, LOCAL_CONTRAST_ADAPTATION_FACTOR * delta.xy);\\r\\n\\r\\n\t\tgl_FragColor = vec4(edges, 0.0, 1.0);\\r\\n\\r\\n\t#elif EDGE_DETECTION_MODE == 2\\r\\n\\r\\n\t\t// Chroma-based edge detection.\\r\\n\\r\\n\t\tvec4 delta;\\r\\n\t\tvec3 c = texture2D(inputBuffer, vUv).rgb;\\r\\n\\r\\n\t\tvec3 cLeft = texture2D(inputBuffer, vUv0).rgb;\\r\\n\t\tvec3 t = abs(c - cLeft);\\r\\n\t\tdelta.x = max(max(t.r, t.g), t.b);\\r\\n\\r\\n\t\tvec3 cTop = texture2D(inputBuffer, vUv1).rgb;\\r\\n\t\tt = abs(c - cTop);\\r\\n\t\tdelta.y = max(max(t.r, t.g), t.b);\\r\\n\\r\\n\t\tvec2 edges = step(threshold, delta.xy);\\r\\n\\r\\n\t\tif(dot(edges, vec2(1.0)) == 0.0) {\\r\\n\\r\\n\t\t\tdiscard;\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t\t// Calculate right and bottom deltas.\\r\\n\t\tvec3 cRight = texture2D(inputBuffer, vUv2).rgb;\\r\\n\t\tt = abs(c - cRight);\\r\\n\t\tdelta.z = max(max(t.r, t.g), t.b);\\r\\n\\r\\n\t\tvec3 cBottom = texture2D(inputBuffer, vUv3).rgb;\\r\\n\t\tt = abs(c - cBottom);\\r\\n\t\tdelta.w = max(max(t.r, t.g), t.b);\\r\\n\\r\\n\t\t// Calculate the maximum delta in the direct neighborhood.\\r\\n\t\tvec2 maxDelta = max(delta.xy, delta.zw);\\r\\n\\r\\n\t\t// Calculate left-left and top-top deltas.\\r\\n\t\tvec3 cLeftLeft = texture2D(inputBuffer, vUv4).rgb;\\r\\n\t\tt = abs(c - cLeftLeft);\\r\\n\t\tdelta.z = max(max(t.r, t.g), t.b);\\r\\n\\r\\n\t\tvec3 cTopTop = texture2D(inputBuffer, vUv5).rgb;\\r\\n\t\tt = abs(c - cTopTop);\\r\\n\t\tdelta.w = max(max(t.r, t.g), t.b);\\r\\n\\r\\n\t\t// Calculate the final maximum delta.\\r\\n\t\tmaxDelta = max(maxDelta.xy, delta.zw);\\r\\n\t\tfloat finalDelta = max(maxDelta.x, maxDelta.y);\\r\\n\\r\\n\t\t// Local contrast adaptation.\\r\\n\t\tedges *= step(finalDelta, LOCAL_CONTRAST_ADAPTATION_FACTOR * delta.xy);\\r\\n\\r\\n\t\tgl_FragColor = vec4(edges, 0.0, 1.0);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n}\\r\\n\"; // src/materials/glsl/edge-detection/shader.vert\n\nvar shader_default6 = \"uniform vec2 texelSize;\\r\\n\\r\\nvarying vec2 vUv;\\r\\nvarying vec2 vUv0;\\r\\nvarying vec2 vUv1;\\r\\n\\r\\n#if EDGE_DETECTION_MODE != 0\\r\\n\\r\\n\tvarying vec2 vUv2;\\r\\n\tvarying vec2 vUv3;\\r\\n\tvarying vec2 vUv4;\\r\\n\tvarying vec2 vUv5;\\r\\n\\r\\n#endif\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\tvUv = position.xy * 0.5 + 0.5;\\r\\n\\r\\n\t// Left and top texel coordinates.\\r\\n\tvUv0 = vUv + texelSize * vec2(-1.0, 0.0);\\r\\n\tvUv1 = vUv + texelSize * vec2(0.0, -1.0);\\r\\n\\r\\n\t#if EDGE_DETECTION_MODE != 0\\r\\n\\r\\n\t\t// Right and bottom texel coordinates.\\r\\n\t\tvUv2 = vUv + texelSize * vec2(1.0, 0.0);\\r\\n\t\tvUv3 = vUv + texelSize * vec2(0.0, 1.0);\\r\\n\\r\\n\t\t// Left-left and top-top texel coordinates.\\r\\n\t\tvUv4 = vUv + texelSize * vec2(-2.0, 0.0);\\r\\n\t\tvUv5 = vUv + texelSize * vec2(0.0, -2.0);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\\r\\n\\r\\n}\\r\\n\"; // src/materials/ColorEdgesMaterial.js\n\nvar ColorEdgesMaterial = /*#__PURE__*/function (_ShaderMaterial4) {\n  _inherits(ColorEdgesMaterial, _ShaderMaterial4);\n\n  var _super4 = _createSuper(ColorEdgesMaterial);\n\n  function ColorEdgesMaterial() {\n    var _this4;\n\n    var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector22();\n\n    _classCallCheck(this, ColorEdgesMaterial);\n\n    _this4 = _super4.call(this, {\n      type: \"ColorEdgesMaterial\",\n      defines: {\n        EDGE_DETECTION_MODE: \"2\",\n        LOCAL_CONTRAST_ADAPTATION_FACTOR: \"2.0\",\n        EDGE_THRESHOLD: \"0.1\"\n      },\n      uniforms: {\n        inputBuffer: new Uniform4(null),\n        texelSize: new Uniform4(texelSize)\n      },\n      fragmentShader: shader_default5,\n      vertexShader: shader_default6,\n      blending: NoBlending4,\n      depthWrite: false,\n      depthTest: false\n    });\n    _this4.toneMapped = false;\n    return _this4;\n  }\n\n  _createClass(ColorEdgesMaterial, [{\n    key: \"setLocalContrastAdaptationFactor\",\n    value: function setLocalContrastAdaptationFactor(factor) {\n      this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = factor.toFixed(\"2\");\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"setEdgeDetectionThreshold\",\n    value: function setEdgeDetectionThreshold(threshold) {\n      var t = Math.min(Math.max(threshold, 0.05), 0.5);\n      this.defines.EDGE_THRESHOLD = t.toFixed(\"2\");\n      this.needsUpdate = true;\n    }\n  }]);\n\n  return ColorEdgesMaterial;\n}(ShaderMaterial4); // src/materials/ConvolutionMaterial.js\n\n\nimport { NoBlending as NoBlending5, ShaderMaterial as ShaderMaterial5, Uniform as Uniform5, Vector2 as Vector23 } from \"three\"; // src/materials/glsl/convolution/shader.frag\n\nvar shader_default7 = \"#include <common>\\r\\n#include <dithering_pars_fragment>\\r\\n\\r\\nuniform sampler2D inputBuffer;\\r\\n\\r\\nvarying vec2 vUv0;\\r\\nvarying vec2 vUv1;\\r\\nvarying vec2 vUv2;\\r\\nvarying vec2 vUv3;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\t// Sample top left texel.\\r\\n\tvec4 sum = texture2D(inputBuffer, vUv0);\\r\\n\\r\\n\t// Sample top right texel.\\r\\n\tsum += texture2D(inputBuffer, vUv1);\\r\\n\\r\\n\t// Sample bottom right texel.\\r\\n\tsum += texture2D(inputBuffer, vUv2);\\r\\n\\r\\n\t// Sample bottom left texel.\\r\\n\tsum += texture2D(inputBuffer, vUv3);\\r\\n\\r\\n\t// Compute the average.\\r\\n\tgl_FragColor = sum * 0.25;\\r\\n\\r\\n\t#include <dithering_fragment>\\r\\n\\r\\n}\\r\\n\"; // src/materials/glsl/convolution/shader.vert\n\nvar shader_default8 = \"uniform vec2 texelSize;\\r\\nuniform vec2 halfTexelSize;\\r\\nuniform float kernel;\\r\\nuniform float scale;\\r\\n\\r\\n/* Packing multiple texture coordinates into one varying and using a swizzle to\\r\\nextract them in the fragment shader still causes a dependent texture read. */\\r\\nvarying vec2 vUv0;\\r\\nvarying vec2 vUv1;\\r\\nvarying vec2 vUv2;\\r\\nvarying vec2 vUv3;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\tvec2 uv = position.xy * 0.5 + 0.5;\\r\\n\tvec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\\r\\n\\r\\n\tvUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\\r\\n\tvUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\\r\\n\tvUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\\r\\n\tvUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\\r\\n\\r\\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\\r\\n\\r\\n}\\r\\n\"; // src/materials/ConvolutionMaterial.js\n\nvar ConvolutionMaterial = /*#__PURE__*/function (_ShaderMaterial5) {\n  _inherits(ConvolutionMaterial, _ShaderMaterial5);\n\n  var _super5 = _createSuper(ConvolutionMaterial);\n\n  function ConvolutionMaterial() {\n    var _this5;\n\n    var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector23();\n\n    _classCallCheck(this, ConvolutionMaterial);\n\n    _this5 = _super5.call(this, {\n      type: \"ConvolutionMaterial\",\n      uniforms: {\n        inputBuffer: new Uniform5(null),\n        texelSize: new Uniform5(new Vector23()),\n        halfTexelSize: new Uniform5(new Vector23()),\n        kernel: new Uniform5(0),\n        scale: new Uniform5(1)\n      },\n      fragmentShader: shader_default7,\n      vertexShader: shader_default8,\n      blending: NoBlending5,\n      depthWrite: false,\n      depthTest: false\n    });\n    _this5.toneMapped = false;\n\n    _this5.setTexelSize(texelSize.x, texelSize.y);\n\n    _this5.kernelSize = KernelSize.LARGE;\n    return _this5;\n  }\n\n  _createClass(ConvolutionMaterial, [{\n    key: \"getKernel\",\n    value: function getKernel() {\n      return kernelPresets[this.kernelSize];\n    }\n  }, {\n    key: \"setTexelSize\",\n    value: function setTexelSize(x, y) {\n      this.uniforms.texelSize.value.set(x, y);\n      this.uniforms.halfTexelSize.value.set(x, y).multiplyScalar(0.5);\n    }\n  }]);\n\n  return ConvolutionMaterial;\n}(ShaderMaterial5);\n\nvar kernelPresets = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])];\nvar KernelSize = {\n  VERY_SMALL: 0,\n  SMALL: 1,\n  MEDIUM: 2,\n  LARGE: 3,\n  VERY_LARGE: 4,\n  HUGE: 5\n}; // src/materials/CopyMaterial.js\n\nimport { NoBlending as NoBlending6, ShaderMaterial as ShaderMaterial6, Uniform as Uniform6 } from \"three\"; // src/materials/glsl/copy/shader.frag\n\nvar shader_default9 = \"uniform sampler2D inputBuffer;\\r\\nuniform float opacity;\\r\\n\\r\\nvarying vec2 vUv;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\tvec4 texel = texture2D(inputBuffer, vUv);\\r\\n\tgl_FragColor = opacity * texel;\\r\\n\\r\\n\t#include <encodings_fragment>\\r\\n\\r\\n}\\r\\n\"; // src/materials/CopyMaterial.js\n\nvar CopyMaterial = /*#__PURE__*/function (_ShaderMaterial6) {\n  _inherits(CopyMaterial, _ShaderMaterial6);\n\n  var _super6 = _createSuper(CopyMaterial);\n\n  function CopyMaterial() {\n    var _this6;\n\n    _classCallCheck(this, CopyMaterial);\n\n    _this6 = _super6.call(this, {\n      type: \"CopyMaterial\",\n      uniforms: {\n        inputBuffer: new Uniform6(null),\n        opacity: new Uniform6(1)\n      },\n      fragmentShader: shader_default9,\n      vertexShader: shader_default2,\n      blending: NoBlending6,\n      depthWrite: false,\n      depthTest: false\n    });\n    _this6.toneMapped = false;\n    return _this6;\n  }\n\n  return CopyMaterial;\n}(ShaderMaterial6); // src/materials/DepthComparisonMaterial.js\n\n\nimport { NoBlending as NoBlending7, PerspectiveCamera as PerspectiveCamera2, ShaderMaterial as ShaderMaterial7, Uniform as Uniform7 } from \"three\"; // src/materials/glsl/depth-comparison/shader.frag\n\nvar shader_default10 = \"#include <packing>\\r\\n#include <clipping_planes_pars_fragment>\\r\\n\\r\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\r\\n\\r\\n\tuniform highp sampler2D depthBuffer;\\r\\n\\r\\n#else\\r\\n\\r\\n\tuniform mediump sampler2D depthBuffer;\\r\\n\\r\\n#endif\\r\\n\\r\\nuniform float cameraNear;\\r\\nuniform float cameraFar;\\r\\n\\r\\nvarying float vViewZ;\\r\\nvarying vec4 vProjTexCoord;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\t#include <clipping_planes_fragment>\\r\\n\\r\\n\t// Transform into Cartesian coordinate (not mirrored).\\r\\n\tvec2 projTexCoord = (vProjTexCoord.xy / vProjTexCoord.w) * 0.5 + 0.5;\\r\\n\tprojTexCoord = clamp(projTexCoord, 0.002, 0.998);\\r\\n\\r\\n\tfloat fragCoordZ = unpackRGBAToDepth(texture2D(depthBuffer, projTexCoord));\\r\\n\\r\\n\t#ifdef PERSPECTIVE_CAMERA\\r\\n\\r\\n\t\tfloat viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tfloat viewZ = orthographicDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tfloat depthTest = (-vViewZ > -viewZ) ? 1.0 : 0.0;\\r\\n\\r\\n\tgl_FragColor.rg = vec2(0.0, depthTest);\\r\\n\\r\\n}\\r\\n\"; // src/materials/glsl/depth-comparison/shader.vert\n\nvar shader_default11 = \"#include <common>\\r\\n#include <morphtarget_pars_vertex>\\r\\n#include <skinning_pars_vertex>\\r\\n#include <clipping_planes_pars_vertex>\\r\\n\\r\\nvarying float vViewZ;\\r\\nvarying vec4 vProjTexCoord;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\t#include <skinbase_vertex>\\r\\n\\r\\n\t#include <begin_vertex>\\r\\n\t#include <morphtarget_vertex>\\r\\n\t#include <skinning_vertex>\\r\\n\t#include <project_vertex>\\r\\n\\r\\n\tvViewZ = mvPosition.z;\\r\\n\tvProjTexCoord = gl_Position;\\r\\n\\r\\n\t#include <clipping_planes_vertex>\\r\\n\\r\\n}\\r\\n\"; // src/materials/DepthComparisonMaterial.js\n\nvar DepthComparisonMaterial = /*#__PURE__*/function (_ShaderMaterial7) {\n  _inherits(DepthComparisonMaterial, _ShaderMaterial7);\n\n  var _super7 = _createSuper(DepthComparisonMaterial);\n\n  function DepthComparisonMaterial() {\n    var _this7;\n\n    var depthTexture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var camera = arguments.length > 1 ? arguments[1] : undefined;\n\n    _classCallCheck(this, DepthComparisonMaterial);\n\n    _this7 = _super7.call(this, {\n      type: \"DepthComparisonMaterial\",\n      uniforms: {\n        depthBuffer: new Uniform7(depthTexture),\n        cameraNear: new Uniform7(0.3),\n        cameraFar: new Uniform7(1e3)\n      },\n      fragmentShader: shader_default10,\n      vertexShader: shader_default11,\n      blending: NoBlending7,\n      depthWrite: false,\n      depthTest: false\n    });\n    _this7.toneMapped = false;\n\n    _this7.adoptCameraSettings(camera);\n\n    return _this7;\n  }\n\n  _createClass(DepthComparisonMaterial, [{\n    key: \"adoptCameraSettings\",\n    value: function adoptCameraSettings() {\n      var camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (camera !== null) {\n        this.uniforms.cameraNear.value = camera.near;\n        this.uniforms.cameraFar.value = camera.far;\n\n        if (camera instanceof PerspectiveCamera2) {\n          this.defines.PERSPECTIVE_CAMERA = \"1\";\n        } else {\n          delete this.defines.PERSPECTIVE_CAMERA;\n        }\n      }\n    }\n  }]);\n\n  return DepthComparisonMaterial;\n}(ShaderMaterial7); // src/materials/DepthDownsamplingMaterial.js\n\n\nimport { NoBlending as NoBlending8, ShaderMaterial as ShaderMaterial8, Uniform as Uniform8, Vector2 as Vector24 } from \"three\"; // src/materials/glsl/depth-downsampling/shader.frag\n\nvar shader_default12 = \"#include <packing>\\r\\n\\r\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\r\\n\\r\\n\tuniform highp sampler2D depthBuffer;\\r\\n\\r\\n#else\\r\\n\\r\\n\tuniform mediump sampler2D depthBuffer;\\r\\n\\r\\n#endif\\r\\n\\r\\n#ifdef DOWNSAMPLE_NORMALS\\r\\n\\r\\n\tuniform sampler2D normalBuffer;\\r\\n\\r\\n#endif\\r\\n\\r\\nvarying vec2 vUv0;\\r\\nvarying vec2 vUv1;\\r\\nvarying vec2 vUv2;\\r\\nvarying vec2 vUv3;\\r\\n\\r\\nfloat readDepth(const in vec2 uv) {\\r\\n\\r\\n\t#if DEPTH_PACKING == 3201\\r\\n\\r\\n\t\treturn unpackRGBAToDepth(texture2D(depthBuffer, uv));\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\treturn texture2D(depthBuffer, uv).r;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * Returns the index of the most representative depth in the 2x2 neighborhood.\\r\\n */\\r\\n\\r\\nint findBestDepth(const in float samples[4]) {\\r\\n\\r\\n\t// Calculate the centroid.\\r\\n\tfloat c = (samples[0] + samples[1] + samples[2] + samples[3]) / 4.0;\\r\\n\\r\\n\tfloat distances[4] = float[](\\r\\n\t\tabs(c - samples[0]), abs(c - samples[1]),\\r\\n\t\tabs(c - samples[2]), abs(c - samples[3])\\r\\n\t);\\r\\n\\r\\n\tfloat maxDistance = max(\\r\\n\t\tmax(distances[0], distances[1]),\\r\\n\t\tmax(distances[2], distances[3])\\r\\n\t);\\r\\n\\r\\n\tint remaining[3];\\r\\n\tint rejected[3];\\r\\n\\r\\n\tint i, j, k;\\r\\n\\r\\n\tfor(i = 0, j = 0, k = 0; i < 4; ++i) {\\r\\n\\r\\n\t\tif(distances[i] < maxDistance) {\\r\\n\\r\\n\t\t\t// Keep the most representative samples.\\r\\n\t\t\tremaining[j++] = i;\\r\\n\\r\\n\t\t} else {\\r\\n\\r\\n\t\t\t// Discard max distance samples.\\r\\n\t\t\trejected[k++] = i;\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t}\\r\\n\\r\\n\t// Fill up the array in case there were two or more max distance samples.\\r\\n\tfor(; j < 3; ++j) {\\r\\n\\r\\n\t\tremaining[j] = rejected[--k];\\r\\n\\r\\n\t}\\r\\n\\r\\n\t// Final candidates.\\r\\n\tvec3 s = vec3(\\r\\n\t\tsamples[remaining[0]],\\r\\n\t\tsamples[remaining[1]],\\r\\n\t\tsamples[remaining[2]]\\r\\n\t);\\r\\n\\r\\n\t// Recalculate the controid.\\r\\n\tc = (s.x + s.y + s.z) / 3.0;\\r\\n\\r\\n\tdistances[0] = abs(c - s.x);\\r\\n\tdistances[1] = abs(c - s.y);\\r\\n\tdistances[2] = abs(c - s.z);\\r\\n\\r\\n\tfloat minDistance = min(distances[0], min(distances[1], distances[2]));\\r\\n\\r\\n\t// Determine the index of the min distance sample.\\r\\n\tfor(i = 0; i < 3; ++i) {\\r\\n\\r\\n\t\tif(distances[i] == minDistance) {\\r\\n\\r\\n\t\t\tbreak;\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t}\\r\\n\\r\\n\treturn remaining[i];\\r\\n\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\t// Gather depth samples in a 2x2 neighborhood.\\r\\n\tfloat d[4] = float[](\\r\\n\t\treadDepth(vUv0), readDepth(vUv1),\\r\\n\t\treadDepth(vUv2), readDepth(vUv3)\\r\\n\t);\\r\\n\\r\\n\tint index = findBestDepth(d);\\r\\n\\r\\n\t#ifdef DOWNSAMPLE_NORMALS\\r\\n\\r\\n\t\tvec2 uvs[4] = vec2[](vUv0, vUv1, vUv2, vUv3);\\r\\n\t\tvec3 n = texture2D(normalBuffer, uvs[index]).rgb;\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tvec3 n = vec3(0.0);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tgl_FragColor = vec4(n, d[index]);\\r\\n\\r\\n}\\r\\n\"; // src/materials/glsl/depth-downsampling/shader.vert\n\nvar shader_default13 = \"uniform vec2 texelSize;\\r\\n\\r\\nvarying vec2 vUv0;\\r\\nvarying vec2 vUv1;\\r\\nvarying vec2 vUv2;\\r\\nvarying vec2 vUv3;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\tvec2 uv = position.xy * 0.5 + 0.5;\\r\\n\\r\\n\tvUv0 = uv;\\r\\n\tvUv1 = vec2(uv.x, uv.y + texelSize.y);\\r\\n\tvUv2 = vec2(uv.x + texelSize.x, uv.y);\\r\\n\tvUv3 = uv + texelSize;\\r\\n\\r\\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\\r\\n\\r\\n}\\r\\n\"; // src/materials/DepthDownsamplingMaterial.js\n\nvar DepthDownsamplingMaterial = /*#__PURE__*/function (_ShaderMaterial8) {\n  _inherits(DepthDownsamplingMaterial, _ShaderMaterial8);\n\n  var _super8 = _createSuper(DepthDownsamplingMaterial);\n\n  function DepthDownsamplingMaterial() {\n    var _this8;\n\n    _classCallCheck(this, DepthDownsamplingMaterial);\n\n    _this8 = _super8.call(this, {\n      type: \"DepthDownsamplingMaterial\",\n      defines: {\n        DEPTH_PACKING: \"0\"\n      },\n      uniforms: {\n        depthBuffer: new Uniform8(null),\n        normalBuffer: new Uniform8(null),\n        texelSize: new Uniform8(new Vector24())\n      },\n      fragmentShader: shader_default12,\n      vertexShader: shader_default13,\n      blending: NoBlending8,\n      depthWrite: false,\n      depthTest: false\n    });\n    _this8.toneMapped = false;\n    return _this8;\n  }\n\n  _createClass(DepthDownsamplingMaterial, [{\n    key: \"depthPacking\",\n    get: function get() {\n      return Number(this.defines.DEPTH_PACKING);\n    },\n    set: function set(value) {\n      this.defines.DEPTH_PACKING = value.toFixed(0);\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"setTexelSize\",\n    value: function setTexelSize(x, y) {\n      this.uniforms.texelSize.value.set(x, y);\n    }\n  }]);\n\n  return DepthDownsamplingMaterial;\n}(ShaderMaterial8); // src/materials/DepthMaskMaterial.js\n\n\nimport { AlwaysDepth, EqualDepth, GreaterDepth, GreaterEqualDepth, LessDepth, LessEqualDepth, NeverDepth, NoBlending as NoBlending9, NotEqualDepth, ShaderMaterial as ShaderMaterial9, Uniform as Uniform9 } from \"three\"; // src/materials/glsl/depth-mask/shader.frag\n\nvar shader_default14 = \"#include <common>\\r\\n#include <packing>\\r\\n\\r\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\r\\n\\r\\n\tuniform highp sampler2D depthBuffer0;\\r\\n\tuniform highp sampler2D depthBuffer1;\\r\\n\\r\\n#else\\r\\n\\r\\n\tuniform mediump sampler2D depthBuffer0;\\r\\n\tuniform mediump sampler2D depthBuffer1;\\r\\n\\r\\n#endif\\r\\n\\r\\nuniform sampler2D inputBuffer;\\r\\nuniform float bias0;\\r\\nuniform float bias1;\\r\\n\\r\\nvarying vec2 vUv;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\tvec2 depth;\\r\\n\\r\\n\t#if DEPTH_PACKING_0 == 3201\\r\\n\\r\\n\t\tdepth.x = unpackRGBAToDepth(texture2D(depthBuffer0, vUv));\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tdepth.x = texture2D(depthBuffer0, vUv).r;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\t#if DEPTH_PACKING_1 == 3201\\r\\n\\r\\n\t\tdepth.y = unpackRGBAToDepth(texture2D(depthBuffer1, vUv));\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tdepth.y = texture2D(depthBuffer1, vUv).r;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tdepth = clamp(depth + vec2(bias0, bias1), 0.0, 1.0);\\r\\n\\r\\n\t#ifdef KEEP_FAR\\r\\n\\r\\n\t\tbool keep = (depth.x == 1.0) || depthTest(depth.x, depth.y);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tbool keep = (depth.x != 1.0) && depthTest(depth.x, depth.y);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tif(keep) {\\r\\n\\r\\n\t\tgl_FragColor = texture2D(inputBuffer, vUv);\\r\\n\\r\\n\t} else {\\r\\n\\r\\n\t\tdiscard;\\r\\n\\r\\n\t}\\r\\n\\r\\n}\\r\\n\"; // src/materials/DepthMaskMaterial.js\n\nvar DepthMaskMaterial = /*#__PURE__*/function (_ShaderMaterial9) {\n  _inherits(DepthMaskMaterial, _ShaderMaterial9);\n\n  var _super9 = _createSuper(DepthMaskMaterial);\n\n  function DepthMaskMaterial() {\n    var _this9;\n\n    _classCallCheck(this, DepthMaskMaterial);\n\n    _this9 = _super9.call(this, {\n      type: \"DepthMaskMaterial\",\n      defines: {\n        DEPTH_PACKING_0: \"0\",\n        DEPTH_PACKING_1: \"0\",\n        KEEP_FAR: \"1\"\n      },\n      uniforms: {\n        inputBuffer: new Uniform9(null),\n        depthBuffer0: new Uniform9(null),\n        depthBuffer1: new Uniform9(null),\n        bias0: new Uniform9(0),\n        bias1: new Uniform9(0)\n      },\n      fragmentShader: shader_default14,\n      vertexShader: shader_default2,\n      blending: NoBlending9,\n      depthWrite: false,\n      depthTest: false\n    });\n    _this9.toneMapped = false;\n    _this9.depthMode = LessDepth;\n\n    _this9.setDepthMode(LessDepth);\n\n    return _this9;\n  }\n\n  _createClass(DepthMaskMaterial, [{\n    key: \"keepFar\",\n    get: function get() {\n      return this.defines.KEEP_FAR !== void 0;\n    },\n    set: function set(value) {\n      if (value) {\n        this.defines.KEEP_FAR = \"1\";\n      } else {\n        delete this.defines.KEEP_FAR;\n      }\n\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"getDepthMode\",\n    value: function getDepthMode() {\n      return this.depthMode;\n    }\n  }, {\n    key: \"setDepthMode\",\n    value: function setDepthMode(mode) {\n      var depthTest;\n\n      switch (mode) {\n        case NeverDepth:\n          depthTest = \"false\";\n          break;\n\n        case AlwaysDepth:\n          depthTest = \"true\";\n          break;\n\n        case EqualDepth:\n          depthTest = \"abs(d1 - d0) <= EPSILON\";\n          break;\n\n        case NotEqualDepth:\n          depthTest = \"abs(d1 - d0) > EPSILON\";\n          break;\n\n        case LessDepth:\n          depthTest = \"d0 > d1\";\n          break;\n\n        case LessEqualDepth:\n          depthTest = \"d0 >= d1\";\n          break;\n\n        case GreaterEqualDepth:\n          depthTest = \"d0 <= d1\";\n          break;\n\n        case GreaterDepth:\n        default:\n          depthTest = \"d0 < d1\";\n          break;\n      }\n\n      this.depthMode = mode;\n      this.defines[\"depthTest(d0, d1)\"] = depthTest;\n      this.needsUpdate = true;\n    }\n  }]);\n\n  return DepthMaskMaterial;\n}(ShaderMaterial9); // src/materials/EdgeDetectionMaterial.js\n\n\nimport { NoBlending as NoBlending10, ShaderMaterial as ShaderMaterial10, Uniform as Uniform10, Vector2 as Vector25 } from \"three\";\n\nvar EdgeDetectionMaterial = /*#__PURE__*/function (_ShaderMaterial10) {\n  _inherits(EdgeDetectionMaterial, _ShaderMaterial10);\n\n  var _super10 = _createSuper(EdgeDetectionMaterial);\n\n  function EdgeDetectionMaterial() {\n    var _this10;\n\n    var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector25();\n    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EdgeDetectionMode.COLOR;\n\n    _classCallCheck(this, EdgeDetectionMaterial);\n\n    _this10 = _super10.call(this, {\n      type: \"EdgeDetectionMaterial\",\n      defines: {\n        LOCAL_CONTRAST_ADAPTATION_FACTOR: \"2.0\",\n        EDGE_THRESHOLD: \"0.1\",\n        DEPTH_THRESHOLD: \"0.01\",\n        PREDICATION_MODE: \"0\",\n        PREDICATION_THRESHOLD: \"0.01\",\n        PREDICATION_SCALE: \"2.0\",\n        PREDICATION_STRENGTH: \"1.0\",\n        DEPTH_PACKING: \"0\"\n      },\n      uniforms: {\n        inputBuffer: new Uniform10(null),\n        depthBuffer: new Uniform10(null),\n        predicationBuffer: new Uniform10(null),\n        texelSize: new Uniform10(texelSize)\n      },\n      fragmentShader: shader_default5,\n      vertexShader: shader_default6,\n      blending: NoBlending10,\n      depthWrite: false,\n      depthTest: false\n    });\n    _this10.toneMapped = false;\n\n    _this10.setEdgeDetectionMode(mode);\n\n    return _this10;\n  }\n\n  _createClass(EdgeDetectionMaterial, [{\n    key: \"depthPacking\",\n    get: function get() {\n      return Number(this.defines.DEPTH_PACKING);\n    },\n    set: function set(value) {\n      this.defines.DEPTH_PACKING = value.toFixed(0);\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"setEdgeDetectionMode\",\n    value: function setEdgeDetectionMode(mode) {\n      this.defines.EDGE_DETECTION_MODE = mode.toFixed(0);\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"setLocalContrastAdaptationFactor\",\n    value: function setLocalContrastAdaptationFactor(factor) {\n      this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = factor.toFixed(\"6\");\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"setEdgeDetectionThreshold\",\n    value: function setEdgeDetectionThreshold(threshold) {\n      this.defines.EDGE_THRESHOLD = threshold.toFixed(\"6\");\n      this.defines.DEPTH_THRESHOLD = (threshold * 0.1).toFixed(\"6\");\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"setPredicationMode\",\n    value: function setPredicationMode(mode) {\n      this.defines.PREDICATION_MODE = mode.toFixed(0);\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"setPredicationBuffer\",\n    value: function setPredicationBuffer(predicationBuffer) {\n      this.uniforms.predicationBuffer.value = predicationBuffer;\n    }\n  }, {\n    key: \"setPredicationThreshold\",\n    value: function setPredicationThreshold(threshold) {\n      this.defines.PREDICATION_THRESHOLD = threshold.toFixed(\"6\");\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"setPredicationScale\",\n    value: function setPredicationScale(scale) {\n      this.defines.PREDICATION_SCALE = scale.toFixed(\"6\");\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"setPredicationStrength\",\n    value: function setPredicationStrength(strength) {\n      this.defines.PREDICATION_STRENGTH = strength.toFixed(\"6\");\n      this.needsUpdate = true;\n    }\n  }]);\n\n  return EdgeDetectionMaterial;\n}(ShaderMaterial10);\n\nvar EdgeDetectionMode = {\n  DEPTH: 0,\n  LUMA: 1,\n  COLOR: 2\n};\nvar PredicationMode = {\n  DISABLED: 0,\n  DEPTH: 1,\n  CUSTOM: 2\n}; // src/materials/EffectMaterial.js\n\nimport { NoBlending as NoBlending11, PerspectiveCamera as PerspectiveCamera3, ShaderMaterial as ShaderMaterial11, Uniform as Uniform11, Vector2 as Vector26 } from \"three\"; // src/materials/glsl/effect/shader.frag\n\nvar shader_default15 = \"#include <common>\\r\\n#include <packing>\\r\\n#include <dithering_pars_fragment>\\r\\n\\r\\nuniform sampler2D inputBuffer;\\r\\n\\r\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\r\\n\\r\\n\tuniform highp sampler2D depthBuffer;\\r\\n\\r\\n#else\\r\\n\\r\\n\tuniform mediump sampler2D depthBuffer;\\r\\n\\r\\n#endif\\r\\n\\r\\nuniform vec2 resolution;\\r\\nuniform vec2 texelSize;\\r\\n\\r\\nuniform float cameraNear;\\r\\nuniform float cameraFar;\\r\\nuniform float aspect;\\r\\nuniform float time;\\r\\n\\r\\nvarying vec2 vUv;\\r\\n\\r\\nfloat readDepth(const in vec2 uv) {\\r\\n\\r\\n\t#if DEPTH_PACKING == 3201\\r\\n\\r\\n\t\treturn unpackRGBAToDepth(texture2D(depthBuffer, uv));\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\treturn texture2D(depthBuffer, uv).r;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n}\\r\\n\\r\\nfloat getViewZ(const in float depth) {\\r\\n\\r\\n\t#ifdef PERSPECTIVE_CAMERA\\r\\n\\r\\n\t\treturn perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\treturn orthographicDepthToViewZ(depth, cameraNear, cameraFar);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n}\\r\\n\\r\\nFRAGMENT_HEAD\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\tFRAGMENT_MAIN_UV\\r\\n\\r\\n\tvec4 color0 = texture2D(inputBuffer, UV);\\r\\n\tvec4 color1 = vec4(0.0);\\r\\n\\r\\n\tFRAGMENT_MAIN_IMAGE\\r\\n\\r\\n\tgl_FragColor = color0;\\r\\n\\r\\n\t#ifdef ENCODE_OUTPUT\\r\\n\\r\\n\t\t#include <encodings_fragment>\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\t#include <dithering_fragment>\\r\\n\\r\\n}\\r\\n\"; // src/materials/glsl/effect/shader.vert\n\nvar shader_default16 = \"uniform vec2 resolution;\\r\\nuniform vec2 texelSize;\\r\\n\\r\\nuniform float cameraNear;\\r\\nuniform float cameraFar;\\r\\nuniform float aspect;\\r\\nuniform float time;\\r\\n\\r\\nvarying vec2 vUv;\\r\\n\\r\\nVERTEX_HEAD\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\tvUv = position.xy * 0.5 + 0.5;\\r\\n\\r\\n\tVERTEX_MAIN_SUPPORT\\r\\n\\r\\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\\r\\n\\r\\n}\\r\\n\"; // src/materials/EffectMaterial.js\n\nvar EffectMaterial = /*#__PURE__*/function (_ShaderMaterial11) {\n  _inherits(EffectMaterial, _ShaderMaterial11);\n\n  var _super11 = _createSuper(EffectMaterial);\n\n  function EffectMaterial() {\n    var _this11;\n\n    var shaderParts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var defines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var uniforms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var camera = arguments.length > 3 ? arguments[3] : undefined;\n    var dithering = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    _classCallCheck(this, EffectMaterial);\n\n    _this11 = _super11.call(this, {\n      type: \"EffectMaterial\",\n      defines: {\n        DEPTH_PACKING: \"0\",\n        ENCODE_OUTPUT: \"1\"\n      },\n      uniforms: {\n        inputBuffer: new Uniform11(null),\n        depthBuffer: new Uniform11(null),\n        resolution: new Uniform11(new Vector26()),\n        texelSize: new Uniform11(new Vector26()),\n        cameraNear: new Uniform11(0.3),\n        cameraFar: new Uniform11(1e3),\n        aspect: new Uniform11(1),\n        time: new Uniform11(0)\n      },\n      blending: NoBlending11,\n      depthWrite: false,\n      depthTest: false,\n      dithering: dithering\n    });\n    _this11.toneMapped = false;\n\n    if (shaderParts !== null) {\n      _this11.setShaderParts(shaderParts);\n    }\n\n    if (defines !== null) {\n      _this11.setDefines(defines);\n    }\n\n    if (uniforms !== null) {\n      _this11.setUniforms(uniforms);\n    }\n\n    _this11.adoptCameraSettings(camera);\n\n    return _this11;\n  }\n\n  _createClass(EffectMaterial, [{\n    key: \"depthPacking\",\n    get: function get() {\n      return Number(this.defines.DEPTH_PACKING);\n    },\n    set: function set(value) {\n      this.defines.DEPTH_PACKING = value.toFixed(0);\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"setShaderParts\",\n    value: function setShaderParts(shaderParts) {\n      this.fragmentShader = shader_default15.replace(Section.FRAGMENT_HEAD, shaderParts.get(Section.FRAGMENT_HEAD)).replace(Section.FRAGMENT_MAIN_UV, shaderParts.get(Section.FRAGMENT_MAIN_UV)).replace(Section.FRAGMENT_MAIN_IMAGE, shaderParts.get(Section.FRAGMENT_MAIN_IMAGE));\n      this.vertexShader = shader_default16.replace(Section.VERTEX_HEAD, shaderParts.get(Section.VERTEX_HEAD)).replace(Section.VERTEX_MAIN_SUPPORT, shaderParts.get(Section.VERTEX_MAIN_SUPPORT));\n      this.needsUpdate = true;\n      return this;\n    }\n  }, {\n    key: \"setDefines\",\n    value: function setDefines(defines) {\n      var _iterator = _createForOfIteratorHelper(defines.entries()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var entry = _step.value;\n          this.defines[entry[0]] = entry[1];\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.needsUpdate = true;\n      return this;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(uniforms) {\n      var _iterator2 = _createForOfIteratorHelper(uniforms.entries()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var entry = _step2.value;\n          this.uniforms[entry[0]] = entry[1];\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"adoptCameraSettings\",\n    value: function adoptCameraSettings() {\n      var camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (camera !== null) {\n        this.uniforms.cameraNear.value = camera.near;\n        this.uniforms.cameraFar.value = camera.far;\n\n        if (camera instanceof PerspectiveCamera3) {\n          this.defines.PERSPECTIVE_CAMERA = \"1\";\n        } else {\n          delete this.defines.PERSPECTIVE_CAMERA;\n        }\n\n        this.needsUpdate = true;\n      }\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      var w = Math.max(width, 1);\n      var h = Math.max(height, 1);\n      this.uniforms.resolution.value.set(w, h);\n      this.uniforms.texelSize.value.set(1 / w, 1 / h);\n      this.uniforms.aspect.value = w / h;\n    }\n  }]);\n\n  return EffectMaterial;\n}(ShaderMaterial11);\n\nvar Section = {\n  FRAGMENT_HEAD: \"FRAGMENT_HEAD\",\n  FRAGMENT_MAIN_UV: \"FRAGMENT_MAIN_UV\",\n  FRAGMENT_MAIN_IMAGE: \"FRAGMENT_MAIN_IMAGE\",\n  VERTEX_HEAD: \"VERTEX_HEAD\",\n  VERTEX_MAIN_SUPPORT: \"VERTEX_MAIN_SUPPORT\"\n}; // src/materials/GodRaysMaterial.js\n\nimport { NoBlending as NoBlending12, ShaderMaterial as ShaderMaterial12, Uniform as Uniform12 } from \"three\"; // src/materials/glsl/god-rays/shader.frag\n\nvar shader_default17 = \"#include <common>\\r\\n#include <dithering_pars_fragment>\\r\\n\\r\\nuniform sampler2D inputBuffer;\\r\\nuniform vec2 lightPosition;\\r\\nuniform float exposure;\\r\\nuniform float decay;\\r\\nuniform float density;\\r\\nuniform float weight;\\r\\nuniform float clampMax;\\r\\n\\r\\nvarying vec2 vUv;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\tvec2 coord = vUv;\\r\\n\\r\\n\t// Calculate the vector from this pixel to the light position in screen space.\\r\\n\tvec2 delta = lightPosition - coord;\\r\\n\tdelta *= 1.0 / SAMPLES_FLOAT * density;\\r\\n\\r\\n\t// A decreasing illumination factor.\\r\\n\tfloat illuminationDecay = 1.0;\\r\\n\tvec4 color = vec4(0.0);\\r\\n\\r\\n\t/* Estimate the probability of occlusion at each pixel by summing samples\\r\\n\talong a ray to the light position. */\\r\\n\tfor(int i = 0; i < SAMPLES_INT; ++i) {\\r\\n\\r\\n\t\tcoord += delta;\\r\\n\t\tvec4 texel = texture2D(inputBuffer, coord);\\r\\n\\r\\n\t\t// Apply the sample attenuation scale/decay factors.\\r\\n\t\ttexel *= illuminationDecay * weight;\\r\\n\t\tcolor += texel;\\r\\n\\r\\n\t\t// Update the exponential decay factor.\\r\\n\t\tilluminationDecay *= decay;\\r\\n\\r\\n\t}\\r\\n\\r\\n\tgl_FragColor = clamp(color * exposure, 0.0, clampMax);\\r\\n\\r\\n\t#include <dithering_fragment>\\r\\n\\r\\n}\\r\\n\"; // src/materials/GodRaysMaterial.js\n\nvar GodRaysMaterial = /*#__PURE__*/function (_ShaderMaterial12) {\n  _inherits(GodRaysMaterial, _ShaderMaterial12);\n\n  var _super12 = _createSuper(GodRaysMaterial);\n\n  function GodRaysMaterial(lightPosition) {\n    var _this12;\n\n    _classCallCheck(this, GodRaysMaterial);\n\n    _this12 = _super12.call(this, {\n      type: \"GodRaysMaterial\",\n      defines: {\n        SAMPLES_INT: \"60\",\n        SAMPLES_FLOAT: \"60.0\"\n      },\n      uniforms: {\n        inputBuffer: new Uniform12(null),\n        lightPosition: new Uniform12(lightPosition),\n        density: new Uniform12(1),\n        decay: new Uniform12(1),\n        weight: new Uniform12(1),\n        exposure: new Uniform12(1),\n        clampMax: new Uniform12(1)\n      },\n      fragmentShader: shader_default17,\n      vertexShader: shader_default2,\n      blending: NoBlending12,\n      depthWrite: false,\n      depthTest: false\n    });\n    _this12.toneMapped = false;\n    return _this12;\n  }\n\n  _createClass(GodRaysMaterial, [{\n    key: \"samples\",\n    get: function get() {\n      return Number(this.defines.SAMPLES_INT);\n    },\n    set: function set(value) {\n      var s = Math.floor(value);\n      this.defines.SAMPLES_INT = s.toFixed(0);\n      this.defines.SAMPLES_FLOAT = s.toFixed(1);\n      this.needsUpdate = true;\n    }\n  }]);\n\n  return GodRaysMaterial;\n}(ShaderMaterial12); // src/materials/LuminanceMaterial.js\n\n\nimport { NoBlending as NoBlending13, ShaderMaterial as ShaderMaterial13, Uniform as Uniform13, Vector2 as Vector27 } from \"three\"; // src/materials/glsl/luminance/shader.frag\n\nvar shader_default18 = \"#include <common>\\r\\n\\r\\nuniform sampler2D inputBuffer;\\r\\n\\r\\n#ifdef RANGE\\r\\n\\r\\n\tuniform vec2 range;\\r\\n\\r\\n#elif defined(THRESHOLD)\\r\\n\\r\\n\tuniform float threshold;\\r\\n\tuniform float smoothing;\\r\\n\\r\\n#endif\\r\\n\\r\\nvarying vec2 vUv;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\tvec4 texel = texture2D(inputBuffer, vUv);\\r\\n\tfloat l = linearToRelativeLuminance(texel.rgb);\\r\\n\\r\\n\t#ifdef RANGE\\r\\n\\r\\n\t\t// Apply a luminance range mask.\\r\\n\t\tfloat low = step(range.x, l);\\r\\n\t\tfloat high = step(l, range.y);\\r\\n\\r\\n\t\tl *= low * high;\\r\\n\\r\\n\t#elif defined(THRESHOLD)\\r\\n\\r\\n\t\tl = smoothstep(threshold, threshold + smoothing, l);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\t#ifdef COLOR\\r\\n\\r\\n\t\tgl_FragColor = vec4(texel.rgb * l, l);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tgl_FragColor = vec4(l);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n}\\r\\n\"; // src/materials/LuminanceMaterial.js\n\nvar LuminanceMaterial = /*#__PURE__*/function (_ShaderMaterial13) {\n  _inherits(LuminanceMaterial, _ShaderMaterial13);\n\n  var _super13 = _createSuper(LuminanceMaterial);\n\n  function LuminanceMaterial() {\n    var _this13;\n\n    var colorOutput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var luminanceRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, LuminanceMaterial);\n\n    var useRange = luminanceRange !== null;\n    _this13 = _super13.call(this, {\n      type: \"LuminanceMaterial\",\n      uniforms: {\n        inputBuffer: new Uniform13(null),\n        threshold: new Uniform13(0),\n        smoothing: new Uniform13(1),\n        range: new Uniform13(useRange ? luminanceRange : new Vector27())\n      },\n      fragmentShader: shader_default18,\n      vertexShader: shader_default2,\n      blending: NoBlending13,\n      depthWrite: false,\n      depthTest: false\n    });\n    _this13.toneMapped = false;\n    _this13.colorOutput = colorOutput;\n    _this13.useThreshold = true;\n    _this13.useRange = useRange;\n    return _this13;\n  }\n\n  _createClass(LuminanceMaterial, [{\n    key: \"threshold\",\n    get: function get() {\n      return this.uniforms.threshold.value;\n    },\n    set: function set(value) {\n      this.uniforms.threshold.value = value;\n    }\n  }, {\n    key: \"smoothing\",\n    get: function get() {\n      return this.uniforms.smoothing.value;\n    },\n    set: function set(value) {\n      this.uniforms.smoothing.value = value;\n    }\n  }, {\n    key: \"useThreshold\",\n    get: function get() {\n      return this.defines.THRESHOLD !== void 0;\n    },\n    set: function set(value) {\n      if (value) {\n        this.defines.THRESHOLD = \"1\";\n      } else {\n        delete this.defines.THRESHOLD;\n      }\n\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"colorOutput\",\n    get: function get() {\n      return this.defines.COLOR !== void 0;\n    },\n    set: function set(value) {\n      if (value) {\n        this.defines.COLOR = \"1\";\n      } else {\n        delete this.defines.COLOR;\n      }\n\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"setColorOutputEnabled\",\n    value: function setColorOutputEnabled(enabled) {\n      this.colorOutput = enabled;\n    }\n  }, {\n    key: \"useRange\",\n    get: function get() {\n      return this.defines.RANGE !== void 0;\n    },\n    set: function set(value) {\n      if (value) {\n        this.defines.RANGE = \"1\";\n      } else {\n        delete this.defines.RANGE;\n      }\n\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"luminanceRange\",\n    get: function get() {\n      return this.useRange;\n    },\n    set: function set(value) {\n      this.useRange = value;\n    }\n  }, {\n    key: \"setLuminanceRangeEnabled\",\n    value: function setLuminanceRangeEnabled(enabled) {\n      this.useRange = enabled;\n    }\n  }]);\n\n  return LuminanceMaterial;\n}(ShaderMaterial13); // src/materials/MaskMaterial.js\n\n\nimport { NoBlending as NoBlending14, ShaderMaterial as ShaderMaterial14, Uniform as Uniform14 } from \"three\"; // src/materials/glsl/mask/shader.frag\n\nvar shader_default19 = \"uniform sampler2D maskTexture;\\r\\nuniform sampler2D inputBuffer;\\r\\n\\r\\n#if MASK_FUNCTION != 0\\r\\n\\r\\n\tuniform float strength;\\r\\n\\r\\n#endif\\r\\n\\r\\nvarying vec2 vUv;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\t#if COLOR_CHANNEL == 0\\r\\n\\r\\n\t\tfloat mask = texture2D(maskTexture, vUv).r;\\r\\n\\r\\n\t#elif COLOR_CHANNEL == 1\\r\\n\\r\\n\t\tfloat mask = texture2D(maskTexture, vUv).g;\\r\\n\\r\\n\t#elif COLOR_CHANNEL == 2\\r\\n\\r\\n\t\tfloat mask = texture2D(maskTexture, vUv).b;\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tfloat mask = texture2D(maskTexture, vUv).a;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\t#if MASK_FUNCTION == 0\\r\\n\\r\\n\t\t#ifdef INVERTED\\r\\n\\r\\n\t\t\tif(mask > 0.0) {\\r\\n\\r\\n\t\t\t\tdiscard;\\r\\n\\r\\n\t\t\t}\\r\\n\\r\\n\t\t#else\\r\\n\\r\\n\t\t\tif(mask == 0.0) {\\r\\n\\r\\n\t\t\t\tdiscard;\\r\\n\\r\\n\t\t\t}\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tmask = clamp(mask * strength, 0.0, 1.0);\\r\\n\\r\\n\t\t#ifdef INVERTED\\r\\n\\r\\n\t\t\tmask = (1.0 - mask);\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t\t#if MASK_FUNCTION == 1\\r\\n\\r\\n\t\t\tgl_FragColor = mask * texture2D(inputBuffer, vUv);\\r\\n\\r\\n\t\t#else\\r\\n\\r\\n\t\t\tgl_FragColor = vec4(mask * texture2D(inputBuffer, vUv).rgb, mask);\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t#endif\\r\\n\\r\\n}\\r\\n\"; // src/materials/MaskMaterial.js\n\nvar MaskMaterial = /*#__PURE__*/function (_ShaderMaterial14) {\n  _inherits(MaskMaterial, _ShaderMaterial14);\n\n  var _super14 = _createSuper(MaskMaterial);\n\n  function MaskMaterial() {\n    var _this14;\n\n    var maskTexture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, MaskMaterial);\n\n    _this14 = _super14.call(this, {\n      type: \"MaskMaterial\",\n      uniforms: {\n        maskTexture: new Uniform14(maskTexture),\n        inputBuffer: new Uniform14(null),\n        strength: new Uniform14(1)\n      },\n      fragmentShader: shader_default19,\n      vertexShader: shader_default2,\n      blending: NoBlending14,\n      depthWrite: false,\n      depthTest: false\n    });\n    _this14.toneMapped = false;\n    _this14.colorChannel = ColorChannel.RED;\n    _this14.maskFunction = MaskFunction.DISCARD;\n    return _this14;\n  }\n\n  _createClass(MaskMaterial, [{\n    key: \"maskTexture\",\n    set: function set(value) {\n      this.uniforms.maskTexture.value = value;\n    }\n  }, {\n    key: \"colorChannel\",\n    set: function set(value) {\n      this.defines.COLOR_CHANNEL = value.toFixed(0);\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"maskFunction\",\n    set: function set(value) {\n      this.defines.MASK_FUNCTION = value.toFixed(0);\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"inverted\",\n    get: function get() {\n      return this.defines.INVERTED !== void 0;\n    },\n    set: function set(value) {\n      if (this.inverted && !value) {\n        delete this.defines.INVERTED;\n      } else if (value) {\n        this.defines.INVERTED = \"1\";\n      }\n\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"strength\",\n    get: function get() {\n      return this.uniforms.strength.value;\n    },\n    set: function set(value) {\n      this.uniforms.strength.value = value;\n    }\n  }]);\n\n  return MaskMaterial;\n}(ShaderMaterial14);\n\nvar MaskFunction = {\n  DISCARD: 0,\n  MULTIPLY: 1,\n  MULTIPLY_RGB_SET_ALPHA: 2\n}; // src/materials/OutlineMaterial.js\n\nimport { NoBlending as NoBlending15, ShaderMaterial as ShaderMaterial15, Uniform as Uniform15, Vector2 as Vector28 } from \"three\"; // src/materials/glsl/outline/shader.frag\n\nvar shader_default20 = \"uniform sampler2D inputBuffer;\\r\\n\\r\\nvarying vec2 vUv0;\\r\\nvarying vec2 vUv1;\\r\\nvarying vec2 vUv2;\\r\\nvarying vec2 vUv3;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\tvec2 c0 = texture2D(inputBuffer, vUv0).rg;\\r\\n\tvec2 c1 = texture2D(inputBuffer, vUv1).rg;\\r\\n\tvec2 c2 = texture2D(inputBuffer, vUv2).rg;\\r\\n\tvec2 c3 = texture2D(inputBuffer, vUv3).rg;\\r\\n\\r\\n\tfloat d0 = (c0.x - c1.x) * 0.5;\\r\\n\tfloat d1 = (c2.x - c3.x) * 0.5;\\r\\n\tfloat d = length(vec2(d0, d1));\\r\\n\\r\\n\tfloat a0 = min(c0.y, c1.y);\\r\\n\tfloat a1 = min(c2.y, c3.y);\\r\\n\tfloat visibilityFactor = min(a0, a1);\\r\\n\\r\\n\tgl_FragColor.rg = (1.0 - visibilityFactor > 0.001) ? vec2(d, 0.0) : vec2(0.0, d);\\r\\n\\r\\n}\\r\\n\"; // src/materials/glsl/outline/shader.vert\n\nvar shader_default21 = \"uniform vec2 texelSize;\\r\\n\\r\\nvarying vec2 vUv0;\\r\\nvarying vec2 vUv1;\\r\\nvarying vec2 vUv2;\\r\\nvarying vec2 vUv3;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\tvec2 uv = position.xy * 0.5 + 0.5;\\r\\n\\r\\n\tvUv0 = vec2(uv.x + texelSize.x, uv.y);\\r\\n\tvUv1 = vec2(uv.x - texelSize.x, uv.y);\\r\\n\tvUv2 = vec2(uv.x, uv.y + texelSize.y);\\r\\n\tvUv3 = vec2(uv.x, uv.y - texelSize.y);\\r\\n\\r\\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\\r\\n\\r\\n}\\r\\n\"; // src/materials/OutlineMaterial.js\n\nvar OutlineMaterial = /*#__PURE__*/function (_ShaderMaterial15) {\n  _inherits(OutlineMaterial, _ShaderMaterial15);\n\n  var _super15 = _createSuper(OutlineMaterial);\n\n  function OutlineMaterial() {\n    var _this15;\n\n    var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector28();\n\n    _classCallCheck(this, OutlineMaterial);\n\n    _this15 = _super15.call(this, {\n      type: \"OutlineMaterial\",\n      uniforms: {\n        inputBuffer: new Uniform15(null),\n        texelSize: new Uniform15(new Vector28())\n      },\n      fragmentShader: shader_default20,\n      vertexShader: shader_default21,\n      blending: NoBlending15,\n      depthWrite: false,\n      depthTest: false\n    });\n    _this15.toneMapped = false;\n\n    _this15.setTexelSize(texelSize.x, texelSize.y);\n\n    _this15.uniforms.maskTexture = _this15.uniforms.inputBuffer;\n    return _this15;\n  }\n\n  _createClass(OutlineMaterial, [{\n    key: \"setTexelSize\",\n    value: function setTexelSize(x, y) {\n      this.uniforms.texelSize.value.set(x, y);\n    }\n  }]);\n\n  return OutlineMaterial;\n}(ShaderMaterial15);\n\nvar OutlineEdgesMaterial = OutlineMaterial; // src/materials/SMAAWeightsMaterial.js\n\nimport { NoBlending as NoBlending16, ShaderMaterial as ShaderMaterial16, Uniform as Uniform16, Vector2 as Vector29 } from \"three\"; // src/materials/glsl/smaa-weights/shader.frag\n\nvar shader_default22 = \"#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\\r\\n\\r\\n#if __VERSION__ < 300\\r\\n\\r\\n\t#define round(v) floor(v + 0.5)\\r\\n\\r\\n#endif\\r\\n\\r\\nuniform sampler2D inputBuffer;\\r\\nuniform sampler2D areaTexture;\\r\\nuniform sampler2D searchTexture;\\r\\n\\r\\nuniform vec2 texelSize;\\r\\nuniform vec2 resolution;\\r\\n\\r\\nvarying vec2 vUv;\\r\\nvarying vec4 vOffset[3];\\r\\nvarying vec2 vPixCoord;\\r\\n\\r\\n\\r\\n/**\\r\\n * Moves values to a target vector based on a given conditional vector.\\r\\n */\\r\\n\\r\\nvoid movec(const in bvec2 c, inout vec2 variable, const in vec2 value) {\\r\\n\\r\\n\tif(c.x) { variable.x = value.x; }\\r\\n\tif(c.y) { variable.y = value.y; }\\r\\n\\r\\n}\\r\\n\\r\\nvoid movec(const in bvec4 c, inout vec4 variable, const in vec4 value) {\\r\\n\\r\\n\tmovec(c.xy, variable.xy, value.xy);\\r\\n\tmovec(c.zw, variable.zw, value.zw);\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * Allows to decode two binary values from a bilinear-filtered access.\\r\\n *\\r\\n * Bilinear access for fetching 'e' have a 0.25 offset, and we are interested\\r\\n * in the R and G edges:\\r\\n *\\r\\n * +---G---+-------+\\r\\n * |   x o R   x   |\\r\\n * +-------+-------+\\r\\n *\\r\\n * Then, if one of these edge is enabled:\\r\\n *  Red: (0.75 * X + 0.25 * 1) => 0.25 or 1.0\\r\\n *  Green: (0.75 * 1 + 0.25 * X) => 0.75 or 1.0\\r\\n *\\r\\n * This function will unpack the values (mad + mul + round):\\r\\n * wolframalpha.com: round(x * abs(5 * x - 5 * 0.75)) plot 0 to 1\\r\\n */\\r\\n\\r\\nvec2 decodeDiagBilinearAccess(in vec2 e) {\\r\\n\\r\\n\te.r = e.r * abs(5.0 * e.r - 5.0 * 0.75);\\r\\n\\r\\n\treturn round(e);\\r\\n\\r\\n}\\r\\n\\r\\nvec4 decodeDiagBilinearAccess(in vec4 e) {\\r\\n\\r\\n\te.rb = e.rb * abs(5.0 * e.rb - 5.0 * 0.75);\\r\\n\\r\\n\treturn round(e);\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * Diagonal pattern searches.\\r\\n */\\r\\n\\r\\nvec2 searchDiag1(const in vec2 texCoord, const in vec2 dir, out vec2 e) {\\r\\n\\r\\n\tvec4 coord = vec4(texCoord, -1.0, 1.0);\\r\\n\tvec3 t = vec3(texelSize, 1.0);\\r\\n\\r\\n\tfor(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {\\r\\n\\r\\n\t\tif(!(coord.z < float(MAX_SEARCH_STEPS_DIAG_INT - 1) && coord.w > 0.9)) {\\r\\n\\r\\n\t\t\tbreak;\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t\tcoord.xyz = t * vec3(dir, 1.0) + coord.xyz;\\r\\n\t\te = texture2D(inputBuffer, coord.xy).rg;\\r\\n\t\tcoord.w = dot(e, vec2(0.5));\\r\\n\\r\\n\t}\\r\\n\\r\\n\treturn coord.zw;\\r\\n\\r\\n}\\r\\n\\r\\nvec2 searchDiag2(const in vec2 texCoord, const in vec2 dir, out vec2 e) {\\r\\n\\r\\n\tvec4 coord = vec4(texCoord, -1.0, 1.0);\\r\\n\tcoord.x += 0.25 * texelSize.x; // See @SearchDiag2Optimization\\r\\n\tvec3 t = vec3(texelSize, 1.0);\\r\\n\\r\\n\tfor(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {\\r\\n\\r\\n\t\tif(!(coord.z < float(MAX_SEARCH_STEPS_DIAG_INT - 1) && coord.w > 0.9)) {\\r\\n\\r\\n\t\t\tbreak;\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t\tcoord.xyz = t * vec3(dir, 1.0) + coord.xyz;\\r\\n\\r\\n\t\t// @SearchDiag2Optimization\\r\\n\t\t// Fetch both edges at once using bilinear filtering.\\r\\n\t\te = texture2D(inputBuffer, coord.xy).rg;\\r\\n\t\te = decodeDiagBilinearAccess(e);\\r\\n\\r\\n\t\t// Non-optimized version:\\r\\n\t\t// e.g = texture2D(inputBuffer, coord.xy).g;\\r\\n\t\t// e.r = SMAASampleLevelZeroOffset(inputBuffer, coord.xy, vec2(1, 0)).r;\\r\\n\\r\\n\t\tcoord.w = dot(e, vec2(0.5));\\r\\n\\r\\n\t}\\r\\n\\r\\n\treturn coord.zw;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * Calculates the area corresponding to a certain diagonal distance and crossing\\r\\n * edges 'e'.\\r\\n */\\r\\n\\r\\nvec2 areaDiag(const in vec2 dist, const in vec2 e, const in float offset) {\\r\\n\\r\\n\tvec2 texCoord = vec2(AREATEX_MAX_DISTANCE_DIAG, AREATEX_MAX_DISTANCE_DIAG) * e + dist;\\r\\n\\r\\n\t// Apply a scale and bias for mapping to texel space.\\r\\n\ttexCoord = AREATEX_PIXEL_SIZE * texCoord + 0.5 * AREATEX_PIXEL_SIZE;\\r\\n\\r\\n\t// Diagonal areas are on the second half of the texture.\\r\\n\ttexCoord.x += 0.5;\\r\\n\\r\\n\t// Move to the proper place, according to the subpixel offset.\\r\\n\ttexCoord.y += AREATEX_SUBTEX_SIZE * offset;\\r\\n\\r\\n\treturn texture2D(areaTexture, texCoord).rg;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * Searches for diagonal patterns and returns the corresponding weights.\\r\\n */\\r\\n\\r\\nvec2 calculateDiagWeights(const in vec2 texCoord, const in vec2 e, const in vec4 subsampleIndices) {\\r\\n\\r\\n\tvec2 weights = vec2(0.0);\\r\\n\\r\\n\t// Search for the line ends.\\r\\n\tvec4 d;\\r\\n\tvec2 end;\\r\\n\\r\\n\tif(e.r > 0.0) {\\r\\n\\r\\n\t\td.xz = searchDiag1(texCoord, vec2(-1.0,  1.0), end);\\r\\n\t\td.x += float(end.y > 0.9);\\r\\n\\r\\n\t} else {\\r\\n\\r\\n\t\td.xz = vec2(0.0);\\r\\n\\r\\n\t}\\r\\n\\r\\n\td.yw = searchDiag1(texCoord, vec2(1.0, -1.0), end);\\r\\n\\r\\n\tif(d.x + d.y > 2.0) { // d.x + d.y + 1 > 3\\r\\n\\r\\n\t\t// Fetch the crossing edges.\\r\\n\t\tvec4 coords = vec4(-d.x + 0.25, d.x, d.y, -d.y - 0.25) * texelSize.xyxy + texCoord.xyxy;\\r\\n\t\tvec4 c;\\r\\n\t\tc.xy = sampleLevelZeroOffset(inputBuffer, coords.xy, vec2(-1, 0)).rg;\\r\\n\t\tc.zw = sampleLevelZeroOffset(inputBuffer, coords.zw, vec2(1, 0)).rg;\\r\\n\t\tc.yxwz = decodeDiagBilinearAccess(c.xyzw);\\r\\n\\r\\n\t\t// Non-optimized version:\\r\\n\t\t// vec4 coords = vec4(-d.x, d.x, d.y, -d.y) * texelSize.xyxy + texCoord.xyxy;\\r\\n\t\t// vec4 c;\\r\\n\t\t// c.x = sampleLevelZeroOffset(inputBuffer, coords.xy, vec2(-1, 0)).g;\\r\\n\t\t// c.y = sampleLevelZeroOffset(inputBuffer, coords.xy, vec2(0, 0)).r;\\r\\n\t\t// c.z = sampleLevelZeroOffset(inputBuffer, coords.zw, vec2(1, 0)).g;\\r\\n\t\t// c.w = sampleLevelZeroOffset(inputBuffer, coords.zw, vec2(1, -1)).r;\\r\\n\\r\\n\t\t// Merge crossing edges at each side into a single value.\\r\\n\t\tvec2 cc = vec2(2.0) * c.xz + c.yw;\\r\\n\\r\\n\t\t// Remove the crossing edge if no end of the line could be found.\\r\\n\t\tmovec(bvec2(step(0.9, d.zw)), cc, vec2(0.0));\\r\\n\\r\\n\t\t// Fetch the areas for this line.\\r\\n\t\tweights += areaDiag(d.xy, cc, subsampleIndices.z);\\r\\n\\r\\n\t}\\r\\n\\r\\n\t// Search for the line ends.\\r\\n\td.xz = searchDiag2(texCoord, vec2(-1.0, -1.0), end);\\r\\n\\r\\n\tif(sampleLevelZeroOffset(inputBuffer, texCoord, vec2(1, 0)).r > 0.0) {\\r\\n\\r\\n\t\td.yw = searchDiag2(texCoord, vec2(1.0), end);\\r\\n\t\td.y += float(end.y > 0.9);\\r\\n\\r\\n\t} else {\\r\\n\\r\\n\t\td.yw = vec2(0.0);\\r\\n\\r\\n\t}\\r\\n\\r\\n\tif(d.x + d.y > 2.0) { // d.x + d.y + 1 > 3\\r\\n\\r\\n\t\t// Fetch the crossing edges.\\r\\n\t\tvec4 coords = vec4(-d.x, -d.x, d.y, d.y) * texelSize.xyxy + texCoord.xyxy;\\r\\n\t\tvec4 c;\\r\\n\t\tc.x = sampleLevelZeroOffset(inputBuffer, coords.xy, vec2(-1, 0)).g;\\r\\n\t\tc.y = sampleLevelZeroOffset(inputBuffer, coords.xy, vec2(0, -1)).r;\\r\\n\t\tc.zw = sampleLevelZeroOffset(inputBuffer, coords.zw, vec2(1, 0)).gr;\\r\\n\t\tvec2 cc = vec2(2.0) * c.xz + c.yw;\\r\\n\\r\\n\t\t// Remove the crossing edge if no end of the line could be found.\\r\\n\t\tmovec(bvec2(step(0.9, d.zw)), cc, vec2(0.0));\\r\\n\\r\\n\t\t// Fetch the areas for this line.\\r\\n\t\tweights += areaDiag(d.xy, cc, subsampleIndices.w).gr;\\r\\n\\r\\n\t}\\r\\n\\r\\n\treturn weights;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * Determines how much length should be added in the last step of the searches.\\r\\n *\\r\\n * Takes the bilinearly interpolated edge (see @PSEUDO_GATHER4), and adds 0, 1\\r\\n * or 2 depending on which edges and crossing edges are active.\\r\\n */\\r\\n\\r\\nfloat searchLength(const in vec2 e, const in float offset) {\\r\\n\\r\\n\t/* The texture is flipped vertically, with left and right cases taking half\\r\\n\tof the space horizontally. */\\r\\n\tvec2 scale = SEARCHTEX_SIZE * vec2(0.5, -1.0);\\r\\n\tvec2 bias = SEARCHTEX_SIZE * vec2(offset, 1.0);\\r\\n\\r\\n\t// Scale and bias to access texel centers.\\r\\n\tscale += vec2(-1.0, 1.0);\\r\\n\tbias += vec2(0.5, -0.5);\\r\\n\\r\\n\t// Convert from pixel coordinates to texcoords.\\r\\n\tscale *= 1.0 / SEARCHTEX_PACKED_SIZE;\\r\\n\tbias *= 1.0 / SEARCHTEX_PACKED_SIZE;\\r\\n\\r\\n\treturn texture2D(searchTexture, scale * e + bias).r;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * Horizontal search for the second pass.\\r\\n */\\r\\n\\r\\nfloat searchXLeft(in vec2 texCoord, const in float end) {\\r\\n\\r\\n\t/* @PSEUDO_GATHER4\\r\\n\tThis texCoord has been offset by (-0.25, -0.125) in the vertex shader to\\r\\n\tsample between edges, thus fetching four edges in a row.\\r\\n\tSampling with different offsets in each direction allows to disambiguate\\r\\n\twhich edges are active from the four fetched ones. */\\r\\n\\r\\n\tvec2 e = vec2(0.0, 1.0);\\r\\n\\r\\n\tfor(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {\\r\\n\\r\\n\t\tif(!(texCoord.x > end && e.g > 0.8281 && e.r == 0.0)) {\\r\\n\\r\\n\t\t\tbreak;\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t\te = texture2D(inputBuffer, texCoord).rg;\\r\\n\t\ttexCoord = vec2(-2.0, 0.0) * texelSize + texCoord;\\r\\n\\r\\n\t}\\r\\n\\r\\n\tfloat offset = -(255.0 / 127.0) * searchLength(e, 0.0) + 3.25;\\r\\n\\r\\n\treturn texelSize.x * offset + texCoord.x;\\r\\n\\r\\n\t// Non-optimized version:\\r\\n\t// Correct the previous (-0.25, -0.125) offset.\\r\\n\t// texCoord.x += 0.25 * texelSize.x;\\r\\n\t// The searches are biased by 1, so adjust the coords accordingly.\\r\\n\t// texCoord.x += texelSize.x;\\r\\n\t// Disambiguate the length added by the last step.\\r\\n\t// texCoord.x += 2.0 * texelSize.x; // Undo last step.\\r\\n\t// texCoord.x -= texelSize.x * (255.0 / 127.0) * searchLength(e, 0.0);\\r\\n\t// return texelSize.x * offset + texCoord.x);\\r\\n\\r\\n}\\r\\n\\r\\nfloat searchXRight(vec2 texCoord, const in float end) {\\r\\n\\r\\n\tvec2 e = vec2(0.0, 1.0);\\r\\n\\r\\n\tfor(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {\\r\\n\\r\\n\t\tif(!(texCoord.x < end && e.g > 0.8281 && e.r == 0.0)) {\\r\\n\\r\\n\t\t\tbreak;\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t\te = texture2D(inputBuffer, texCoord).rg;\\r\\n\t\ttexCoord = vec2(2.0, 0.0) * texelSize.xy + texCoord;\\r\\n\\r\\n\t}\\r\\n\\r\\n\tfloat offset = -(255.0 / 127.0) * searchLength(e, 0.5) + 3.25;\\r\\n\\r\\n\treturn -texelSize.x * offset + texCoord.x;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * Vertical search for the second pass.\\r\\n */\\r\\n\\r\\nfloat searchYUp(vec2 texCoord, const in float end) {\\r\\n\\r\\n\tvec2 e = vec2(1.0, 0.0);\\r\\n\\r\\n\tfor(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {\\r\\n\\r\\n\t\tif(!(texCoord.y > end && e.r > 0.8281 && e.g == 0.0)) {\\r\\n\\r\\n\t\t\tbreak;\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t\te = texture2D(inputBuffer, texCoord).rg;\\r\\n\t\ttexCoord = -vec2(0.0, 2.0) * texelSize.xy + texCoord;\\r\\n\\r\\n\t}\\r\\n\\r\\n\tfloat offset = -(255.0 / 127.0) * searchLength(e.gr, 0.0) + 3.25;\\r\\n\\r\\n\treturn texelSize.y * offset + texCoord.y;\\r\\n\\r\\n}\\r\\n\\r\\nfloat searchYDown(vec2 texCoord, const in float end) {\\r\\n\\r\\n\tvec2 e = vec2(1.0, 0.0);\\r\\n\\r\\n\tfor(int i = 0; i < MAX_SEARCH_STEPS_INT; i++) {\\r\\n\\r\\n\t\tif(!(texCoord.y < end && e.r > 0.8281 && e.g == 0.0)) {\\r\\n\\r\\n\t\t\tbreak;\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t\te = texture2D(inputBuffer, texCoord).rg;\\r\\n\t\ttexCoord = vec2(0.0, 2.0) * texelSize.xy + texCoord;\\r\\n\\r\\n\t}\\r\\n\\r\\n\tfloat offset = -(255.0 / 127.0) * searchLength(e.gr, 0.5) + 3.25;\\r\\n\\r\\n\treturn -texelSize.y * offset + texCoord.y;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * Determines the areas at each side of the current edge.\\r\\n */\\r\\n\\r\\nvec2 area(const in vec2 dist, const in float e1, const in float e2, const in float offset) {\\r\\n\\r\\n\t// Rounding prevents precision errors of bilinear filtering.\\r\\n\tvec2 texCoord = vec2(AREATEX_MAX_DISTANCE) * round(4.0 * vec2(e1, e2)) + dist;\\r\\n\\r\\n\t// Apply a scale and bias for mapping to texel space.\\r\\n\ttexCoord = AREATEX_PIXEL_SIZE * texCoord + 0.5 * AREATEX_PIXEL_SIZE;\\r\\n\\r\\n\t// Move to the proper place, according to the subpixel offset.\\r\\n\ttexCoord.y = AREATEX_SUBTEX_SIZE * offset + texCoord.y;\\r\\n\\r\\n\treturn texture2D(areaTexture, texCoord).rg;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * Corner detection.\\r\\n */\\r\\n\\r\\nvoid detectHorizontalCornerPattern(inout vec2 weights, const in vec4 texCoord, const in vec2 d) {\\r\\n\\r\\n\t#if !defined(DISABLE_CORNER_DETECTION)\\r\\n\\r\\n\t\tvec2 leftRight = step(d.xy, d.yx);\\r\\n\t\tvec2 rounding = (1.0 - CORNER_ROUNDING_NORM) * leftRight;\\r\\n\\r\\n\t\t// Reduce blending for pixels in the center of a line.\\r\\n\t\trounding /= leftRight.x + leftRight.y;\\r\\n\\r\\n\t\tvec2 factor = vec2(1.0);\\r\\n\t\tfactor.x -= rounding.x * sampleLevelZeroOffset(inputBuffer, texCoord.xy, vec2(0, 1)).r;\\r\\n\t\tfactor.x -= rounding.y * sampleLevelZeroOffset(inputBuffer, texCoord.zw, vec2(1, 1)).r;\\r\\n\t\tfactor.y -= rounding.x * sampleLevelZeroOffset(inputBuffer, texCoord.xy, vec2(0, -2)).r;\\r\\n\t\tfactor.y -= rounding.y * sampleLevelZeroOffset(inputBuffer, texCoord.zw, vec2(1, -2)).r;\\r\\n\\r\\n\t\tweights *= clamp(factor, 0.0, 1.0);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n}\\r\\n\\r\\nvoid detectVerticalCornerPattern(inout vec2 weights, const in vec4 texCoord, const in vec2 d) {\\r\\n\\r\\n\t#if !defined(DISABLE_CORNER_DETECTION)\\r\\n\\r\\n\t\tvec2 leftRight = step(d.xy, d.yx);\\r\\n\t\tvec2 rounding = (1.0 - CORNER_ROUNDING_NORM) * leftRight;\\r\\n\\r\\n\t\trounding /= leftRight.x + leftRight.y;\\r\\n\\r\\n\t\tvec2 factor = vec2(1.0);\\r\\n\t\tfactor.x -= rounding.x * sampleLevelZeroOffset(inputBuffer, texCoord.xy, vec2(1, 0)).g;\\r\\n\t\tfactor.x -= rounding.y * sampleLevelZeroOffset(inputBuffer, texCoord.zw, vec2(1, 1)).g;\\r\\n\t\tfactor.y -= rounding.x * sampleLevelZeroOffset(inputBuffer, texCoord.xy, vec2(-2, 0)).g;\\r\\n\t\tfactor.y -= rounding.y * sampleLevelZeroOffset(inputBuffer, texCoord.zw, vec2(-2, 1)).g;\\r\\n\\r\\n\t\tweights *= clamp(factor, 0.0, 1.0);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\tvec4 weights = vec4(0.0);\\r\\n\tvec4 subsampleIndices = vec4(0.0);\\r\\n\tvec2 e = texture2D(inputBuffer, vUv).rg;\\r\\n\\r\\n\tif(e.g > 0.0) {\\r\\n\\r\\n\t\t// Edge at north.\\r\\n\\r\\n\t\t#if !defined(DISABLE_DIAG_DETECTION)\\r\\n\\r\\n\t\t\t/* Diagonals have both north and west edges, so searching for them in one of\\r\\n\t\t\tthe boundaries is enough. */\\r\\n\t\t\tweights.rg = calculateDiagWeights(vUv, e, subsampleIndices);\\r\\n\\r\\n\t\t\t// Skip horizontal/vertical processing if there is a diagonal.\\r\\n\t\t\tif(weights.r == -weights.g) { // weights.r + weights.g == 0.0\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t\tvec2 d;\\r\\n\\r\\n\t\t// Find the distance to the left.\\r\\n\t\tvec3 coords;\\r\\n\t\tcoords.x = searchXLeft(vOffset[0].xy, vOffset[2].x);\\r\\n\t\tcoords.y = vOffset[1].y; // vOffset[1].y = vUv.y - 0.25 * texelSize.y (@CROSSING_OFFSET)\\r\\n\t\td.x = coords.x;\\r\\n\\r\\n\t\t/* Now fetch the left crossing edges, two at a time using bilinear\\r\\n\t\tfiltering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to discern what\\r\\n\t\tvalue each edge has. */\\r\\n\t\tfloat e1 = texture2D(inputBuffer, coords.xy).r;\\r\\n\\r\\n\t\t// Find the distance to the right.\\r\\n\t\tcoords.z = searchXRight(vOffset[0].zw, vOffset[2].y);\\r\\n\t\td.y = coords.z;\\r\\n\\r\\n\t\t/* Translate distances to pixel units for better interleave arithmetic and\\r\\n\t\tmemory accesses. */\\r\\n\t\td = round(resolution.xx * d + -vPixCoord.xx);\\r\\n\\r\\n\t\t// The area texture is compressed quadratically.\\r\\n\t\tvec2 sqrtD = sqrt(abs(d));\\r\\n\\r\\n\t\t// Fetch the right crossing edges.\\r\\n\t\tfloat e2 = sampleLevelZeroOffset(inputBuffer, coords.zy, vec2(1, 0)).r;\\r\\n\\r\\n\t\t// Pattern recognized, now get the actual area.\\r\\n\t\tweights.rg = area(sqrtD, e1, e2, subsampleIndices.y);\\r\\n\\r\\n\t\t// Fix corners.\\r\\n\t\tcoords.y = vUv.y;\\r\\n\t\tdetectHorizontalCornerPattern(weights.rg, coords.xyzy, d);\\r\\n\\r\\n\t\t#if !defined(DISABLE_DIAG_DETECTION)\\r\\n\\r\\n\t\t\t} else {\\r\\n\\r\\n\t\t\t\t// Skip vertical processing.\\r\\n\t\t\t\te.r = 0.0;\\r\\n\\r\\n\t\t\t}\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t}\\r\\n\\r\\n\tif(e.r > 0.0) {\\r\\n\\r\\n\t\t// Edge at west.\\r\\n\\r\\n\t\tvec2 d;\\r\\n\\r\\n\t\t// Find the distance to the top.\\r\\n\t\tvec3 coords;\\r\\n\t\tcoords.y = searchYUp(vOffset[1].xy, vOffset[2].z);\\r\\n\t\tcoords.x = vOffset[0].x; // vOffset[1].x = vUv.x - 0.25 * texelSize.x;\\r\\n\t\td.x = coords.y;\\r\\n\\r\\n\t\t// Fetch the top crossing edges.\\r\\n\t\tfloat e1 = texture2D(inputBuffer, coords.xy).g;\\r\\n\\r\\n\t\t// Find the distance to the bottom.\\r\\n\t\tcoords.z = searchYDown(vOffset[1].zw, vOffset[2].w);\\r\\n\t\td.y = coords.z;\\r\\n\\r\\n\t\t// Translate distances into pixel units.\\r\\n\t\td = round(resolution.yy * d - vPixCoord.yy);\\r\\n\\r\\n\t\t// The area texture is compressed quadratically.\\r\\n\t\tvec2 sqrtD = sqrt(abs(d));\\r\\n\\r\\n\t\t// Fetch the bottom crossing edges.\\r\\n\t\tfloat e2 = sampleLevelZeroOffset(inputBuffer, coords.xz, vec2(0, 1)).g;\\r\\n\\r\\n\t\t// Get the area for this direction.\\r\\n\t\tweights.ba = area(sqrtD, e1, e2, subsampleIndices.x);\\r\\n\\r\\n\t\t// Fix corners.\\r\\n\t\tcoords.x = vUv.x;\\r\\n\t\tdetectVerticalCornerPattern(weights.ba, coords.xyxz, d);\\r\\n\\r\\n\t}\\r\\n\\r\\n\tgl_FragColor = weights;\\r\\n\\r\\n}\\r\\n\"; // src/materials/glsl/smaa-weights/shader.vert\n\nvar shader_default23 = \"uniform vec2 texelSize;\\r\\nuniform vec2 resolution;\\r\\n\\r\\nvarying vec2 vUv;\\r\\nvarying vec4 vOffset[3];\\r\\nvarying vec2 vPixCoord;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\tvUv = position.xy * 0.5 + 0.5;\\r\\n\tvPixCoord = vUv * resolution;\\r\\n\\r\\n\t// Offsets for the searches (see @PSEUDO_GATHER4).\\r\\n\tvOffset[0] = vUv.xyxy + texelSize.xyxy * vec4(-0.25, -0.125, 1.25, -0.125);\\r\\n\tvOffset[1] = vUv.xyxy + texelSize.xyxy * vec4(-0.125, -0.25, -0.125, 1.25);\\r\\n\\r\\n\t// This indicates the ends of the loops.\\r\\n\tvOffset[2] = vec4(vOffset[0].xz, vOffset[1].yw) +\\r\\n\t\tvec4(-2.0, 2.0, -2.0, 2.0) * texelSize.xxyy * MAX_SEARCH_STEPS_FLOAT;\\r\\n\\r\\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\\r\\n\\r\\n}\\r\\n\"; // src/materials/SMAAWeightsMaterial.js\n\nvar SMAAWeightsMaterial = /*#__PURE__*/function (_ShaderMaterial16) {\n  _inherits(SMAAWeightsMaterial, _ShaderMaterial16);\n\n  var _super16 = _createSuper(SMAAWeightsMaterial);\n\n  function SMAAWeightsMaterial() {\n    var _this16;\n\n    var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector29();\n    var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector29();\n\n    _classCallCheck(this, SMAAWeightsMaterial);\n\n    _this16 = _super16.call(this, {\n      type: \"SMAAWeightsMaterial\",\n      defines: {\n        MAX_SEARCH_STEPS_INT: \"16\",\n        MAX_SEARCH_STEPS_FLOAT: \"16.0\",\n        MAX_SEARCH_STEPS_DIAG_INT: \"8\",\n        MAX_SEARCH_STEPS_DIAG_FLOAT: \"8.0\",\n        CORNER_ROUNDING: \"25\",\n        CORNER_ROUNDING_NORM: \"0.25\",\n        AREATEX_MAX_DISTANCE: \"16.0\",\n        AREATEX_MAX_DISTANCE_DIAG: \"20.0\",\n        AREATEX_PIXEL_SIZE: \"(1.0 / vec2(160.0, 560.0))\",\n        AREATEX_SUBTEX_SIZE: \"(1.0 / 7.0)\",\n        SEARCHTEX_SIZE: \"vec2(66.0, 33.0)\",\n        SEARCHTEX_PACKED_SIZE: \"vec2(64.0, 16.0)\"\n      },\n      uniforms: {\n        inputBuffer: new Uniform16(null),\n        areaTexture: new Uniform16(null),\n        searchTexture: new Uniform16(null),\n        texelSize: new Uniform16(texelSize),\n        resolution: new Uniform16(resolution)\n      },\n      fragmentShader: shader_default22,\n      vertexShader: shader_default23,\n      blending: NoBlending16,\n      depthWrite: false,\n      depthTest: false\n    });\n    _this16.toneMapped = false;\n    return _this16;\n  }\n\n  _createClass(SMAAWeightsMaterial, [{\n    key: \"setOrthogonalSearchSteps\",\n    value: function setOrthogonalSearchSteps(steps) {\n      var s = Math.min(Math.max(steps, 0), 112);\n      this.defines.MAX_SEARCH_STEPS_INT = s.toFixed(\"0\");\n      this.defines.MAX_SEARCH_STEPS_FLOAT = s.toFixed(\"1\");\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"setDiagonalSearchSteps\",\n    value: function setDiagonalSearchSteps(steps) {\n      var s = Math.min(Math.max(steps, 0), 20);\n      this.defines.MAX_SEARCH_STEPS_DIAG_INT = s.toFixed(\"0\");\n      this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = s.toFixed(\"1\");\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"setCornerRounding\",\n    value: function setCornerRounding(rounding) {\n      var r = Math.min(Math.max(rounding, 0), 100);\n      this.defines.CORNER_ROUNDING = r.toFixed(\"4\");\n      this.defines.CORNER_ROUNDING_NORM = (r / 100).toFixed(\"4\");\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"diagonalDetection\",\n    get: function get() {\n      return this.defines.DISABLE_DIAG_DETECTION === void 0;\n    },\n    set: function set(value) {\n      if (value) {\n        delete this.defines.DISABLE_DIAG_DETECTION;\n      } else {\n        this.defines.DISABLE_DIAG_DETECTION = \"1\";\n      }\n\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"cornerRounding\",\n    get: function get() {\n      return this.defines.DISABLE_CORNER_DETECTION === void 0;\n    },\n    set: function set(value) {\n      if (value) {\n        delete this.defines.DISABLE_CORNER_DETECTION;\n      } else {\n        this.defines.DISABLE_CORNER_DETECTION = \"1\";\n      }\n\n      this.needsUpdate = true;\n    }\n  }]);\n\n  return SMAAWeightsMaterial;\n}(ShaderMaterial16); // src/materials/SSAOMaterial.js\n\n\nimport { Matrix4, NoBlending as NoBlending17, PerspectiveCamera as PerspectiveCamera4, ShaderMaterial as ShaderMaterial17, Uniform as Uniform17, Vector2 as Vector210 } from \"three\"; // src/materials/glsl/ssao/shader.frag\n\nvar shader_default24 = \"#include <common>\\r\\n#include <packing>\\r\\n\\r\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\r\\n\\r\\n\tuniform highp sampler2D normalDepthBuffer;\\r\\n\\r\\n#else\\r\\n\\r\\n\tuniform mediump sampler2D normalDepthBuffer;\\r\\n\\r\\n#endif\\r\\n\\r\\n#ifndef NORMAL_DEPTH\\r\\n\\r\\n\tuniform sampler2D normalBuffer;\\r\\n\\r\\n\t// The depth texture is bound to normalDepthBuffer.\\r\\n\tfloat readDepth(const in vec2 uv) {\\r\\n\\r\\n\t\t#if DEPTH_PACKING == 3201\\r\\n\\r\\n\t\t\treturn unpackRGBAToDepth(texture2D(normalDepthBuffer, uv));\\r\\n\\r\\n\t\t#else\\r\\n\\r\\n\t\t\treturn texture2D(normalDepthBuffer, uv).r;\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t}\\r\\n\\r\\n#endif\\r\\n\\r\\nuniform sampler2D noiseTexture;\\r\\n\\r\\nuniform mat4 inverseProjectionMatrix;\\r\\nuniform mat4 projectionMatrix;\\r\\nuniform vec2 texelSize;\\r\\n\\r\\nuniform float cameraNear;\\r\\nuniform float cameraFar;\\r\\nuniform float minRadiusScale;\\r\\nuniform float intensity;\\r\\nuniform float fade;\\r\\nuniform float bias;\\r\\n\\r\\nuniform vec2 distanceCutoff;\\r\\nuniform vec2 proximityCutoff;\\r\\n\\r\\nvarying vec2 vUv;\\r\\nvarying vec2 vUv2;\\r\\n\\r\\nfloat getViewZ(const in float depth) {\\r\\n\\r\\n\t#ifdef PERSPECTIVE_CAMERA\\r\\n\\r\\n\t\treturn perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\treturn orthographicDepthToViewZ(depth, cameraNear, cameraFar);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n}\\r\\n\\r\\nvec3 getViewPosition(const in vec2 screenPosition, const in float depth, const in float viewZ) {\\r\\n\\r\\n\tfloat clipW = projectionMatrix[2][3] * viewZ + projectionMatrix[3][3];\\r\\n\tvec4 clipPosition = vec4((vec3(screenPosition, depth) - 0.5) * 2.0, 1.0);\\r\\n\tclipPosition *= clipW; // Unproject.\\r\\n\\r\\n\treturn (inverseProjectionMatrix * clipPosition).xyz;\\r\\n\\r\\n}\\r\\n\\r\\nfloat getAmbientOcclusion(const in vec3 p, const in vec3 n, const in float depth, const in vec2 uv) {\\r\\n\\r\\n\t#ifdef DISTANCE_SCALING\\r\\n\\r\\n\t\tfloat radiusScale = 1.0 - smoothstep(0.0, distanceCutoff.y, depth);\\r\\n\t\tradiusScale = radiusScale * (1.0 - minRadiusScale) + minRadiusScale;\\r\\n\\r\\n\t\tfloat radius = RADIUS * radiusScale;\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tfloat radius = RADIUS;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\t// Use a random starting angle.\\r\\n\tfloat noise = texture2D(noiseTexture, vUv2).r;\\r\\n\tfloat baseAngle = noise * PI2;\\r\\n\\r\\n\tfloat invSamples = 1.0 / SAMPLES_FLOAT;\\r\\n\tfloat rings = SPIRAL_TURNS * PI2;\\r\\n\\r\\n\tfloat occlusion = 0.0;\\r\\n\tint taps = 0;\\r\\n\\r\\n\tfor(int i = 0; i < SAMPLES_INT; ++i) {\\r\\n\\r\\n\t\tfloat alpha = (float(i) + 0.5) * invSamples;\\r\\n\t\tfloat angle = alpha * rings + baseAngle;\\r\\n\\r\\n\t\tvec2 coord = alpha * radius * vec2(cos(angle), sin(angle)) * texelSize + uv;\\r\\n\\r\\n\t\tif(coord.s < 0.0 || coord.s > 1.0 || coord.t < 0.0 || coord.t > 1.0) {\\r\\n\\r\\n\t\t\t// Skip samples outside the screen.\\r\\n\t\t\tcontinue;\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t\t#ifdef NORMAL_DEPTH\\r\\n\\r\\n\t\t\tfloat sampleDepth = texture2D(normalDepthBuffer, coord).a;\\r\\n\\r\\n\t\t#else\\r\\n\\r\\n\t\t\tfloat sampleDepth = readDepth(coord);\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t\tfloat viewZ = getViewZ(sampleDepth);\\r\\n\\r\\n\t\t#ifdef PERSPECTIVE_CAMERA\\r\\n\\r\\n\t\t\tfloat linearSampleDepth = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\\r\\n\\r\\n\t\t#else\\r\\n\\r\\n\t\t\tfloat linearSampleDepth = sampleDepth;\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t\tfloat proximity = abs(depth - linearSampleDepth);\\r\\n\\r\\n\t\tif(proximity < proximityCutoff.y) {\\r\\n\\r\\n\t\t\tfloat falloff = 1.0 - smoothstep(proximityCutoff.x, proximityCutoff.y, proximity);\\r\\n\\r\\n\t\t\tvec3 Q = getViewPosition(coord, sampleDepth, viewZ);\\r\\n\t\t\tvec3 v = Q - p;\\r\\n\\r\\n\t\t\tfloat vv = dot(v, v);\\r\\n\t\t\tfloat vn = dot(v, n) - bias;\\r\\n\\r\\n\t\t\tfloat f = max(RADIUS_SQ - vv, 0.0) / RADIUS_SQ;\\r\\n\t\t\tocclusion += (f * f * f * max(vn / (fade + vv), 0.0)) * falloff;\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t\t++taps;\\r\\n\\r\\n\t}\\r\\n\\r\\n\treturn occlusion / (4.0 * max(float(taps), 1.0));\\r\\n\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\t#ifdef NORMAL_DEPTH\\r\\n\\r\\n\t\tvec4 normalDepth = texture2D(normalDepthBuffer, vUv);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tvec4 normalDepth = vec4(\\r\\n\t\t\ttexture2D(normalBuffer, vUv).rgb,\\r\\n\t\t\treadDepth(vUv)\\r\\n\t\t);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tfloat ao = 1.0;\\r\\n\tfloat depth = normalDepth.a;\\r\\n\tfloat viewZ = getViewZ(depth);\\r\\n\\r\\n\t#ifdef PERSPECTIVE_CAMERA\\r\\n\\r\\n\t\tfloat linearDepth = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tfloat linearDepth = depth;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\t// Skip fragments that are too far away.\\r\\n\tif(linearDepth < distanceCutoff.y) {\\r\\n\\r\\n\t\tvec3 viewPosition = getViewPosition(vUv, depth, viewZ);\\r\\n\t\tvec3 viewNormal = unpackRGBToNormal(normalDepth.rgb);\\r\\n\t\tao -= getAmbientOcclusion(viewPosition, viewNormal, linearDepth, vUv);\\r\\n\\r\\n\t\t// Fade AO based on depth.\\r\\n\t\tfloat d = smoothstep(distanceCutoff.x, distanceCutoff.y, linearDepth);\\r\\n\t\tao = mix(ao, 1.0, d);\\r\\n\\r\\n\t\t// Adjust the overall intensity.\\r\\n\t\tao = clamp(pow(ao, abs(intensity)), 0.0, 1.0);\\r\\n\\r\\n\t}\\r\\n\\r\\n\tgl_FragColor.r = ao;\\r\\n\\r\\n}\\r\\n\"; // src/materials/glsl/ssao/shader.vert\n\nvar shader_default25 = \"uniform vec2 noiseScale;\\r\\n\\r\\nvarying vec2 vUv;\\r\\nvarying vec2 vUv2;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\tvUv = position.xy * 0.5 + 0.5;\\r\\n\tvUv2 = vUv * noiseScale;\\r\\n\\r\\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\\r\\n\\r\\n}\\r\\n\"; // src/materials/SSAOMaterial.js\n\nvar SSAOMaterial = /*#__PURE__*/function (_ShaderMaterial17) {\n  _inherits(SSAOMaterial, _ShaderMaterial17);\n\n  var _super17 = _createSuper(SSAOMaterial);\n\n  function SSAOMaterial(camera) {\n    var _this17;\n\n    _classCallCheck(this, SSAOMaterial);\n\n    _this17 = _super17.call(this, {\n      type: \"SSAOMaterial\",\n      defines: {\n        SAMPLES_INT: \"0\",\n        SAMPLES_FLOAT: \"0.0\",\n        SPIRAL_TURNS: \"0.0\",\n        RADIUS: \"1.0\",\n        RADIUS_SQ: \"1.0\",\n        DISTANCE_SCALING: \"1\",\n        DEPTH_PACKING: \"0\"\n      },\n      uniforms: {\n        normalBuffer: new Uniform17(null),\n        normalDepthBuffer: new Uniform17(null),\n        noiseTexture: new Uniform17(null),\n        inverseProjectionMatrix: new Uniform17(new Matrix4()),\n        projectionMatrix: new Uniform17(new Matrix4()),\n        texelSize: new Uniform17(new Vector210()),\n        cameraNear: new Uniform17(0),\n        cameraFar: new Uniform17(0),\n        distanceCutoff: new Uniform17(new Vector210()),\n        proximityCutoff: new Uniform17(new Vector210()),\n        noiseScale: new Uniform17(new Vector210()),\n        minRadiusScale: new Uniform17(0.33),\n        intensity: new Uniform17(1),\n        fade: new Uniform17(0.01),\n        bias: new Uniform17(0)\n      },\n      fragmentShader: shader_default24,\n      vertexShader: shader_default25,\n      blending: NoBlending17,\n      depthWrite: false,\n      depthTest: false\n    });\n    _this17.toneMapped = false;\n\n    _this17.adoptCameraSettings(camera);\n\n    return _this17;\n  }\n\n  _createClass(SSAOMaterial, [{\n    key: \"depthPacking\",\n    get: function get() {\n      return Number(this.defines.DEPTH_PACKING);\n    },\n    set: function set(value) {\n      this.defines.DEPTH_PACKING = value.toFixed(0);\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"setTexelSize\",\n    value: function setTexelSize(x, y) {\n      this.uniforms.texelSize.value.set(x, y);\n    }\n  }, {\n    key: \"adoptCameraSettings\",\n    value: function adoptCameraSettings() {\n      var camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (camera !== null) {\n        var uniforms = this.uniforms;\n        uniforms.cameraNear.value = camera.near;\n        uniforms.cameraFar.value = camera.far;\n\n        if (camera instanceof PerspectiveCamera4) {\n          this.defines.PERSPECTIVE_CAMERA = \"1\";\n        } else {\n          delete this.defines.PERSPECTIVE_CAMERA;\n        }\n\n        this.needsUpdate = true;\n      }\n    }\n  }]);\n\n  return SSAOMaterial;\n}(ShaderMaterial17); // src/passes/Pass.js\n\n\nimport { BufferAttribute, BufferGeometry, Camera, Mesh, Scene } from \"three\";\nvar dummyCamera = new Camera();\nvar geometry = null;\n\nfunction getFullscreenTriangle() {\n  if (geometry === null) {\n    var vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);\n    var uvs = new Float32Array([0, 0, 2, 0, 0, 2]);\n    geometry = new BufferGeometry();\n\n    if (geometry.setAttribute !== void 0) {\n      geometry.setAttribute(\"position\", new BufferAttribute(vertices, 3));\n      geometry.setAttribute(\"uv\", new BufferAttribute(uvs, 2));\n    } else {\n      geometry.addAttribute(\"position\", new BufferAttribute(vertices, 3));\n      geometry.addAttribute(\"uv\", new BufferAttribute(uvs, 2));\n    }\n  }\n\n  return geometry;\n}\n\nvar Pass = /*#__PURE__*/function () {\n  function Pass() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Pass\";\n    var scene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Scene();\n    var camera = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : dummyCamera;\n\n    _classCallCheck(this, Pass);\n\n    this.name = name;\n    this.scene = scene;\n    this.camera = camera;\n    this.screen = null;\n    this.rtt = true;\n    this.needsSwap = true;\n    this.needsDepthTexture = false;\n    this.enabled = true;\n  }\n\n  _createClass(Pass, [{\n    key: \"renderToScreen\",\n    get: function get() {\n      return !this.rtt;\n    },\n    set: function set(value) {\n      if (this.rtt === value) {\n        var material = this.getFullscreenMaterial();\n\n        if (material !== null) {\n          material.needsUpdate = true;\n        }\n\n        this.rtt = !value;\n      }\n    }\n  }, {\n    key: \"getFullscreenMaterial\",\n    value: function getFullscreenMaterial() {\n      return this.screen !== null ? this.screen.material : null;\n    }\n  }, {\n    key: \"setFullscreenMaterial\",\n    value: function setFullscreenMaterial(material) {\n      var screen = this.screen;\n\n      if (screen !== null) {\n        screen.material = material;\n      } else {\n        screen = new Mesh(getFullscreenTriangle(), material);\n        screen.frustumCulled = false;\n\n        if (this.scene === null) {\n          this.scene = new Scene();\n        }\n\n        this.scene.add(screen);\n        this.screen = screen;\n      }\n    }\n  }, {\n    key: \"getDepthTexture\",\n    value: function getDepthTexture() {\n      return null;\n    }\n  }, {\n    key: \"setDepthTexture\",\n    value: function setDepthTexture(depthTexture) {\n      var depthPacking = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n      throw new Error(\"Render method not implemented!\");\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {}\n  }, {\n    key: \"initialize\",\n    value: function initialize(renderer, alpha, frameBufferType) {}\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var material = this.getFullscreenMaterial();\n\n      if (material !== null) {\n        material.dispose();\n      }\n\n      for (var _i3 = 0, _Object$keys = Object.keys(this); _i3 < _Object$keys.length; _i3++) {\n        var key = _Object$keys[_i3];\n        var property = this[key];\n\n        if (property !== null && typeof property.dispose === \"function\") {\n          if (property instanceof Scene) {\n            continue;\n          }\n\n          this[key].dispose();\n        }\n      }\n    }\n  }]);\n\n  return Pass;\n}(); // src/passes/SavePass.js\n\n\nimport { LinearFilter, RGBFormat, UnsignedByteType, WebGLRenderTarget } from \"three\";\n\nvar SavePass = /*#__PURE__*/function (_Pass) {\n  _inherits(SavePass, _Pass);\n\n  var _super18 = _createSuper(SavePass);\n\n  function SavePass(renderTarget) {\n    var _this18;\n\n    var resize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    _classCallCheck(this, SavePass);\n\n    _this18 = _super18.call(this, \"SavePass\");\n\n    _this18.setFullscreenMaterial(new CopyMaterial());\n\n    _this18.needsSwap = false;\n    _this18.renderTarget = renderTarget;\n\n    if (renderTarget === void 0) {\n      _this18.renderTarget = new WebGLRenderTarget(1, 1, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n        stencilBuffer: false,\n        depthBuffer: false\n      });\n      _this18.renderTarget.texture.name = \"SavePass.Target\";\n    }\n\n    _this18.resize = resize;\n    return _this18;\n  }\n\n  _createClass(SavePass, [{\n    key: \"texture\",\n    get: function get() {\n      return this.renderTarget.texture;\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n      this.getFullscreenMaterial().uniforms.inputBuffer.value = inputBuffer.texture;\n      renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n      renderer.render(this.scene, this.camera);\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      if (this.resize) {\n        var w = Math.max(width, 1);\n        var h = Math.max(height, 1);\n        this.renderTarget.setSize(w, h);\n      }\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize(renderer, alpha, frameBufferType) {\n      if (!alpha && frameBufferType === UnsignedByteType) {\n        this.renderTarget.texture.format = RGBFormat;\n      }\n\n      if (frameBufferType !== void 0) {\n        this.renderTarget.texture.type = frameBufferType;\n      }\n    }\n  }]);\n\n  return SavePass;\n}(Pass); // src/passes/AdaptiveLuminancePass.js\n\n\nvar AdaptiveLuminancePass = /*#__PURE__*/function (_Pass2) {\n  _inherits(AdaptiveLuminancePass, _Pass2);\n\n  var _super19 = _createSuper(AdaptiveLuminancePass);\n\n  function AdaptiveLuminancePass(luminanceBuffer) {\n    var _this19;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$minLuminance = _ref.minLuminance,\n        minLuminance = _ref$minLuminance === void 0 ? 0.01 : _ref$minLuminance,\n        _ref$adaptationRate = _ref.adaptationRate,\n        adaptationRate = _ref$adaptationRate === void 0 ? 1 : _ref$adaptationRate;\n\n    _classCallCheck(this, AdaptiveLuminancePass);\n\n    _this19 = _super19.call(this, \"AdaptiveLuminancePass\");\n\n    _this19.setFullscreenMaterial(new AdaptiveLuminanceMaterial());\n\n    _this19.needsSwap = false;\n    _this19.renderTargetPrevious = new WebGLRenderTarget2(1, 1, {\n      minFilter: NearestFilter,\n      magFilter: NearestFilter,\n      type: HalfFloatType,\n      stencilBuffer: false,\n      depthBuffer: false,\n      format: RGBAFormat\n    });\n    _this19.renderTargetPrevious.texture.name = \"Luminance.Previous\";\n\n    var uniforms = _this19.getFullscreenMaterial().uniforms;\n\n    uniforms.luminanceBuffer0.value = _this19.renderTargetPrevious.texture;\n    uniforms.luminanceBuffer1.value = luminanceBuffer;\n    uniforms.minLuminance.value = minLuminance;\n    _this19.renderTargetAdapted = _this19.renderTargetPrevious.clone();\n    _this19.renderTargetAdapted.texture.name = \"Luminance.Adapted\";\n    _this19.savePass = new SavePass(_this19.renderTargetPrevious, false);\n    _this19.adaptationRate = adaptationRate;\n    return _this19;\n  }\n\n  _createClass(AdaptiveLuminancePass, [{\n    key: \"texture\",\n    get: function get() {\n      return this.renderTargetAdapted.texture;\n    }\n  }, {\n    key: \"mipLevel1x1\",\n    set: function set(value) {\n      var material = this.getFullscreenMaterial();\n      material.defines.MIP_LEVEL_1X1 = value.toFixed(1);\n      material.needsUpdate = true;\n    }\n  }, {\n    key: \"adaptationRate\",\n    get: function get() {\n      return this.getFullscreenMaterial().uniforms.tau.value;\n    },\n    set: function set(value) {\n      this.getFullscreenMaterial().uniforms.tau.value = value;\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n      this.getFullscreenMaterial().uniforms.deltaTime.value = deltaTime;\n      renderer.setRenderTarget(this.renderToScreen ? null : this.renderTargetAdapted);\n      renderer.render(this.scene, this.camera);\n      this.savePass.render(renderer, this.renderTargetAdapted);\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize(renderer, alpha, frameBufferType) {\n      if (frameBufferType !== HalfFloatType) {\n        var capabilities = renderer.capabilities;\n        var context = renderer.getContext();\n\n        if (capabilities.isWebGL2) {\n          context.getExtension(\"EXT_color_buffer_float\");\n        } else {\n          context.getExtension(\"EXT_color_buffer_half_float\");\n        }\n      }\n    }\n  }]);\n\n  return AdaptiveLuminancePass;\n}(Pass); // src/passes/BlurPass.js\n\n\nimport { LinearFilter as LinearFilter2, RGBFormat as RGBFormat2, UnsignedByteType as UnsignedByteType2, WebGLRenderTarget as WebGLRenderTarget3 } from \"three\"; // src/core/Resizer.js\n\nimport { Vector2 as Vector211 } from \"three\";\nvar AUTO_SIZE = -1;\n\nvar Resizer = /*#__PURE__*/function () {\n  function Resizer(resizable) {\n    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AUTO_SIZE;\n    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : AUTO_SIZE;\n    var scale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    _classCallCheck(this, Resizer);\n\n    this.resizable = resizable;\n    this.base = new Vector211(1, 1);\n    this.target = new Vector211(width, height);\n    this.s = scale;\n  }\n\n  _createClass(Resizer, [{\n    key: \"scale\",\n    get: function get() {\n      return this.s;\n    },\n    set: function set(value) {\n      this.s = value;\n      this.target.x = AUTO_SIZE;\n      this.target.y = AUTO_SIZE;\n      this.resizable.setSize(this.base.x, this.base.y);\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      var base = this.base;\n      var target = this.target;\n      var result;\n\n      if (target.x !== AUTO_SIZE) {\n        result = target.x;\n      } else if (target.y !== AUTO_SIZE) {\n        result = Math.round(target.y * (base.x / base.y));\n      } else {\n        result = Math.round(base.x * this.s);\n      }\n\n      return result;\n    },\n    set: function set(value) {\n      this.target.x = value;\n      this.resizable.setSize(this.base.x, this.base.y);\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      var base = this.base;\n      var target = this.target;\n      var result;\n\n      if (target.y !== AUTO_SIZE) {\n        result = target.y;\n      } else if (target.x !== AUTO_SIZE) {\n        result = Math.round(target.x / (base.x / base.y));\n      } else {\n        result = Math.round(base.y * this.s);\n      }\n\n      return result;\n    },\n    set: function set(value) {\n      this.target.y = value;\n      this.resizable.setSize(this.base.x, this.base.y);\n    }\n  }], [{\n    key: \"AUTO_SIZE\",\n    get: function get() {\n      return AUTO_SIZE;\n    }\n  }]);\n\n  return Resizer;\n}(); // src/passes/BlurPass.js\n\n\nvar BlurPass = /*#__PURE__*/function (_Pass3) {\n  _inherits(BlurPass, _Pass3);\n\n  var _super20 = _createSuper(BlurPass);\n\n  function BlurPass() {\n    var _this20;\n\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$resolutionScale = _ref2.resolutionScale,\n        resolutionScale = _ref2$resolutionScale === void 0 ? 0.5 : _ref2$resolutionScale,\n        _ref2$width = _ref2.width,\n        width = _ref2$width === void 0 ? Resizer.AUTO_SIZE : _ref2$width,\n        _ref2$height = _ref2.height,\n        height = _ref2$height === void 0 ? Resizer.AUTO_SIZE : _ref2$height,\n        _ref2$kernelSize = _ref2.kernelSize,\n        kernelSize = _ref2$kernelSize === void 0 ? KernelSize.LARGE : _ref2$kernelSize;\n\n    _classCallCheck(this, BlurPass);\n\n    _this20 = _super20.call(this, \"BlurPass\");\n    _this20.renderTargetA = new WebGLRenderTarget3(1, 1, {\n      minFilter: LinearFilter2,\n      magFilter: LinearFilter2,\n      stencilBuffer: false,\n      depthBuffer: false\n    });\n    _this20.renderTargetA.texture.name = \"Blur.Target.A\";\n    _this20.renderTargetB = _this20.renderTargetA.clone();\n    _this20.renderTargetB.texture.name = \"Blur.Target.B\";\n    _this20.resolution = new Resizer(_assertThisInitialized(_this20), width, height, resolutionScale);\n    _this20.convolutionMaterial = new ConvolutionMaterial();\n    _this20.ditheredConvolutionMaterial = new ConvolutionMaterial();\n    _this20.ditheredConvolutionMaterial.dithering = true;\n    _this20.dithering = false;\n    _this20.kernelSize = kernelSize;\n    return _this20;\n  }\n\n  _createClass(BlurPass, [{\n    key: \"width\",\n    get: function get() {\n      return this.resolution.width;\n    },\n    set: function set(value) {\n      this.resolution.width = value;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.resolution.height;\n    },\n    set: function set(value) {\n      this.resolution.height = value;\n    }\n  }, {\n    key: \"scale\",\n    get: function get() {\n      return this.convolutionMaterial.uniforms.scale.value;\n    },\n    set: function set(value) {\n      this.convolutionMaterial.uniforms.scale.value = value;\n      this.ditheredConvolutionMaterial.uniforms.scale.value = value;\n    }\n  }, {\n    key: \"kernelSize\",\n    get: function get() {\n      return this.convolutionMaterial.kernelSize;\n    },\n    set: function set(value) {\n      this.convolutionMaterial.kernelSize = value;\n      this.ditheredConvolutionMaterial.kernelSize = value;\n    }\n  }, {\n    key: \"getResolutionScale\",\n    value: function getResolutionScale() {\n      return this.resolution.scale;\n    }\n  }, {\n    key: \"setResolutionScale\",\n    value: function setResolutionScale(scale) {\n      this.resolution.scale = scale;\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n      var scene = this.scene;\n      var camera = this.camera;\n      var renderTargetA = this.renderTargetA;\n      var renderTargetB = this.renderTargetB;\n      var material = this.convolutionMaterial;\n      var uniforms = material.uniforms;\n      var kernel = material.getKernel();\n      var lastRT = inputBuffer;\n      var destRT;\n      var i, l;\n      this.setFullscreenMaterial(material);\n\n      for (i = 0, l = kernel.length - 1; i < l; ++i) {\n        destRT = (i & 1) === 0 ? renderTargetA : renderTargetB;\n        uniforms.kernel.value = kernel[i];\n        uniforms.inputBuffer.value = lastRT.texture;\n        renderer.setRenderTarget(destRT);\n        renderer.render(scene, camera);\n        lastRT = destRT;\n      }\n\n      if (this.dithering) {\n        material = this.ditheredConvolutionMaterial;\n        uniforms = material.uniforms;\n        this.setFullscreenMaterial(material);\n      }\n\n      uniforms.kernel.value = kernel[i];\n      uniforms.inputBuffer.value = lastRT.texture;\n      renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n      renderer.render(scene, camera);\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      var resolution = this.resolution;\n      resolution.base.set(width, height);\n      var w = resolution.width;\n      var h = resolution.height;\n      this.renderTargetA.setSize(w, h);\n      this.renderTargetB.setSize(w, h);\n      this.convolutionMaterial.setTexelSize(1 / w, 1 / h);\n      this.ditheredConvolutionMaterial.setTexelSize(1 / w, 1 / h);\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize(renderer, alpha, frameBufferType) {\n      if (!alpha && frameBufferType === UnsignedByteType2) {\n        this.renderTargetA.texture.format = RGBFormat2;\n        this.renderTargetB.texture.format = RGBFormat2;\n      }\n\n      if (frameBufferType !== void 0) {\n        this.renderTargetA.texture.type = frameBufferType;\n        this.renderTargetB.texture.type = frameBufferType;\n      }\n    }\n  }], [{\n    key: \"AUTO_SIZE\",\n    get: function get() {\n      return Resizer.AUTO_SIZE;\n    }\n  }]);\n\n  return BlurPass;\n}(Pass); // src/passes/ClearMaskPass.js\n\n\nvar ClearMaskPass = /*#__PURE__*/function (_Pass4) {\n  _inherits(ClearMaskPass, _Pass4);\n\n  var _super21 = _createSuper(ClearMaskPass);\n\n  function ClearMaskPass() {\n    var _this21;\n\n    _classCallCheck(this, ClearMaskPass);\n\n    _this21 = _super21.call(this, \"ClearMaskPass\", null, null);\n    _this21.needsSwap = false;\n    return _this21;\n  }\n\n  _createClass(ClearMaskPass, [{\n    key: \"render\",\n    value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n      var stencil = renderer.state.buffers.stencil;\n      stencil.setLocked(false);\n      stencil.setTest(false);\n    }\n  }]);\n\n  return ClearMaskPass;\n}(Pass); // src/passes/ClearPass.js\n\n\nimport { Color } from \"three\";\nvar color = new Color();\n\nvar ClearPass = /*#__PURE__*/function (_Pass5) {\n  _inherits(ClearPass, _Pass5);\n\n  var _super22 = _createSuper(ClearPass);\n\n  function ClearPass() {\n    var _this22;\n\n    var color2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var stencil = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, ClearPass);\n\n    _this22 = _super22.call(this, \"ClearPass\", null, null);\n    _this22.needsSwap = false;\n    _this22.color = color2;\n    _this22.depth = depth;\n    _this22.stencil = stencil;\n    _this22.overrideClearColor = null;\n    _this22.overrideClearAlpha = -1;\n    return _this22;\n  }\n\n  _createClass(ClearPass, [{\n    key: \"render\",\n    value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n      var overrideClearColor = this.overrideClearColor;\n      var overrideClearAlpha = this.overrideClearAlpha;\n      var clearAlpha = renderer.getClearAlpha();\n      var hasOverrideClearColor = overrideClearColor !== null;\n      var hasOverrideClearAlpha = overrideClearAlpha >= 0;\n\n      if (hasOverrideClearColor) {\n        color.copy(renderer.getClearColor(color));\n        renderer.setClearColor(overrideClearColor, hasOverrideClearAlpha ? overrideClearAlpha : clearAlpha);\n      } else if (hasOverrideClearAlpha) {\n        renderer.setClearAlpha(overrideClearAlpha);\n      }\n\n      renderer.setRenderTarget(this.renderToScreen ? null : inputBuffer);\n      renderer.clear(this.color, this.depth, this.stencil);\n\n      if (hasOverrideClearColor) {\n        renderer.setClearColor(color, clearAlpha);\n      } else if (hasOverrideClearAlpha) {\n        renderer.setClearAlpha(clearAlpha);\n      }\n    }\n  }]);\n\n  return ClearPass;\n}(Pass); // src/passes/DepthPass.js\n\n\nimport { Color as Color2, MeshDepthMaterial, NearestFilter as NearestFilter2, RGBADepthPacking, WebGLRenderTarget as WebGLRenderTarget4 } from \"three\"; // src/core/OverrideMaterialManager.js\n\nimport { BackSide, DoubleSide, FrontSide } from \"three\";\nvar workaroundEnabled = false;\n\nvar OverrideMaterialManager = /*#__PURE__*/function () {\n  function OverrideMaterialManager() {\n    var _this23 = this;\n\n    var material = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, OverrideMaterialManager);\n\n    this.originalMaterials = new Map();\n    this.material = null;\n    this.materials = null;\n    this.materialsBackSide = null;\n    this.materialsDoubleSide = null;\n    this.setMaterial(material);\n    this.meshCount = 0;\n\n    this.replaceMaterial = function (node) {\n      if (node.isMesh) {\n        var materials;\n\n        switch (node.material.side) {\n          case DoubleSide:\n            materials = _this23.materialsDoubleSide;\n            break;\n\n          case BackSide:\n            materials = _this23.materialsBackSide;\n            break;\n\n          default:\n            materials = _this23.materials;\n            break;\n        }\n\n        _this23.originalMaterials.set(node, node.material);\n\n        if (node.isSkinnedMesh) {\n          node.material = materials[2];\n        } else if (node.isInstancedMesh) {\n          node.material = materials[1];\n        } else {\n          node.material = materials[0];\n        }\n\n        ++_this23.meshCount;\n      }\n    };\n  }\n\n  _createClass(OverrideMaterialManager, [{\n    key: \"setMaterial\",\n    value: function setMaterial(material) {\n      this.disposeMaterials();\n      this.material = material;\n\n      if (material !== null) {\n        var materials = this.materials = [material.clone(), material.clone(), material.clone()];\n\n        for (var _i4 = 0, _materials = materials; _i4 < _materials.length; _i4++) {\n          var m2 = _materials[_i4];\n          m2.uniforms = Object.assign({}, material.uniforms);\n          m2.side = FrontSide;\n        }\n\n        materials[2].skinning = true;\n        this.materialsBackSide = materials.map(function (m2) {\n          var c2 = m2.clone();\n          c2.uniforms = Object.assign({}, material.uniforms);\n          c2.side = BackSide;\n          return c2;\n        });\n        this.materialsDoubleSide = materials.map(function (m2) {\n          var c2 = m2.clone();\n          c2.uniforms = Object.assign({}, material.uniforms);\n          c2.side = DoubleSide;\n          return c2;\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, scene, camera) {\n      var shadowMapEnabled = renderer.shadowMap.enabled;\n      renderer.shadowMap.enabled = false;\n\n      if (workaroundEnabled) {\n        var originalMaterials = this.originalMaterials;\n        this.meshCount = 0;\n        scene.traverse(this.replaceMaterial);\n        renderer.render(scene, camera);\n\n        var _iterator3 = _createForOfIteratorHelper(originalMaterials),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var entry = _step3.value;\n            entry[0].material = entry[1];\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        if (this.meshCount !== originalMaterials.size) {\n          originalMaterials.clear();\n        }\n      } else {\n        var overrideMaterial = scene.overrideMaterial;\n        scene.overrideMaterial = this.material;\n        renderer.render(scene, camera);\n        scene.overrideMaterial = overrideMaterial;\n      }\n\n      renderer.shadowMap.enabled = shadowMapEnabled;\n    }\n  }, {\n    key: \"disposeMaterials\",\n    value: function disposeMaterials() {\n      if (this.material !== null) {\n        var materials = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide);\n\n        var _iterator4 = _createForOfIteratorHelper(materials),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var m2 = _step4.value;\n            m2.dispose();\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.originalMaterials.clear();\n      this.disposeMaterials();\n    }\n  }], [{\n    key: \"workaroundEnabled\",\n    get: function get() {\n      return workaroundEnabled;\n    },\n    set: function set(value) {\n      workaroundEnabled = value;\n    }\n  }]);\n\n  return OverrideMaterialManager;\n}(); // src/passes/RenderPass.js\n\n\nvar RenderPass = /*#__PURE__*/function (_Pass6) {\n  _inherits(RenderPass, _Pass6);\n\n  var _super23 = _createSuper(RenderPass);\n\n  function RenderPass(scene, camera) {\n    var _this24;\n\n    var overrideMaterial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, RenderPass);\n\n    _this24 = _super23.call(this, \"RenderPass\", scene, camera);\n    _this24.needsSwap = false;\n    _this24.clearPass = new ClearPass();\n    _this24.overrideMaterialManager = overrideMaterial === null ? null : new OverrideMaterialManager(overrideMaterial);\n    return _this24;\n  }\n\n  _createClass(RenderPass, [{\n    key: \"renderToScreen\",\n    get: function get() {\n      return _get(_getPrototypeOf(RenderPass.prototype), \"renderToScreen\", this);\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(RenderPass.prototype), \"renderToScreen\", value, this, true);\n\n      this.clearPass.renderToScreen = value;\n    }\n  }, {\n    key: \"overrideMaterial\",\n    get: function get() {\n      var manager = this.overrideMaterialManager;\n      return manager !== null ? manager.material : null;\n    },\n    set: function set(value) {\n      var manager = this.overrideMaterialManager;\n\n      if (value !== null) {\n        if (manager !== null) {\n          manager.setMaterial(value);\n        } else {\n          this.overrideMaterialManager = new OverrideMaterialManager(value);\n        }\n      } else if (manager !== null) {\n        manager.dispose();\n        this.overrideMaterialManager = null;\n      }\n    }\n  }, {\n    key: \"clear\",\n    get: function get() {\n      return this.clearPass.enabled;\n    },\n    set: function set(value) {\n      this.clearPass.enabled = value;\n    }\n  }, {\n    key: \"getClearPass\",\n    value: function getClearPass() {\n      return this.clearPass;\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n      var scene = this.scene;\n      var camera = this.camera;\n      var background = scene.background;\n      var renderTarget = this.renderToScreen ? null : inputBuffer;\n\n      if (this.clear) {\n        if (this.clearPass.overrideClearColor !== null) {\n          scene.background = null;\n        }\n\n        this.clearPass.render(renderer, inputBuffer);\n      }\n\n      renderer.setRenderTarget(renderTarget);\n\n      if (this.overrideMaterialManager !== null) {\n        this.overrideMaterialManager.render(renderer, scene, camera);\n      } else {\n        renderer.render(scene, camera);\n      }\n\n      if (scene.background !== background) {\n        scene.background = background;\n      }\n    }\n  }]);\n\n  return RenderPass;\n}(Pass); // src/passes/DepthPass.js\n\n\nvar DepthPass = /*#__PURE__*/function (_Pass7) {\n  _inherits(DepthPass, _Pass7);\n\n  var _super24 = _createSuper(DepthPass);\n\n  function DepthPass(scene, camera) {\n    var _this25;\n\n    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref3$resolutionScale = _ref3.resolutionScale,\n        resolutionScale = _ref3$resolutionScale === void 0 ? 1 : _ref3$resolutionScale,\n        _ref3$width = _ref3.width,\n        width = _ref3$width === void 0 ? Resizer.AUTO_SIZE : _ref3$width,\n        _ref3$height = _ref3.height,\n        height = _ref3$height === void 0 ? Resizer.AUTO_SIZE : _ref3$height,\n        renderTarget = _ref3.renderTarget;\n\n    _classCallCheck(this, DepthPass);\n\n    _this25 = _super24.call(this, \"DepthPass\");\n    _this25.needsSwap = false;\n    _this25.renderPass = new RenderPass(scene, camera, new MeshDepthMaterial({\n      depthPacking: RGBADepthPacking\n    }));\n\n    var clearPass = _this25.renderPass.getClearPass();\n\n    clearPass.overrideClearColor = new Color2(16777215);\n    clearPass.overrideClearAlpha = 1;\n    _this25.renderTarget = renderTarget;\n\n    if (_this25.renderTarget === void 0) {\n      _this25.renderTarget = new WebGLRenderTarget4(1, 1, {\n        minFilter: NearestFilter2,\n        magFilter: NearestFilter2,\n        stencilBuffer: false\n      });\n      _this25.renderTarget.texture.name = \"DepthPass.Target\";\n    }\n\n    _this25.resolution = new Resizer(_assertThisInitialized(_this25), width, height, resolutionScale);\n    return _this25;\n  }\n\n  _createClass(DepthPass, [{\n    key: \"texture\",\n    get: function get() {\n      return this.renderTarget.texture;\n    }\n  }, {\n    key: \"getResolutionScale\",\n    value: function getResolutionScale() {\n      return this.resolutionScale;\n    }\n  }, {\n    key: \"setResolutionScale\",\n    value: function setResolutionScale(scale) {\n      this.resolutionScale = scale;\n      this.setSize(this.resolution.base.x, this.resolution.base.y);\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n      var renderTarget = this.renderToScreen ? null : this.renderTarget;\n      this.renderPass.render(renderer, renderTarget);\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      var resolution = this.resolution;\n      resolution.base.set(width, height);\n      this.renderTarget.setSize(resolution.width, resolution.height);\n    }\n  }]);\n\n  return DepthPass;\n}(Pass); // src/passes/DepthDownsamplingPass.js\n\n\nimport { FloatType, NearestFilter as NearestFilter3, WebGLRenderTarget as WebGLRenderTarget5 } from \"three\";\n\nvar DepthDownsamplingPass = /*#__PURE__*/function (_Pass8) {\n  _inherits(DepthDownsamplingPass, _Pass8);\n\n  var _super25 = _createSuper(DepthDownsamplingPass);\n\n  function DepthDownsamplingPass() {\n    var _this26;\n\n    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref4$normalBuffer = _ref4.normalBuffer,\n        normalBuffer = _ref4$normalBuffer === void 0 ? null : _ref4$normalBuffer,\n        _ref4$resolutionScale = _ref4.resolutionScale,\n        resolutionScale = _ref4$resolutionScale === void 0 ? 0.5 : _ref4$resolutionScale,\n        _ref4$width = _ref4.width,\n        width = _ref4$width === void 0 ? Resizer.AUTO_SIZE : _ref4$width,\n        _ref4$height = _ref4.height,\n        height = _ref4$height === void 0 ? Resizer.AUTO_SIZE : _ref4$height;\n\n    _classCallCheck(this, DepthDownsamplingPass);\n\n    _this26 = _super25.call(this, \"DepthDownsamplingPass\");\n\n    _this26.setFullscreenMaterial(new DepthDownsamplingMaterial());\n\n    _this26.needsDepthTexture = true;\n    _this26.needsSwap = false;\n\n    if (normalBuffer !== null) {\n      var material = _this26.getFullscreenMaterial();\n\n      material.uniforms.normalBuffer.value = normalBuffer;\n      material.defines.DOWNSAMPLE_NORMALS = \"1\";\n    }\n\n    _this26.renderTarget = new WebGLRenderTarget5(1, 1, {\n      minFilter: NearestFilter3,\n      magFilter: NearestFilter3,\n      stencilBuffer: false,\n      depthBuffer: false,\n      type: FloatType\n    });\n    _this26.renderTarget.texture.name = \"DepthDownsamplingPass.Target\";\n    _this26.renderTarget.texture.generateMipmaps = false;\n    _this26.resolution = new Resizer(_assertThisInitialized(_this26), width, height);\n    _this26.resolution.scale = resolutionScale;\n    return _this26;\n  }\n\n  _createClass(DepthDownsamplingPass, [{\n    key: \"texture\",\n    get: function get() {\n      return this.renderTarget.texture;\n    }\n  }, {\n    key: \"setDepthTexture\",\n    value: function setDepthTexture(depthTexture) {\n      var depthPacking = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var material = this.getFullscreenMaterial();\n      material.uniforms.depthBuffer.value = depthTexture;\n      material.depthPacking = depthPacking;\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n      renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n      renderer.render(this.scene, this.camera);\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      var resolution = this.resolution;\n      resolution.base.set(width, height);\n      this.getFullscreenMaterial().setTexelSize(1 / width, 1 / height);\n      this.renderTarget.setSize(resolution.width, resolution.height);\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize(renderer, alpha, frameBufferType) {\n      if (!renderer.capabilities.isWebGL2) {\n        console.error(\"The DepthDownsamplingPass requires WebGL 2\");\n      }\n    }\n  }]);\n\n  return DepthDownsamplingPass;\n}(Pass); // src/effects/blending/BlendFunction.js\n\n\nvar BlendFunction = {\n  SKIP: 0,\n  ADD: 1,\n  ALPHA: 2,\n  AVERAGE: 3,\n  COLOR_BURN: 4,\n  COLOR_DODGE: 5,\n  DARKEN: 6,\n  DIFFERENCE: 7,\n  EXCLUSION: 8,\n  LIGHTEN: 9,\n  MULTIPLY: 10,\n  DIVIDE: 11,\n  NEGATION: 12,\n  NORMAL: 13,\n  OVERLAY: 14,\n  REFLECT: 15,\n  SCREEN: 16,\n  SOFT_LIGHT: 17,\n  SUBTRACT: 18\n}; // src/effects/blending/BlendMode.js\n\nimport { EventDispatcher, Uniform as Uniform18 } from \"three\"; // src/effects/blending/glsl/add/shader.frag\n\nvar shader_default26 = \"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\treturn min(x + y, 1.0) * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/alpha/shader.frag\n\nvar shader_default27 = \"vec3 blend(const in vec3 x, const in vec3 y, const in float opacity) {\\r\\n\\r\\n\treturn y * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\\r\\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\tfloat a = min(y.a, opacity);\\r\\n\\r\\n\treturn vec4(blend(x.rgb, y.rgb, a), max(x.a, a));\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/average/shader.frag\n\nvar shader_default28 = \"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\treturn (x + y) * 0.5 * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/color-burn/shader.frag\n\nvar shader_default29 = \"float blend(const in float x, const in float y) {\\r\\n\\r\\n\treturn (y == 0.0) ? y : max(1.0 - (1.0 - x) / y, 0.0);\\r\\n\\r\\n}\\r\\n\\r\\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\tvec4 z = vec4(blend(x.r, y.r), blend(x.g, y.g), blend(x.b, y.b), blend(x.a, y.a));\\r\\n\\r\\n\treturn z * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/color-dodge/shader.frag\n\nvar shader_default30 = \"float blend(const in float x, const in float y) {\\r\\n\\r\\n\treturn (y == 1.0) ? y : min(x / (1.0 - y), 1.0);\\r\\n\\r\\n}\\r\\n\\r\\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\tvec4 z = vec4(blend(x.r, y.r), blend(x.g, y.g), blend(x.b, y.b), blend(x.a, y.a));\\r\\n\\r\\n\treturn z * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/darken/shader.frag\n\nvar shader_default31 = \"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\treturn min(x, y) * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/difference/shader.frag\n\nvar shader_default32 = \"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\treturn abs(x - y) * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/exclusion/shader.frag\n\nvar shader_default33 = \"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\treturn (x + y - 2.0 * x * y) * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/lighten/shader.frag\n\nvar shader_default34 = \"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\treturn max(x, y) * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/multiply/shader.frag\n\nvar shader_default35 = \"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\treturn x * y * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/divide/shader.frag\n\nvar shader_default36 = \"float blend(const in float x, const in float y) {\\r\\n\\r\\n\treturn (y > 0.0) ? min(x / y, 1.0) : 1.0;\\r\\n\\r\\n}\\r\\n\\r\\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\tvec4 z = vec4(blend(x.r, y.r), blend(x.g, y.g), blend(x.b, y.b), blend(x.a, y.a));\\r\\n\\r\\n\treturn z * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/negation/shader.frag\n\nvar shader_default37 = \"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\treturn (1.0 - abs(1.0 - x - y)) * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/normal/shader.frag\n\nvar shader_default38 = \"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\treturn y * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/overlay/shader.frag\n\nvar shader_default39 = \"float blend(const in float x, const in float y) {\\r\\n\\r\\n\treturn (x < 0.5) ? (2.0 * x * y) : (1.0 - 2.0 * (1.0 - x) * (1.0 - y));\\r\\n\\r\\n}\\r\\n\\r\\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\tvec4 z = vec4(blend(x.r, y.r), blend(x.g, y.g), blend(x.b, y.b), blend(x.a, y.a));\\r\\n\\r\\n\treturn z * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/reflect/shader.frag\n\nvar shader_default40 = \"float blend(const in float x, const in float y) {\\r\\n\\r\\n\treturn (y == 1.0) ? y : min(x * x / (1.0 - y), 1.0);\\r\\n\\r\\n}\\r\\n\\r\\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\tvec4 z = vec4(blend(x.r, y.r), blend(x.g, y.g), blend(x.b, y.b), blend(x.a, y.a));\\r\\n\\r\\n\treturn z * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/screen/shader.frag\n\nvar shader_default41 = \"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\treturn (1.0 - (1.0 - x) * (1.0 - y)) * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/soft-light/shader.frag\n\nvar shader_default42 = \"float blend(const in float x, const in float y) {\\r\\n\\r\\n\treturn (y < 0.5) ?\\r\\n\t\t(2.0 * x * y + x * x * (1.0 - 2.0 * y)) :\\r\\n\t\t(sqrt(x) * (2.0 * y - 1.0) + 2.0 * x * (1.0 - y));\\r\\n\\r\\n}\\r\\n\\r\\nvec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\tvec4 z = vec4(blend(x.r, y.r), blend(x.g, y.g), blend(x.b, y.b), blend(x.a, y.a));\\r\\n\\r\\n\treturn z * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/glsl/subtract/shader.frag\n\nvar shader_default43 = \"vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {\\r\\n\\r\\n\treturn max(x + y - 1.0, 0.0) * opacity + x * (1.0 - opacity);\\r\\n\\r\\n}\\r\\n\"; // src/effects/blending/BlendMode.js\n\nvar blendFunctions = new Map([[BlendFunction.SKIP, null], [BlendFunction.ADD, shader_default26], [BlendFunction.ALPHA, shader_default27], [BlendFunction.AVERAGE, shader_default28], [BlendFunction.COLOR_BURN, shader_default29], [BlendFunction.COLOR_DODGE, shader_default30], [BlendFunction.DARKEN, shader_default31], [BlendFunction.DIFFERENCE, shader_default32], [BlendFunction.EXCLUSION, shader_default33], [BlendFunction.LIGHTEN, shader_default34], [BlendFunction.MULTIPLY, shader_default35], [BlendFunction.DIVIDE, shader_default36], [BlendFunction.NEGATION, shader_default37], [BlendFunction.NORMAL, shader_default38], [BlendFunction.OVERLAY, shader_default39], [BlendFunction.REFLECT, shader_default40], [BlendFunction.SCREEN, shader_default41], [BlendFunction.SOFT_LIGHT, shader_default42], [BlendFunction.SUBTRACT, shader_default43]]);\n\nvar BlendMode = /*#__PURE__*/function (_EventDispatcher) {\n  _inherits(BlendMode, _EventDispatcher);\n\n  var _super26 = _createSuper(BlendMode);\n\n  function BlendMode(blendFunction) {\n    var _this27;\n\n    var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    _classCallCheck(this, BlendMode);\n\n    _this27 = _super26.call(this);\n    _this27.blendFunction = blendFunction;\n    _this27.opacity = new Uniform18(opacity);\n    return _this27;\n  }\n\n  _createClass(BlendMode, [{\n    key: \"getBlendFunction\",\n    value: function getBlendFunction() {\n      return this.blendFunction;\n    }\n  }, {\n    key: \"setBlendFunction\",\n    value: function setBlendFunction(blendFunction) {\n      this.blendFunction = blendFunction;\n      this.dispatchEvent({\n        type: \"change\"\n      });\n    }\n  }, {\n    key: \"getShaderCode\",\n    value: function getShaderCode() {\n      return blendFunctions.get(this.blendFunction);\n    }\n  }]);\n\n  return BlendMode;\n}(EventDispatcher); // src/effects/Effect.js\n\n\nimport { EventDispatcher as EventDispatcher2, Scene as Scene2 } from \"three\";\n\nvar Effect = /*#__PURE__*/function (_EventDispatcher2) {\n  _inherits(Effect, _EventDispatcher2);\n\n  var _super27 = _createSuper(Effect);\n\n  function Effect(name, fragmentShader) {\n    var _this28;\n\n    var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref5$attributes = _ref5.attributes,\n        attributes = _ref5$attributes === void 0 ? EffectAttribute.NONE : _ref5$attributes,\n        _ref5$blendFunction = _ref5.blendFunction,\n        blendFunction = _ref5$blendFunction === void 0 ? BlendFunction.SCREEN : _ref5$blendFunction,\n        _ref5$defines = _ref5.defines,\n        defines = _ref5$defines === void 0 ? new Map() : _ref5$defines,\n        _ref5$uniforms = _ref5.uniforms,\n        uniforms = _ref5$uniforms === void 0 ? new Map() : _ref5$uniforms,\n        _ref5$extensions = _ref5.extensions,\n        extensions = _ref5$extensions === void 0 ? null : _ref5$extensions,\n        _ref5$vertexShader = _ref5.vertexShader,\n        vertexShader = _ref5$vertexShader === void 0 ? null : _ref5$vertexShader;\n\n    _classCallCheck(this, Effect);\n\n    _this28 = _super27.call(this);\n    _this28.name = name;\n    _this28.attributes = attributes;\n    _this28.fragmentShader = fragmentShader;\n    _this28.vertexShader = vertexShader;\n    _this28.defines = defines;\n    _this28.uniforms = uniforms;\n    _this28.extensions = extensions;\n    _this28.blendMode = new BlendMode(blendFunction);\n\n    _this28.blendMode.addEventListener(\"change\", function (event) {\n      return _this28.setChanged();\n    });\n\n    return _this28;\n  }\n\n  _createClass(Effect, [{\n    key: \"setChanged\",\n    value: function setChanged() {\n      this.dispatchEvent({\n        type: \"change\"\n      });\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes(attributes) {\n      this.attributes = attributes;\n      this.setChanged();\n    }\n  }, {\n    key: \"getFragmentShader\",\n    value: function getFragmentShader() {\n      return this.fragmentShader;\n    }\n  }, {\n    key: \"setFragmentShader\",\n    value: function setFragmentShader(fragmentShader) {\n      this.fragmentShader = fragmentShader;\n      this.setChanged();\n    }\n  }, {\n    key: \"getVertexShader\",\n    value: function getVertexShader() {\n      return this.vertexShader;\n    }\n  }, {\n    key: \"setVertexShader\",\n    value: function setVertexShader(vertexShader) {\n      this.vertexShader = vertexShader;\n      this.setChanged();\n    }\n  }, {\n    key: \"setDepthTexture\",\n    value: function setDepthTexture(depthTexture) {\n      var depthPacking = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    }\n  }, {\n    key: \"update\",\n    value: function update(renderer, inputBuffer, deltaTime) {}\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {}\n  }, {\n    key: \"initialize\",\n    value: function initialize(renderer, alpha, frameBufferType) {}\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      for (var _i5 = 0, _Object$keys2 = Object.keys(this); _i5 < _Object$keys2.length; _i5++) {\n        var key = _Object$keys2[_i5];\n        var property = this[key];\n\n        if (property !== null && typeof property.dispose === \"function\") {\n          if (property instanceof Scene2) {\n            continue;\n          }\n\n          this[key].dispose();\n        }\n      }\n    }\n  }]);\n\n  return Effect;\n}(EventDispatcher2);\n\nvar EffectAttribute = {\n  NONE: 0,\n  DEPTH: 1,\n  CONVOLUTION: 2\n};\nvar WebGLExtension = {\n  DERIVATIVES: \"derivatives\",\n  FRAG_DEPTH: \"fragDepth\",\n  DRAW_BUFFERS: \"drawBuffers\",\n  SHADER_TEXTURE_LOD: \"shaderTextureLOD\"\n}; // src/passes/EffectPass.js\n\nfunction findSubstrings(regExp, string) {\n  var substrings = [];\n  var result;\n\n  while ((result = regExp.exec(string)) !== null) {\n    substrings.push(result[1]);\n  }\n\n  return substrings;\n}\n\nfunction prefixSubstrings(prefix, substrings, strings) {\n  var prefixed, regExp;\n\n  var _iterator5 = _createForOfIteratorHelper(substrings),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var substring = _step5.value;\n      prefixed = \"$1\" + prefix + substring.charAt(0).toUpperCase() + substring.slice(1);\n      regExp = new RegExp(\"([^\\\\.])(\\\\b\" + substring + \"\\\\b)\", \"g\");\n\n      var _iterator6 = _createForOfIteratorHelper(strings.entries()),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var entry = _step6.value;\n\n          if (entry[1] !== null) {\n            strings.set(entry[0], entry[1].replace(regExp, prefixed));\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n}\n\nfunction integrateEffect(prefix, effect, shaderParts, blendModes, defines, uniforms, attributes) {\n  var functionRegExp = /(?:\\w+\\s+(\\w+)\\([\\w\\s,]*\\)\\s*{[^}]+})/g;\n  var varyingRegExp = /(?:varying\\s+\\w+\\s+(\\w*))/g;\n  var blendMode = effect.blendMode;\n  var shaders = new Map([[\"fragment\", effect.getFragmentShader()], [\"vertex\", effect.getVertexShader()]]);\n  var mainImageExists = shaders.get(\"fragment\") !== void 0 && /mainImage/.test(shaders.get(\"fragment\"));\n  var mainUvExists = shaders.get(\"fragment\") !== void 0 && /mainUv/.test(shaders.get(\"fragment\"));\n  var varyings = [],\n      names = [];\n  var transformedUv = false;\n  var readDepth = false;\n\n  if (shaders.get(\"fragment\") === void 0) {\n    console.error(\"Missing fragment shader\", effect);\n  } else if (mainUvExists && (attributes & EffectAttribute.CONVOLUTION) !== 0) {\n    console.error(\"Effects that transform UV coordinates are incompatible with convolution effects\", effect);\n  } else if (!mainImageExists && !mainUvExists) {\n    console.error(\"The fragment shader contains neither a mainImage nor a mainUv function\", effect);\n  } else {\n    if (mainUvExists) {\n      shaderParts.set(Section.FRAGMENT_MAIN_UV, shaderParts.get(Section.FRAGMENT_MAIN_UV) + \"\t\" + prefix + \"MainUv(UV);\\n\");\n      transformedUv = true;\n    }\n\n    if (shaders.get(\"vertex\") !== null && /mainSupport/.test(shaders.get(\"vertex\"))) {\n      var string = \"\t\" + prefix + \"MainSupport(\";\n\n      if (/mainSupport *\\([\\w\\s]*?uv\\s*?\\)/.test(shaders.get(\"vertex\"))) {\n        string += \"vUv\";\n      }\n\n      string += \");\\n\";\n      shaderParts.set(Section.VERTEX_MAIN_SUPPORT, shaderParts.get(Section.VERTEX_MAIN_SUPPORT) + string);\n      varyings = varyings.concat(findSubstrings(varyingRegExp, shaders.get(\"vertex\")));\n      names = names.concat(varyings).concat(findSubstrings(functionRegExp, shaders.get(\"vertex\")));\n    }\n\n    names = names.concat(findSubstrings(functionRegExp, shaders.get(\"fragment\"))).concat(Array.from(effect.defines.keys()).map(function (s) {\n      return s.replace(/\\([\\w\\s,]*\\)/g, \"\");\n    })).concat(Array.from(effect.uniforms.keys()));\n    effect.uniforms.forEach(function (value, key) {\n      return uniforms.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), value);\n    });\n    effect.defines.forEach(function (value, key) {\n      return defines.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), value);\n    });\n    prefixSubstrings(prefix, names, defines);\n    prefixSubstrings(prefix, names, shaders);\n    blendModes.set(blendMode.blendFunction, blendMode);\n\n    if (mainImageExists) {\n      var depthParamRegExp = /MainImage *\\([\\w\\s,]*?depth[\\w\\s,]*?\\)/;\n\n      var _string = prefix + \"MainImage(color0, UV, \";\n\n      if ((attributes & EffectAttribute.DEPTH) !== 0 && depthParamRegExp.test(shaders.get(\"fragment\"))) {\n        _string += \"depth, \";\n        readDepth = true;\n      }\n\n      _string += \"color1);\\n\t\";\n      var blendOpacity = prefix + \"BlendOpacity\";\n      uniforms.set(blendOpacity, blendMode.opacity);\n      _string += \"color0 = blend\" + blendMode.getBlendFunction() + \"(color0, color1, \" + blendOpacity + \");\\n\\n\t\";\n      shaderParts.set(Section.FRAGMENT_MAIN_IMAGE, shaderParts.get(Section.FRAGMENT_MAIN_IMAGE) + _string);\n      shaderParts.set(Section.FRAGMENT_HEAD, shaderParts.get(Section.FRAGMENT_HEAD) + \"uniform float \" + blendOpacity + \";\\n\\n\");\n    }\n\n    shaderParts.set(Section.FRAGMENT_HEAD, shaderParts.get(Section.FRAGMENT_HEAD) + shaders.get(\"fragment\") + \"\\n\");\n\n    if (shaders.get(\"vertex\") !== null) {\n      shaderParts.set(Section.VERTEX_HEAD, shaderParts.get(Section.VERTEX_HEAD) + shaders.get(\"vertex\") + \"\\n\");\n    }\n  }\n\n  return {\n    varyings: varyings,\n    transformedUv: transformedUv,\n    readDepth: readDepth\n  };\n}\n\nvar EffectPass = /*#__PURE__*/function (_Pass9) {\n  _inherits(EffectPass, _Pass9);\n\n  var _super28 = _createSuper(EffectPass);\n\n  function EffectPass(camera) {\n    var _this29;\n\n    _classCallCheck(this, EffectPass);\n\n    _this29 = _super28.call(this, \"EffectPass\");\n\n    _this29.setFullscreenMaterial(new EffectMaterial(null, null, null, camera));\n\n    for (var _len = arguments.length, effects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      effects[_key - 1] = arguments[_key];\n    }\n\n    _this29.effects = effects.sort(function (a, b) {\n      return b.attributes - a.attributes;\n    });\n    _this29.skipRendering = false;\n    _this29.uniforms = 0;\n    _this29.varyings = 0;\n    _this29.minTime = 1;\n    _this29.maxTime = Number.POSITIVE_INFINITY;\n    return _this29;\n  }\n\n  _createClass(EffectPass, [{\n    key: \"encodeOutput\",\n    get: function get() {\n      return this.getFullscreenMaterial().defines.ENCODE_OUTPUT !== void 0;\n    },\n    set: function set(value) {\n      if (this.encodeOutput !== value) {\n        var material = this.getFullscreenMaterial();\n        material.needsUpdate = true;\n\n        if (value) {\n          material.defines.ENCODE_OUTPUT = \"1\";\n        } else {\n          delete material.defines.ENCODE_OUTPUT;\n        }\n      }\n    }\n  }, {\n    key: \"dithering\",\n    get: function get() {\n      return this.getFullscreenMaterial().dithering;\n    },\n    set: function set(value) {\n      var material = this.getFullscreenMaterial();\n\n      if (material.dithering !== value) {\n        material.dithering = value;\n        material.needsUpdate = true;\n      }\n    }\n  }, {\n    key: \"verifyResources\",\n    value: function verifyResources(renderer) {\n      var capabilities = renderer.capabilities;\n      var max = Math.min(capabilities.maxFragmentUniforms, capabilities.maxVertexUniforms);\n\n      if (this.uniforms > max) {\n        console.warn(\"The current rendering context doesn't support more than \" + max + \" uniforms, but \" + this.uniforms + \" were defined\");\n      }\n\n      max = capabilities.maxVaryings;\n\n      if (this.varyings > max) {\n        console.warn(\"The current rendering context doesn't support more than \" + max + \" varyings, but \" + this.varyings + \" were defined\");\n      }\n    }\n  }, {\n    key: \"updateMaterial\",\n    value: function updateMaterial() {\n      var blendRegExp = /\\bblend\\b/g;\n      var shaderParts = new Map([[Section.FRAGMENT_HEAD, \"\"], [Section.FRAGMENT_MAIN_UV, \"\"], [Section.FRAGMENT_MAIN_IMAGE, \"\"], [Section.VERTEX_HEAD, \"\"], [Section.VERTEX_MAIN_SUPPORT, \"\"]]);\n      var blendModes = new Map();\n      var defines = new Map();\n      var uniforms = new Map();\n      var extensions = new Set();\n      var id = 0,\n          varyings = 0,\n          attributes = 0;\n      var transformedUv = false;\n      var readDepth = false;\n      var result;\n\n      var _iterator7 = _createForOfIteratorHelper(this.effects),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var effect = _step7.value;\n\n          if (effect.blendMode.getBlendFunction() === BlendFunction.SKIP) {\n            attributes |= effect.getAttributes() & EffectAttribute.DEPTH;\n          } else if ((attributes & EffectAttribute.CONVOLUTION) !== 0 && (effect.getAttributes() & EffectAttribute.CONVOLUTION) !== 0) {\n            console.error(\"Convolution effects cannot be merged\", effect);\n          } else {\n            attributes |= effect.getAttributes();\n            result = integrateEffect(\"e\" + id++, effect, shaderParts, blendModes, defines, uniforms, attributes);\n            varyings += result.varyings.length;\n            transformedUv = transformedUv || result.transformedUv;\n            readDepth = readDepth || result.readDepth;\n\n            if (effect.extensions !== null) {\n              var _iterator10 = _createForOfIteratorHelper(effect.extensions),\n                  _step10;\n\n              try {\n                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                  var _extension = _step10.value;\n                  extensions.add(_extension);\n                }\n              } catch (err) {\n                _iterator10.e(err);\n              } finally {\n                _iterator10.f();\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      var _iterator8 = _createForOfIteratorHelper(blendModes.values()),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var blendMode = _step8.value;\n          shaderParts.set(Section.FRAGMENT_HEAD, shaderParts.get(Section.FRAGMENT_HEAD) + blendMode.getShaderCode().replace(blendRegExp, \"blend\" + blendMode.getBlendFunction()) + \"\\n\");\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      if ((attributes & EffectAttribute.DEPTH) !== 0) {\n        if (readDepth) {\n          shaderParts.set(Section.FRAGMENT_MAIN_IMAGE, \"float depth = readDepth(UV);\\n\\n\t\" + shaderParts.get(Section.FRAGMENT_MAIN_IMAGE));\n        }\n\n        this.needsDepthTexture = this.getDepthTexture() === null;\n      } else {\n        this.needsDepthTexture = false;\n      }\n\n      if (transformedUv) {\n        shaderParts.set(Section.FRAGMENT_MAIN_UV, \"vec2 transformedUv = vUv;\\n\" + shaderParts.get(Section.FRAGMENT_MAIN_UV));\n        defines.set(\"UV\", \"transformedUv\");\n      } else {\n        defines.set(\"UV\", \"vUv\");\n      }\n\n      shaderParts.forEach(function (value, key, map) {\n        return map.set(key, value.trim().replace(/^#/, \"\\n#\"));\n      });\n      this.uniforms = uniforms.size;\n      this.varyings = varyings;\n      this.skipRendering = id === 0;\n      this.needsSwap = !this.skipRendering;\n      var material = this.getFullscreenMaterial();\n      material.setShaderParts(shaderParts).setDefines(defines).setUniforms(uniforms);\n      material.extensions = {};\n\n      if (extensions.size > 0) {\n        var _iterator9 = _createForOfIteratorHelper(extensions),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var extension = _step9.value;\n            material.extensions[extension] = true;\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n      }\n\n      this.needsUpdate = false;\n    }\n  }, {\n    key: \"recompile\",\n    value: function recompile(renderer) {\n      this.updateMaterial();\n\n      if (renderer !== void 0) {\n        this.verifyResources(renderer);\n      }\n    }\n  }, {\n    key: \"getDepthTexture\",\n    value: function getDepthTexture() {\n      return this.getFullscreenMaterial().uniforms.depthBuffer.value;\n    }\n  }, {\n    key: \"setDepthTexture\",\n    value: function setDepthTexture(depthTexture) {\n      var depthPacking = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var material = this.getFullscreenMaterial();\n      material.uniforms.depthBuffer.value = depthTexture;\n      material.depthPacking = depthPacking;\n      material.needsUpdate = true;\n\n      var _iterator11 = _createForOfIteratorHelper(this.effects),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var effect = _step11.value;\n          effect.setDepthTexture(depthTexture, depthPacking);\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n      var material = this.getFullscreenMaterial();\n      var time = material.uniforms.time.value + deltaTime;\n\n      if (this.needsUpdate) {\n        this.recompile(renderer);\n      }\n\n      var _iterator12 = _createForOfIteratorHelper(this.effects),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var effect = _step12.value;\n          effect.update(renderer, inputBuffer, deltaTime);\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      if (!this.skipRendering || this.renderToScreen) {\n        material.uniforms.inputBuffer.value = inputBuffer.texture;\n        material.uniforms.time.value = time <= this.maxTime ? time : this.minTime;\n        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n        renderer.render(this.scene, this.camera);\n      }\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      this.getFullscreenMaterial().setSize(width, height);\n\n      var _iterator13 = _createForOfIteratorHelper(this.effects),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var effect = _step13.value;\n          effect.setSize(width, height);\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize(renderer, alpha, frameBufferType) {\n      var _this30 = this;\n\n      this.capabilities = renderer.capabilities;\n\n      var _iterator14 = _createForOfIteratorHelper(this.effects),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var effect = _step14.value;\n          effect.initialize(renderer, alpha, frameBufferType);\n          effect.addEventListener(\"change\", function (event) {\n            return _this30.handleEvent(event);\n          });\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n\n      this.updateMaterial();\n      this.verifyResources(renderer);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(EffectPass.prototype), \"dispose\", this).call(this);\n\n      var _iterator15 = _createForOfIteratorHelper(this.effects),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var effect = _step15.value;\n          effect.dispose();\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(event) {\n      switch (event.type) {\n        case \"change\":\n          this.needsUpdate = true;\n          break;\n      }\n    }\n  }]);\n\n  return EffectPass;\n}(Pass); // src/passes/LambdaPass.js\n\n\nvar LambdaPass = /*#__PURE__*/function (_Pass10) {\n  _inherits(LambdaPass, _Pass10);\n\n  var _super29 = _createSuper(LambdaPass);\n\n  function LambdaPass(f) {\n    var _this31;\n\n    _classCallCheck(this, LambdaPass);\n\n    _this31 = _super29.call(this, \"LambdaPass\", null, null);\n    _this31.needsSwap = false;\n    _this31.f = f;\n    return _this31;\n  }\n\n  _createClass(LambdaPass, [{\n    key: \"render\",\n    value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n      this.f();\n    }\n  }]);\n\n  return LambdaPass;\n}(Pass); // src/passes/LuminancePass.js\n\n\nimport { LinearFilter as LinearFilter3, LuminanceFormat, RGBAFormat as RGBAFormat2, WebGLRenderTarget as WebGLRenderTarget6 } from \"three\";\n\nvar LuminancePass = /*#__PURE__*/function (_Pass11) {\n  _inherits(LuminancePass, _Pass11);\n\n  var _super30 = _createSuper(LuminancePass);\n\n  function LuminancePass() {\n    var _this32;\n\n    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref6$width = _ref6.width,\n        width = _ref6$width === void 0 ? Resizer.AUTO_SIZE : _ref6$width,\n        _ref6$height = _ref6.height,\n        height = _ref6$height === void 0 ? Resizer.AUTO_SIZE : _ref6$height,\n        renderTarget = _ref6.renderTarget,\n        luminanceRange = _ref6.luminanceRange,\n        colorOutput = _ref6.colorOutput;\n\n    _classCallCheck(this, LuminancePass);\n\n    _this32 = _super30.call(this, \"LuminancePass\");\n\n    _this32.setFullscreenMaterial(new LuminanceMaterial(colorOutput, luminanceRange));\n\n    _this32.needsSwap = false;\n    _this32.renderTarget = renderTarget;\n\n    if (_this32.renderTarget === void 0) {\n      _this32.renderTarget = new WebGLRenderTarget6(1, 1, {\n        minFilter: LinearFilter3,\n        magFilter: LinearFilter3,\n        format: colorOutput ? RGBAFormat2 : LuminanceFormat,\n        stencilBuffer: false,\n        depthBuffer: false\n      });\n      _this32.renderTarget.texture.name = \"LuminancePass.Target\";\n      _this32.renderTarget.texture.generateMipmaps = false;\n    }\n\n    _this32.resolution = new Resizer(_assertThisInitialized(_this32), width, height);\n    return _this32;\n  }\n\n  _createClass(LuminancePass, [{\n    key: \"texture\",\n    get: function get() {\n      return this.renderTarget.texture;\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n      var material = this.getFullscreenMaterial();\n      material.uniforms.inputBuffer.value = inputBuffer.texture;\n      renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n      renderer.render(this.scene, this.camera);\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      var resolution = this.resolution;\n      resolution.base.set(width, height);\n      this.renderTarget.setSize(resolution.width, resolution.height);\n    }\n  }]);\n\n  return LuminancePass;\n}(Pass); // src/passes/MaskPass.js\n\n\nvar MaskPass = /*#__PURE__*/function (_Pass12) {\n  _inherits(MaskPass, _Pass12);\n\n  var _super31 = _createSuper(MaskPass);\n\n  function MaskPass(scene, camera) {\n    var _this33;\n\n    _classCallCheck(this, MaskPass);\n\n    _this33 = _super31.call(this, \"MaskPass\", scene, camera);\n    _this33.needsSwap = false;\n    _this33.clearPass = new ClearPass(false, false, true);\n    _this33.inverse = false;\n    return _this33;\n  }\n\n  _createClass(MaskPass, [{\n    key: \"clear\",\n    get: function get() {\n      return this.clearPass.enabled;\n    },\n    set: function set(value) {\n      this.clearPass.enabled = value;\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n      var context = renderer.getContext();\n      var buffers = renderer.state.buffers;\n      var scene = this.scene;\n      var camera = this.camera;\n      var clearPass = this.clearPass;\n      var writeValue = this.inverse ? 0 : 1;\n      var clearValue = 1 - writeValue;\n      buffers.color.setMask(false);\n      buffers.depth.setMask(false);\n      buffers.color.setLocked(true);\n      buffers.depth.setLocked(true);\n      buffers.stencil.setTest(true);\n      buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);\n      buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);\n      buffers.stencil.setClear(clearValue);\n      buffers.stencil.setLocked(true);\n\n      if (this.clear) {\n        if (this.renderToScreen) {\n          clearPass.render(renderer, null);\n        } else {\n          clearPass.render(renderer, inputBuffer);\n          clearPass.render(renderer, outputBuffer);\n        }\n      }\n\n      if (this.renderToScreen) {\n        renderer.setRenderTarget(null);\n        renderer.render(scene, camera);\n      } else {\n        renderer.setRenderTarget(inputBuffer);\n        renderer.render(scene, camera);\n        renderer.setRenderTarget(outputBuffer);\n        renderer.render(scene, camera);\n      }\n\n      buffers.color.setLocked(false);\n      buffers.depth.setLocked(false);\n      buffers.stencil.setLocked(false);\n      buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);\n      buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);\n      buffers.stencil.setLocked(true);\n    }\n  }]);\n\n  return MaskPass;\n}(Pass); // src/passes/NormalPass.js\n\n\nimport { Color as Color3, MeshNormalMaterial, NearestFilter as NearestFilter4, RGBFormat as RGBFormat3, WebGLRenderTarget as WebGLRenderTarget7 } from \"three\";\n\nvar NormalPass = /*#__PURE__*/function (_Pass13) {\n  _inherits(NormalPass, _Pass13);\n\n  var _super32 = _createSuper(NormalPass);\n\n  function NormalPass(scene, camera) {\n    var _this34;\n\n    var _ref7 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref7$resolutionScale = _ref7.resolutionScale,\n        resolutionScale = _ref7$resolutionScale === void 0 ? 1 : _ref7$resolutionScale,\n        _ref7$width = _ref7.width,\n        width = _ref7$width === void 0 ? Resizer.AUTO_SIZE : _ref7$width,\n        _ref7$height = _ref7.height,\n        height = _ref7$height === void 0 ? Resizer.AUTO_SIZE : _ref7$height,\n        renderTarget = _ref7.renderTarget;\n\n    _classCallCheck(this, NormalPass);\n\n    _this34 = _super32.call(this, \"NormalPass\");\n    _this34.needsSwap = false;\n    _this34.renderPass = new RenderPass(scene, camera, new MeshNormalMaterial());\n\n    var clearPass = _this34.renderPass.getClearPass();\n\n    clearPass.overrideClearColor = new Color3(7829503);\n    clearPass.overrideClearAlpha = 1;\n    _this34.renderTarget = renderTarget;\n\n    if (_this34.renderTarget === void 0) {\n      _this34.renderTarget = new WebGLRenderTarget7(1, 1, {\n        minFilter: NearestFilter4,\n        magFilter: NearestFilter4,\n        format: RGBFormat3,\n        stencilBuffer: false\n      });\n      _this34.renderTarget.texture.name = \"NormalPass.Target\";\n    }\n\n    _this34.resolution = new Resizer(_assertThisInitialized(_this34), width, height, resolutionScale);\n    return _this34;\n  }\n\n  _createClass(NormalPass, [{\n    key: \"texture\",\n    get: function get() {\n      return this.renderTarget.texture;\n    }\n  }, {\n    key: \"getResolutionScale\",\n    value: function getResolutionScale() {\n      return this.resolutionScale;\n    }\n  }, {\n    key: \"setResolutionScale\",\n    value: function setResolutionScale(scale) {\n      this.resolutionScale = scale;\n      this.setSize(this.resolution.base.x, this.resolution.base.y);\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n      var renderTarget = this.renderToScreen ? null : this.renderTarget;\n      this.renderPass.render(renderer, renderTarget, renderTarget);\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      var resolution = this.resolution;\n      resolution.base.set(width, height);\n      this.renderTarget.setSize(resolution.width, resolution.height);\n    }\n  }]);\n\n  return NormalPass;\n}(Pass); // src/passes/ShaderPass.js\n\n\nvar ShaderPass = /*#__PURE__*/function (_Pass14) {\n  _inherits(ShaderPass, _Pass14);\n\n  var _super33 = _createSuper(ShaderPass);\n\n  function ShaderPass(material) {\n    var _this35;\n\n    var input = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"inputBuffer\";\n\n    _classCallCheck(this, ShaderPass);\n\n    _this35 = _super33.call(this, \"ShaderPass\");\n\n    _this35.setFullscreenMaterial(material);\n\n    _this35.uniform = null;\n\n    _this35.setInput(input);\n\n    return _this35;\n  }\n\n  _createClass(ShaderPass, [{\n    key: \"setInput\",\n    value: function setInput(input) {\n      var material = this.getFullscreenMaterial();\n      this.uniform = null;\n\n      if (material !== null) {\n        var uniforms = material.uniforms;\n\n        if (uniforms !== void 0 && uniforms[input] !== void 0) {\n          this.uniform = uniforms[input];\n        }\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n      if (this.uniform !== null && inputBuffer !== null) {\n        this.uniform.value = inputBuffer.texture;\n      }\n\n      renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n      renderer.render(this.scene, this.camera);\n    }\n  }]);\n\n  return ShaderPass;\n}(Pass); // src/core/EffectComposer.js\n\n\nvar EffectComposer = /*#__PURE__*/function () {\n  function EffectComposer() {\n    var renderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref8$depthBuffer = _ref8.depthBuffer,\n        depthBuffer = _ref8$depthBuffer === void 0 ? true : _ref8$depthBuffer,\n        _ref8$stencilBuffer = _ref8.stencilBuffer,\n        stencilBuffer = _ref8$stencilBuffer === void 0 ? false : _ref8$stencilBuffer,\n        _ref8$multisampling = _ref8.multisampling,\n        multisampling = _ref8$multisampling === void 0 ? 0 : _ref8$multisampling,\n        frameBufferType = _ref8.frameBufferType;\n\n    _classCallCheck(this, EffectComposer);\n\n    this.renderer = renderer;\n    this.inputBuffer = null;\n    this.outputBuffer = null;\n\n    if (this.renderer !== null) {\n      this.renderer.autoClear = false;\n      this.inputBuffer = this.createBuffer(depthBuffer, stencilBuffer, frameBufferType, multisampling);\n      this.outputBuffer = this.inputBuffer.clone();\n      this.enableExtensions();\n    }\n\n    this.copyPass = new ShaderPass(new CopyMaterial());\n    this.depthTexture = null;\n    this.passes = [];\n    this.autoRenderToScreen = true;\n  }\n\n  _createClass(EffectComposer, [{\n    key: \"multisampling\",\n    get: function get() {\n      return this.inputBuffer instanceof WebGLMultisampleRenderTarget ? this.inputBuffer.samples : 0;\n    },\n    set: function set(value) {\n      var buffer = this.inputBuffer;\n      var multisampling = this.multisampling;\n\n      if (multisampling > 0 && value > 0) {\n        this.inputBuffer.samples = value;\n        this.outputBuffer.samples = value;\n      } else if (multisampling !== value) {\n        this.inputBuffer.dispose();\n        this.outputBuffer.dispose();\n        this.inputBuffer = this.createBuffer(buffer.depthBuffer, buffer.stencilBuffer, buffer.texture.type, value);\n        this.inputBuffer.depthTexture = this.depthTexture;\n        this.outputBuffer = this.inputBuffer.clone();\n      }\n    }\n  }, {\n    key: \"getRenderer\",\n    value: function getRenderer() {\n      return this.renderer;\n    }\n  }, {\n    key: \"enableExtensions\",\n    value: function enableExtensions() {\n      var frameBufferType = this.inputBuffer.texture.type;\n      var capabilities = this.renderer.capabilities;\n      var context = this.renderer.getContext();\n\n      if (frameBufferType !== UnsignedByteType3) {\n        if (capabilities.isWebGL2) {\n          context.getExtension(\"EXT_color_buffer_float\");\n        } else {\n          context.getExtension(\"EXT_color_buffer_half_float\");\n        }\n      }\n    }\n  }, {\n    key: \"replaceRenderer\",\n    value: function replaceRenderer(renderer) {\n      var updateDOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var oldRenderer = this.renderer;\n\n      if (oldRenderer !== null && oldRenderer !== renderer) {\n        var oldSize = oldRenderer.getSize(new Vector212());\n        var newSize = renderer.getSize(new Vector212());\n        var parent = oldRenderer.domElement.parentNode;\n        this.renderer = renderer;\n        this.renderer.autoClear = false;\n\n        if (!oldSize.equals(newSize)) {\n          this.setSize();\n        }\n\n        if (updateDOM && parent !== null) {\n          parent.removeChild(oldRenderer.domElement);\n          parent.appendChild(renderer.domElement);\n        }\n\n        this.enableExtensions();\n      }\n\n      return oldRenderer;\n    }\n  }, {\n    key: \"createDepthTexture\",\n    value: function createDepthTexture() {\n      var depthTexture = this.depthTexture = new DepthTexture();\n      this.inputBuffer.depthTexture = depthTexture;\n      this.inputBuffer.dispose();\n\n      if (this.inputBuffer.stencilBuffer) {\n        depthTexture.format = DepthStencilFormat;\n        depthTexture.type = UnsignedInt248Type;\n      } else {\n        depthTexture.type = UnsignedIntType;\n      }\n\n      return depthTexture;\n    }\n  }, {\n    key: \"deleteDepthTexture\",\n    value: function deleteDepthTexture() {\n      if (this.depthTexture !== null) {\n        this.depthTexture.dispose();\n        this.depthTexture = null;\n        this.inputBuffer.depthTexture = null;\n        this.inputBuffer.dispose();\n\n        var _iterator16 = _createForOfIteratorHelper(this.passes),\n            _step16;\n\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var pass = _step16.value;\n            pass.setDepthTexture(null);\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n      }\n    }\n  }, {\n    key: \"createBuffer\",\n    value: function createBuffer(depthBuffer, stencilBuffer, type, multisampling) {\n      var size = this.renderer.getDrawingBufferSize(new Vector212());\n      var alpha = this.renderer.getContext().getContextAttributes().alpha;\n      var options = {\n        format: !alpha && type === UnsignedByteType3 ? RGBFormat4 : RGBAFormat3,\n        minFilter: LinearFilter4,\n        magFilter: LinearFilter4,\n        stencilBuffer: stencilBuffer,\n        depthBuffer: depthBuffer,\n        type: type\n      };\n      var renderTarget = multisampling > 0 ? new WebGLMultisampleRenderTarget(size.width, size.height, options) : new WebGLRenderTarget8(size.width, size.height, options);\n\n      if (multisampling > 0) {\n        renderTarget.samples = multisampling;\n      }\n\n      renderTarget.texture.name = \"EffectComposer.Buffer\";\n      renderTarget.texture.generateMipmaps = false;\n      return renderTarget;\n    }\n  }, {\n    key: \"addPass\",\n    value: function addPass(pass, index) {\n      var passes = this.passes;\n      var renderer = this.renderer;\n      var drawingBufferSize = renderer.getDrawingBufferSize(new Vector212());\n      var alpha = renderer.getContext().getContextAttributes().alpha;\n      var frameBufferType = this.inputBuffer.texture.type;\n      pass.setSize(drawingBufferSize.width, drawingBufferSize.height);\n      pass.initialize(renderer, alpha, frameBufferType);\n\n      if (this.autoRenderToScreen) {\n        if (passes.length > 0) {\n          passes[passes.length - 1].renderToScreen = false;\n        }\n\n        if (pass.renderToScreen) {\n          this.autoRenderToScreen = false;\n        }\n      }\n\n      if (index !== void 0) {\n        passes.splice(index, 0, pass);\n      } else {\n        passes.push(pass);\n      }\n\n      if (this.autoRenderToScreen) {\n        passes[passes.length - 1].renderToScreen = true;\n      }\n\n      if (pass.needsDepthTexture || this.depthTexture !== null) {\n        if (this.depthTexture === null) {\n          var depthTexture = this.createDepthTexture();\n\n          var _iterator17 = _createForOfIteratorHelper(passes),\n              _step17;\n\n          try {\n            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n              pass = _step17.value;\n              pass.setDepthTexture(depthTexture);\n            }\n          } catch (err) {\n            _iterator17.e(err);\n          } finally {\n            _iterator17.f();\n          }\n        } else {\n          pass.setDepthTexture(this.depthTexture);\n        }\n      }\n    }\n  }, {\n    key: \"removePass\",\n    value: function removePass(pass) {\n      var passes = this.passes;\n      var index = passes.indexOf(pass);\n      var exists = index !== -1;\n      var removed = exists && passes.splice(index, 1).length > 0;\n\n      if (removed) {\n        if (this.depthTexture !== null) {\n          var reducer = function reducer(a, b) {\n            return a || b.needsDepthTexture;\n          };\n\n          var depthTextureRequired = passes.reduce(reducer, false);\n\n          if (!depthTextureRequired) {\n            if (pass.getDepthTexture() === this.depthTexture) {\n              pass.setDepthTexture(null);\n            }\n\n            this.deleteDepthTexture();\n          }\n        }\n\n        if (this.autoRenderToScreen) {\n          if (index === passes.length) {\n            pass.renderToScreen = false;\n\n            if (passes.length > 0) {\n              passes[passes.length - 1].renderToScreen = true;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"removeAllPasses\",\n    value: function removeAllPasses() {\n      var passes = this.passes;\n      this.deleteDepthTexture();\n\n      if (passes.length > 0) {\n        if (this.autoRenderToScreen) {\n          passes[passes.length - 1].renderToScreen = false;\n        }\n\n        this.passes = [];\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(deltaTime) {\n      var renderer = this.renderer;\n      var copyPass = this.copyPass;\n      var inputBuffer = this.inputBuffer;\n      var outputBuffer = this.outputBuffer;\n      var stencilTest = false;\n      var context, stencil, buffer;\n\n      var _iterator18 = _createForOfIteratorHelper(this.passes),\n          _step18;\n\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var pass = _step18.value;\n\n          if (pass.enabled) {\n            pass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);\n\n            if (pass.needsSwap) {\n              if (stencilTest) {\n                copyPass.renderToScreen = pass.renderToScreen;\n                context = renderer.getContext();\n                stencil = renderer.state.buffers.stencil;\n                stencil.setFunc(context.NOTEQUAL, 1, 4294967295);\n                copyPass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);\n                stencil.setFunc(context.EQUAL, 1, 4294967295);\n              }\n\n              buffer = inputBuffer;\n              inputBuffer = outputBuffer;\n              outputBuffer = buffer;\n            }\n\n            if (pass instanceof MaskPass) {\n              stencilTest = true;\n            } else if (pass instanceof ClearMaskPass) {\n              stencilTest = false;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height, updateStyle) {\n      var renderer = this.renderer;\n\n      if (width === void 0 || height === void 0) {\n        var size = renderer.getSize(new Vector212());\n        width = size.width;\n        height = size.height;\n      } else {\n        renderer.setSize(width, height, updateStyle);\n      }\n\n      var drawingBufferSize = renderer.getDrawingBufferSize(new Vector212());\n      this.inputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);\n      this.outputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);\n\n      var _iterator19 = _createForOfIteratorHelper(this.passes),\n          _step19;\n\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var pass = _step19.value;\n          pass.setSize(drawingBufferSize.width, drawingBufferSize.height);\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.dispose();\n      this.autoRenderToScreen = true;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _iterator20 = _createForOfIteratorHelper(this.passes),\n          _step20;\n\n      try {\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var pass = _step20.value;\n          pass.dispose();\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n\n      this.passes = [];\n\n      if (this.inputBuffer !== null) {\n        this.inputBuffer.dispose();\n      }\n\n      if (this.outputBuffer !== null) {\n        this.outputBuffer.dispose();\n      }\n\n      this.deleteDepthTexture();\n      this.copyPass.dispose();\n    }\n  }]);\n\n  return EffectComposer;\n}(); // src/core/Initializable.js\n\n\nvar Initializable = /*#__PURE__*/function () {\n  function Initializable() {\n    _classCallCheck(this, Initializable);\n  }\n\n  _createClass(Initializable, [{\n    key: \"initialize\",\n    value: function initialize(renderer, alpha, frameBufferType) {}\n  }]);\n\n  return Initializable;\n}(); // src/core/Resizable.js\n\n\nvar Resizable = /*#__PURE__*/function () {\n  function Resizable() {\n    _classCallCheck(this, Resizable);\n  }\n\n  _createClass(Resizable, [{\n    key: \"setSize\",\n    value: function setSize(width, height) {}\n  }]);\n\n  return Resizable;\n}(); // src/core/Selection.js\n\n\nvar Selection = /*#__PURE__*/function (_Set) {\n  _inherits(Selection, _Set);\n\n  var _super34 = _createSuper(Selection);\n\n  function Selection(iterable) {\n    var _this36;\n\n    var layer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n\n    _classCallCheck(this, Selection);\n\n    _this36 = _super34.call(this);\n    _this36.currentLayer = layer;\n\n    if (iterable !== void 0) {\n      _this36.set(iterable);\n    }\n\n    return _this36;\n  }\n\n  _createClass(Selection, [{\n    key: \"layer\",\n    get: function get() {\n      return this.currentLayer;\n    },\n    set: function set(value) {\n      var currentLayer = this.currentLayer;\n\n      var _iterator21 = _createForOfIteratorHelper(this),\n          _step21;\n\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var object = _step21.value;\n          object.layers.disable(currentLayer);\n          object.layers.enable(value);\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n\n      this.currentLayer = value;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var layer = this.layer;\n\n      var _iterator22 = _createForOfIteratorHelper(this),\n          _step22;\n\n      try {\n        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n          var object = _step22.value;\n          object.layers.disable(layer);\n        }\n      } catch (err) {\n        _iterator22.e(err);\n      } finally {\n        _iterator22.f();\n      }\n\n      return _get(_getPrototypeOf(Selection.prototype), \"clear\", this).call(this);\n    }\n  }, {\n    key: \"set\",\n    value: function set(objects) {\n      this.clear();\n\n      var _iterator23 = _createForOfIteratorHelper(objects),\n          _step23;\n\n      try {\n        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n          var object = _step23.value;\n          this.add(object);\n        }\n      } catch (err) {\n        _iterator23.e(err);\n      } finally {\n        _iterator23.f();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(object) {\n      return this.has(object) ? 0 : -1;\n    }\n  }, {\n    key: \"add\",\n    value: function add(object) {\n      object.layers.enable(this.layer);\n\n      _get(_getPrototypeOf(Selection.prototype), \"add\", this).call(this, object);\n\n      return this;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(object) {\n      if (this.has(object)) {\n        object.layers.disable(this.layer);\n      }\n\n      return _get(_getPrototypeOf(Selection.prototype), \"delete\", this).call(this, object);\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(visible) {\n      var _iterator24 = _createForOfIteratorHelper(this),\n          _step24;\n\n      try {\n        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n          var object = _step24.value;\n\n          if (visible) {\n            object.layers.enable(0);\n          } else {\n            object.layers.disable(0);\n          }\n        }\n      } catch (err) {\n        _iterator24.e(err);\n      } finally {\n        _iterator24.f();\n      }\n\n      return this;\n    }\n  }]);\n\n  return Selection;\n}( /*#__PURE__*/_wrapNativeSuper(Set)); // src/effects/BloomEffect.js\n\n\nimport { LinearFilter as LinearFilter5, RGBFormat as RGBFormat5, Uniform as Uniform19, UnsignedByteType as UnsignedByteType4, WebGLRenderTarget as WebGLRenderTarget9 } from \"three\"; // src/effects/glsl/bloom/shader.frag\n\nvar shader_default44 = \"uniform sampler2D texture;\\r\\nuniform float intensity;\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\toutputColor = clamp(texture2D(texture, uv) * intensity, 0.0, 1.0);\\r\\n\\r\\n}\\r\\n\"; // src/effects/BloomEffect.js\n\nvar BloomEffect = /*#__PURE__*/function (_Effect) {\n  _inherits(BloomEffect, _Effect);\n\n  var _super35 = _createSuper(BloomEffect);\n\n  function BloomEffect() {\n    var _this37;\n\n    var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref9$blendFunction = _ref9.blendFunction,\n        blendFunction = _ref9$blendFunction === void 0 ? BlendFunction.SCREEN : _ref9$blendFunction,\n        _ref9$luminanceThresh = _ref9.luminanceThreshold,\n        luminanceThreshold = _ref9$luminanceThresh === void 0 ? 0.9 : _ref9$luminanceThresh,\n        _ref9$luminanceSmooth = _ref9.luminanceSmoothing,\n        luminanceSmoothing = _ref9$luminanceSmooth === void 0 ? 0.025 : _ref9$luminanceSmooth,\n        _ref9$resolutionScale = _ref9.resolutionScale,\n        resolutionScale = _ref9$resolutionScale === void 0 ? 0.5 : _ref9$resolutionScale,\n        _ref9$intensity = _ref9.intensity,\n        intensity = _ref9$intensity === void 0 ? 1 : _ref9$intensity,\n        _ref9$width = _ref9.width,\n        width = _ref9$width === void 0 ? Resizer.AUTO_SIZE : _ref9$width,\n        _ref9$height = _ref9.height,\n        height = _ref9$height === void 0 ? Resizer.AUTO_SIZE : _ref9$height,\n        _ref9$kernelSize = _ref9.kernelSize,\n        kernelSize = _ref9$kernelSize === void 0 ? KernelSize.LARGE : _ref9$kernelSize;\n\n    _classCallCheck(this, BloomEffect);\n\n    _this37 = _super35.call(this, \"BloomEffect\", shader_default44, {\n      blendFunction: blendFunction,\n      uniforms: new Map([[\"texture\", new Uniform19(null)], [\"intensity\", new Uniform19(intensity)]])\n    });\n    _this37.renderTarget = new WebGLRenderTarget9(1, 1, {\n      minFilter: LinearFilter5,\n      magFilter: LinearFilter5,\n      stencilBuffer: false,\n      depthBuffer: false\n    });\n    _this37.renderTarget.texture.name = \"Bloom.Target\";\n    _this37.renderTarget.texture.generateMipmaps = false;\n    _this37.uniforms.get(\"texture\").value = _this37.renderTarget.texture;\n    _this37.blurPass = new BlurPass({\n      resolutionScale: resolutionScale,\n      width: width,\n      height: height,\n      kernelSize: kernelSize\n    });\n    _this37.blurPass.resolution.resizable = _assertThisInitialized(_this37);\n    _this37.luminancePass = new LuminancePass({\n      renderTarget: _this37.renderTarget,\n      colorOutput: true\n    });\n    _this37.luminancePass.resolution = _this37.resolution;\n    _this37.luminanceMaterial.threshold = luminanceThreshold;\n    _this37.luminanceMaterial.smoothing = luminanceSmoothing;\n    return _this37;\n  }\n\n  _createClass(BloomEffect, [{\n    key: \"texture\",\n    get: function get() {\n      return this.renderTarget.texture;\n    }\n  }, {\n    key: \"luminanceMaterial\",\n    get: function get() {\n      return this.luminancePass.getFullscreenMaterial();\n    }\n  }, {\n    key: \"resolution\",\n    get: function get() {\n      return this.blurPass.resolution;\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.resolution.width;\n    },\n    set: function set(value) {\n      this.resolution.width = value;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.resolution.height;\n    },\n    set: function set(value) {\n      this.resolution.height = value;\n    }\n  }, {\n    key: \"dithering\",\n    get: function get() {\n      return this.blurPass.dithering;\n    },\n    set: function set(value) {\n      this.blurPass.dithering = value;\n    }\n  }, {\n    key: \"kernelSize\",\n    get: function get() {\n      return this.blurPass.kernelSize;\n    },\n    set: function set(value) {\n      this.blurPass.kernelSize = value;\n    }\n  }, {\n    key: \"distinction\",\n    get: function get() {\n      console.warn(this.name, \"The distinction field has been removed, use luminanceMaterial.threshold and luminanceMaterial.smoothing instead.\");\n      return 1;\n    },\n    set: function set(value) {\n      console.warn(this.name, \"The distinction field has been removed, use luminanceMaterial.threshold and luminanceMaterial.smoothing instead.\");\n    }\n  }, {\n    key: \"intensity\",\n    get: function get() {\n      return this.uniforms.get(\"intensity\").value;\n    },\n    set: function set(value) {\n      this.uniforms.get(\"intensity\").value = value;\n    }\n  }, {\n    key: \"getResolutionScale\",\n    value: function getResolutionScale() {\n      return this.resolution.scale;\n    }\n  }, {\n    key: \"setResolutionScale\",\n    value: function setResolutionScale(scale) {\n      this.resolution.scale = scale;\n    }\n  }, {\n    key: \"update\",\n    value: function update(renderer, inputBuffer, deltaTime) {\n      var renderTarget = this.renderTarget;\n\n      if (this.luminancePass.enabled) {\n        this.luminancePass.render(renderer, inputBuffer, renderTarget);\n        this.blurPass.render(renderer, renderTarget, renderTarget);\n      } else {\n        this.blurPass.render(renderer, inputBuffer, renderTarget);\n      }\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      this.blurPass.setSize(width, height);\n      this.renderTarget.setSize(this.resolution.width, this.resolution.height);\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize(renderer, alpha, frameBufferType) {\n      this.blurPass.initialize(renderer, alpha, frameBufferType);\n\n      if (!alpha && frameBufferType === UnsignedByteType4) {\n        this.renderTarget.texture.format = RGBFormat5;\n      }\n\n      if (frameBufferType !== void 0) {\n        this.renderTarget.texture.type = frameBufferType;\n      }\n    }\n  }]);\n\n  return BloomEffect;\n}(Effect); // src/effects/BokehEffect.js\n\n\nimport { Uniform as Uniform20 } from \"three\"; // src/effects/glsl/bokeh/shader.frag\n\nvar shader_default45 = \"uniform float focus;\\r\\nuniform float dof;\\r\\nuniform float aperture;\\r\\nuniform float maxBlur;\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, const in float depth, out vec4 outputColor) {\\r\\n\\r\\n\tvec2 aspectCorrection = vec2(1.0, aspect);\\r\\n\\r\\n\t#ifdef PERSPECTIVE_CAMERA\\r\\n\\r\\n\t\tfloat viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\\r\\n\t\tfloat linearDepth = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tfloat linearDepth = depth;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tfloat focusNear = clamp(focus - dof, 0.0, 1.0);\\r\\n\tfloat focusFar = clamp(focus + dof, 0.0, 1.0);\\r\\n\\r\\n\t// Calculate a DoF mask.\\r\\n\tfloat low = step(linearDepth, focusNear);\\r\\n\tfloat high = step(focusFar, linearDepth);\\r\\n\\r\\n\tfloat factor = (linearDepth - focusNear) * low + (linearDepth - focusFar) * high;\\r\\n\tvec2 dofBlur = vec2(clamp(factor * aperture, -maxBlur, maxBlur));\\r\\n\\r\\n\tvec2 dofblur9 = dofBlur * 0.9;\\r\\n\tvec2 dofblur7 = dofBlur * 0.7;\\r\\n\tvec2 dofblur4 = dofBlur * 0.4;\\r\\n\\r\\n\tvec4 color = inputColor;\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.0,   0.4 ) * aspectCorrection) * dofBlur);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.15,  0.37) * aspectCorrection) * dofBlur);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.29,  0.29) * aspectCorrection) * dofBlur);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.37,  0.15) * aspectCorrection) * dofBlur);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.40,  0.0 ) * aspectCorrection) * dofBlur);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.37, -0.15) * aspectCorrection) * dofBlur);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.29, -0.29) * aspectCorrection) * dofBlur);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.15, -0.37) * aspectCorrection) * dofBlur);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.0,  -0.4 ) * aspectCorrection) * dofBlur);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.15,  0.37) * aspectCorrection) * dofBlur);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.29,  0.29) * aspectCorrection) * dofBlur);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.37,  0.15) * aspectCorrection) * dofBlur);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.4,   0.0 ) * aspectCorrection) * dofBlur);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.37, -0.15) * aspectCorrection) * dofBlur);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.29, -0.29) * aspectCorrection) * dofBlur);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.15, -0.37) * aspectCorrection) * dofBlur);\\r\\n\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.15,  0.37) * aspectCorrection) * dofblur9);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.37,  0.15) * aspectCorrection) * dofblur9);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.37, -0.15) * aspectCorrection) * dofblur9);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.15, -0.37) * aspectCorrection) * dofblur9);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.15,  0.37) * aspectCorrection) * dofblur9);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.37,  0.15) * aspectCorrection) * dofblur9);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.37, -0.15) * aspectCorrection) * dofblur9);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.15, -0.37) * aspectCorrection) * dofblur9);\\r\\n\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.29,  0.29) * aspectCorrection) * dofblur7);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.40,  0.0 ) * aspectCorrection) * dofblur7);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.29, -0.29) * aspectCorrection) * dofblur7);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.0,  -0.4 ) * aspectCorrection) * dofblur7);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.29,  0.29) * aspectCorrection) * dofblur7);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.4,   0.0 ) * aspectCorrection) * dofblur7);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.29, -0.29) * aspectCorrection) * dofblur7);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.0,   0.4 ) * aspectCorrection) * dofblur7);\\r\\n\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.29,  0.29) * aspectCorrection) * dofblur4);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.4,   0.0 ) * aspectCorrection) * dofblur4);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.29, -0.29) * aspectCorrection) * dofblur4);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.0,  -0.4 ) * aspectCorrection) * dofblur4);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.29,  0.29) * aspectCorrection) * dofblur4);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.4,   0.0 ) * aspectCorrection) * dofblur4);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2(-0.29, -0.29) * aspectCorrection) * dofblur4);\\r\\n\tcolor += texture2D(inputBuffer, uv + (vec2( 0.0,   0.4 ) * aspectCorrection) * dofblur4);\\r\\n\\r\\n\toutputColor = color / 41.0;\\r\\n\\r\\n}\\r\\n\"; // src/effects/BokehEffect.js\n\nvar BokehEffect = /*#__PURE__*/function (_Effect2) {\n  _inherits(BokehEffect, _Effect2);\n\n  var _super36 = _createSuper(BokehEffect);\n\n  function BokehEffect() {\n    var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref10$blendFunction = _ref10.blendFunction,\n        blendFunction = _ref10$blendFunction === void 0 ? BlendFunction.NORMAL : _ref10$blendFunction,\n        _ref10$focus = _ref10.focus,\n        focus = _ref10$focus === void 0 ? 0.5 : _ref10$focus,\n        _ref10$dof = _ref10.dof,\n        dof = _ref10$dof === void 0 ? 0.02 : _ref10$dof,\n        _ref10$aperture = _ref10.aperture,\n        aperture = _ref10$aperture === void 0 ? 0.015 : _ref10$aperture,\n        _ref10$maxBlur = _ref10.maxBlur,\n        maxBlur = _ref10$maxBlur === void 0 ? 1 : _ref10$maxBlur;\n\n    _classCallCheck(this, BokehEffect);\n\n    return _super36.call(this, \"BokehEffect\", shader_default45, {\n      blendFunction: blendFunction,\n      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,\n      uniforms: new Map([[\"focus\", new Uniform20(focus)], [\"dof\", new Uniform20(dof)], [\"aperture\", new Uniform20(aperture)], [\"maxBlur\", new Uniform20(maxBlur)]])\n    });\n  }\n\n  return BokehEffect;\n}(Effect); // src/effects/BrightnessContrastEffect.js\n\n\nimport { Uniform as Uniform21 } from \"three\"; // src/effects/glsl/brightness-contrast/shader.frag\n\nvar shader_default46 = \"uniform float brightness;\\r\\nuniform float contrast;\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\tvec3 color = inputColor.rgb + vec3(brightness - 0.5);\\r\\n\\r\\n\tif(contrast > 0.0) {\\r\\n\\r\\n\t\tcolor /= vec3(1.0 - contrast);\\r\\n\\r\\n\t} else {\\r\\n\\r\\n\t\tcolor *= vec3(1.0 + contrast);\\r\\n\\r\\n\t}\\r\\n\\r\\n\toutputColor = vec4(min(color + vec3(0.5), 1.0), inputColor.a);\\r\\n\\r\\n}\\r\\n\"; // src/effects/BrightnessContrastEffect.js\n\nvar BrightnessContrastEffect = /*#__PURE__*/function (_Effect3) {\n  _inherits(BrightnessContrastEffect, _Effect3);\n\n  var _super37 = _createSuper(BrightnessContrastEffect);\n\n  function BrightnessContrastEffect() {\n    var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref11$blendFunction = _ref11.blendFunction,\n        blendFunction = _ref11$blendFunction === void 0 ? BlendFunction.NORMAL : _ref11$blendFunction,\n        _ref11$brightness = _ref11.brightness,\n        brightness = _ref11$brightness === void 0 ? 0 : _ref11$brightness,\n        _ref11$contrast = _ref11.contrast,\n        contrast = _ref11$contrast === void 0 ? 0 : _ref11$contrast;\n\n    _classCallCheck(this, BrightnessContrastEffect);\n\n    return _super37.call(this, \"BrightnessContrastEffect\", shader_default46, {\n      blendFunction: blendFunction,\n      uniforms: new Map([[\"brightness\", new Uniform21(brightness)], [\"contrast\", new Uniform21(contrast)]])\n    });\n  }\n\n  return BrightnessContrastEffect;\n}(Effect); // src/effects/glsl/color-average/shader.frag\n\n\nvar shader_default47 = \"void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\tfloat sum = inputColor.r + inputColor.g + inputColor.b;\\r\\n\\r\\n\toutputColor = vec4(vec3(sum / 3.0), inputColor.a);\\r\\n\\r\\n}\\r\\n\"; // src/effects/ColorAverageEffect.js\n\nvar ColorAverageEffect = /*#__PURE__*/function (_Effect4) {\n  _inherits(ColorAverageEffect, _Effect4);\n\n  var _super38 = _createSuper(ColorAverageEffect);\n\n  function ColorAverageEffect() {\n    var blendFunction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : BlendFunction.NORMAL;\n\n    _classCallCheck(this, ColorAverageEffect);\n\n    return _super38.call(this, \"ColorAverageEffect\", shader_default47, {\n      blendFunction: blendFunction\n    });\n  }\n\n  return ColorAverageEffect;\n}(Effect); // src/effects/ColorDepthEffect.js\n\n\nimport { Uniform as Uniform22 } from \"three\"; // src/effects/glsl/color-depth/shader.frag\n\nvar shader_default48 = \"uniform float factor;\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\toutputColor = vec4(floor(inputColor.rgb * factor + 0.5) / factor, inputColor.a);\\r\\n\\r\\n}\\r\\n\"; // src/effects/ColorDepthEffect.js\n\nvar ColorDepthEffect = /*#__PURE__*/function (_Effect5) {\n  _inherits(ColorDepthEffect, _Effect5);\n\n  var _super39 = _createSuper(ColorDepthEffect);\n\n  function ColorDepthEffect() {\n    var _this38;\n\n    var _ref12 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref12$blendFunction = _ref12.blendFunction,\n        blendFunction = _ref12$blendFunction === void 0 ? BlendFunction.NORMAL : _ref12$blendFunction,\n        _ref12$bits = _ref12.bits,\n        bits = _ref12$bits === void 0 ? 16 : _ref12$bits;\n\n    _classCallCheck(this, ColorDepthEffect);\n\n    _this38 = _super39.call(this, \"ColorDepthEffect\", shader_default48, {\n      blendFunction: blendFunction,\n      uniforms: new Map([[\"factor\", new Uniform22(1)]])\n    });\n    _this38.bits = 0;\n\n    _this38.setBitDepth(bits);\n\n    return _this38;\n  }\n\n  _createClass(ColorDepthEffect, [{\n    key: \"getBitDepth\",\n    value: function getBitDepth() {\n      return this.bits;\n    }\n  }, {\n    key: \"setBitDepth\",\n    value: function setBitDepth(bits) {\n      this.bits = bits;\n      this.uniforms.get(\"factor\").value = Math.pow(2, bits / 3);\n    }\n  }]);\n\n  return ColorDepthEffect;\n}(Effect); // src/effects/ChromaticAberrationEffect.js\n\n\nimport { Uniform as Uniform23, Vector2 as Vector213 } from \"three\"; // src/effects/glsl/chromatic-aberration/shader.frag\n\nvar shader_default49 = \"varying vec2 vUvR;\\r\\nvarying vec2 vUvB;\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\tvec4 color = inputColor;\\r\\n\\r\\n\t#ifdef ALPHA\\r\\n\\r\\n\t\tvec2 ra = texture2D(inputBuffer, vUvR).ra;\\r\\n\t\tvec2 ba = texture2D(inputBuffer, vUvB).ba;\\r\\n\\r\\n\t\tcolor.r = ra.x;\\r\\n\t\tcolor.b = ba.x;\\r\\n\t\tcolor.a = max(max(ra.y, ba.y), inputColor.a);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tcolor.r = texture2D(inputBuffer, vUvR).r;\\r\\n\t\tcolor.b = texture2D(inputBuffer, vUvB).b;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\toutputColor = color;\\r\\n\\r\\n}\\r\\n\"; // src/effects/glsl/chromatic-aberration/shader.vert\n\nvar shader_default50 = \"uniform vec2 offset;\\r\\n\\r\\nvarying vec2 vUvR;\\r\\nvarying vec2 vUvB;\\r\\n\\r\\nvoid mainSupport(const in vec2 uv) {\\r\\n\\r\\n\tvUvR = uv + offset;\\r\\n\tvUvB = uv - offset;\\r\\n\\r\\n}\\r\\n\"; // src/effects/ChromaticAberrationEffect.js\n\nvar ChromaticAberrationEffect = /*#__PURE__*/function (_Effect6) {\n  _inherits(ChromaticAberrationEffect, _Effect6);\n\n  var _super40 = _createSuper(ChromaticAberrationEffect);\n\n  function ChromaticAberrationEffect() {\n    var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref13$blendFunction = _ref13.blendFunction,\n        blendFunction = _ref13$blendFunction === void 0 ? BlendFunction.NORMAL : _ref13$blendFunction,\n        _ref13$offset = _ref13.offset,\n        offset = _ref13$offset === void 0 ? new Vector213(1e-3, 5e-4) : _ref13$offset;\n\n    _classCallCheck(this, ChromaticAberrationEffect);\n\n    return _super40.call(this, \"ChromaticAberrationEffect\", shader_default49, {\n      vertexShader: shader_default50,\n      blendFunction: blendFunction,\n      attributes: EffectAttribute.CONVOLUTION,\n      uniforms: new Map([[\"offset\", new Uniform23(offset)]])\n    });\n  }\n\n  _createClass(ChromaticAberrationEffect, [{\n    key: \"offset\",\n    get: function get() {\n      return this.uniforms.get(\"offset\").value;\n    },\n    set: function set(value) {\n      this.uniforms.get(\"offset\").value = value;\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize(renderer, alpha, frameBufferType) {\n      if (alpha) {\n        this.defines.set(\"ALPHA\", \"1\");\n      } else {\n        this.defines.delete(\"ALPHA\");\n      }\n    }\n  }]);\n\n  return ChromaticAberrationEffect;\n}(Effect); // src/effects/glsl/depth/shader.frag\n\n\nvar shader_default51 = \"void mainImage(const in vec4 inputColor, const in vec2 uv, const in float depth, out vec4 outputColor) {\\r\\n\\r\\n\t#ifdef INVERTED\\r\\n\\r\\n\t\tvec3 color = vec3(1.0 - depth);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tvec3 color = vec3(depth);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\toutputColor = vec4(color, inputColor.a);\\r\\n\\r\\n}\\r\\n\"; // src/effects/DepthEffect.js\n\nvar DepthEffect = /*#__PURE__*/function (_Effect7) {\n  _inherits(DepthEffect, _Effect7);\n\n  var _super41 = _createSuper(DepthEffect);\n\n  function DepthEffect() {\n    var _this39;\n\n    var _ref14 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref14$blendFunction = _ref14.blendFunction,\n        blendFunction = _ref14$blendFunction === void 0 ? BlendFunction.NORMAL : _ref14$blendFunction,\n        _ref14$inverted = _ref14.inverted,\n        inverted = _ref14$inverted === void 0 ? false : _ref14$inverted;\n\n    _classCallCheck(this, DepthEffect);\n\n    _this39 = _super41.call(this, \"DepthEffect\", shader_default51, {\n      blendFunction: blendFunction,\n      attributes: EffectAttribute.DEPTH\n    });\n    _this39.inverted = inverted;\n    return _this39;\n  }\n\n  _createClass(DepthEffect, [{\n    key: \"inverted\",\n    get: function get() {\n      return this.defines.has(\"INVERTED\");\n    },\n    set: function set(value) {\n      if (this.inverted !== value) {\n        if (value) {\n          this.defines.set(\"INVERTED\", \"1\");\n        } else {\n          this.defines.delete(\"INVERTED\");\n        }\n\n        this.setChanged();\n      }\n    }\n  }]);\n\n  return DepthEffect;\n}(Effect); // src/effects/DepthOfFieldEffect.js\n\n\nimport { LinearFilter as LinearFilter6, RGBFormat as RGBFormat6, Uniform as Uniform24, UnsignedByteType as UnsignedByteType5, WebGLRenderTarget as WebGLRenderTarget10 } from \"three\"; // src/effects/glsl/depth-of-field/shader.frag\n\nvar shader_default52 = \"uniform sampler2D nearColorBuffer;\\r\\nuniform sampler2D farColorBuffer;\\r\\nuniform sampler2D nearCoCBuffer;\\r\\n\\r\\nuniform float scale;\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, const in float depth, out vec4 outputColor) {\\r\\n\\r\\n\tvec4 colorNear = texture2D(nearColorBuffer, uv);\\r\\n\tvec4 colorFar = texture2D(farColorBuffer, uv);\\r\\n\\r\\n\tfloat CoCNear = texture2D(nearCoCBuffer, uv).r;\\r\\n\tCoCNear = min(CoCNear * scale, 1.0);\\r\\n\\r\\n\t// The far color buffer has been premultiplied with the CoC buffer.\\r\\n\tvec4 result = inputColor * (1.0 - colorFar.a) + colorFar;\\r\\n\tresult = mix(result, colorNear, CoCNear);\\r\\n\\r\\n\toutputColor = result;\\r\\n\\r\\n}\\r\\n\"; // src/effects/DepthOfFieldEffect.js\n\nvar DepthOfFieldEffect = /*#__PURE__*/function (_Effect8) {\n  _inherits(DepthOfFieldEffect, _Effect8);\n\n  var _super42 = _createSuper(DepthOfFieldEffect);\n\n  function DepthOfFieldEffect(camera) {\n    var _this40;\n\n    var _ref15 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref15$blendFunction = _ref15.blendFunction,\n        blendFunction = _ref15$blendFunction === void 0 ? BlendFunction.NORMAL : _ref15$blendFunction,\n        _ref15$focusDistance = _ref15.focusDistance,\n        focusDistance = _ref15$focusDistance === void 0 ? 0 : _ref15$focusDistance,\n        _ref15$focalLength = _ref15.focalLength,\n        focalLength = _ref15$focalLength === void 0 ? 0.1 : _ref15$focalLength,\n        _ref15$bokehScale = _ref15.bokehScale,\n        bokehScale = _ref15$bokehScale === void 0 ? 1 : _ref15$bokehScale,\n        _ref15$width = _ref15.width,\n        width = _ref15$width === void 0 ? Resizer.AUTO_SIZE : _ref15$width,\n        _ref15$height = _ref15.height,\n        height = _ref15$height === void 0 ? Resizer.AUTO_SIZE : _ref15$height;\n\n    _classCallCheck(this, DepthOfFieldEffect);\n\n    _this40 = _super42.call(this, \"DepthOfFieldEffect\", shader_default52, {\n      blendFunction: blendFunction,\n      attributes: EffectAttribute.DEPTH,\n      uniforms: new Map([[\"nearColorBuffer\", new Uniform24(null)], [\"farColorBuffer\", new Uniform24(null)], [\"nearCoCBuffer\", new Uniform24(null)], [\"scale\", new Uniform24(1)]])\n    });\n    _this40.camera = camera;\n    _this40.renderTarget = new WebGLRenderTarget10(1, 1, {\n      minFilter: LinearFilter6,\n      magFilter: LinearFilter6,\n      stencilBuffer: false,\n      depthBuffer: false\n    });\n    _this40.renderTarget.texture.name = \"DoF.Intermediate\";\n    _this40.renderTarget.texture.generateMipmaps = false;\n    _this40.renderTargetMasked = _this40.renderTarget.clone();\n    _this40.renderTargetMasked.texture.name = \"DoF.Masked.Far\";\n    _this40.renderTargetNear = _this40.renderTarget.clone();\n    _this40.renderTargetNear.texture.name = \"DoF.Bokeh.Near\";\n    _this40.uniforms.get(\"nearColorBuffer\").value = _this40.renderTargetNear.texture;\n    _this40.renderTargetFar = _this40.renderTarget.clone();\n    _this40.renderTargetFar.texture.name = \"DoF.Bokeh.Far\";\n    _this40.uniforms.get(\"farColorBuffer\").value = _this40.renderTargetFar.texture;\n    _this40.renderTargetCoC = _this40.renderTarget.clone();\n    _this40.renderTargetCoC.texture.format = RGBFormat6;\n    _this40.renderTargetCoC.texture.name = \"DoF.CoC\";\n    _this40.renderTargetCoCBlurred = _this40.renderTargetCoC.clone();\n    _this40.renderTargetCoCBlurred.texture.name = \"DoF.CoC.Blurred\";\n    _this40.uniforms.get(\"nearCoCBuffer\").value = _this40.renderTargetCoCBlurred.texture;\n    _this40.cocPass = new ShaderPass(new CircleOfConfusionMaterial(camera));\n    var cocMaterial = _this40.circleOfConfusionMaterial;\n    cocMaterial.uniforms.focusDistance.value = focusDistance;\n    cocMaterial.uniforms.focalLength.value = focalLength;\n    _this40.blurPass = new BlurPass({\n      width: width,\n      height: height,\n      kernelSize: KernelSize.MEDIUM\n    });\n    _this40.blurPass.resolution.resizable = _assertThisInitialized(_this40);\n    _this40.maskPass = new ShaderPass(new MaskMaterial(_this40.renderTargetCoC.texture));\n\n    var maskMaterial = _this40.maskPass.getFullscreenMaterial();\n\n    maskMaterial.maskFunction = MaskFunction.MULTIPLY_RGB_SET_ALPHA;\n    maskMaterial.colorChannel = ColorChannel.GREEN;\n    _this40.bokehNearBasePass = new ShaderPass(new BokehMaterial(false, true));\n    _this40.bokehNearFillPass = new ShaderPass(new BokehMaterial(true, true));\n    _this40.bokehFarBasePass = new ShaderPass(new BokehMaterial(false, false));\n    _this40.bokehFarFillPass = new ShaderPass(new BokehMaterial(true, false));\n    _this40.bokehScale = bokehScale;\n    _this40.target = null;\n    return _this40;\n  }\n\n  _createClass(DepthOfFieldEffect, [{\n    key: \"circleOfConfusionMaterial\",\n    get: function get() {\n      return this.cocPass.getFullscreenMaterial();\n    }\n  }, {\n    key: \"resolution\",\n    get: function get() {\n      return this.blurPass.resolution;\n    }\n  }, {\n    key: \"bokehScale\",\n    get: function get() {\n      return this.uniforms.get(\"scale\").value;\n    },\n    set: function set(value) {\n      var passes = [this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass];\n      passes.map(function (p) {\n        return p.getFullscreenMaterial().uniforms.scale;\n      }).forEach(function (u) {\n        u.value = value;\n      });\n      this.maskPass.getFullscreenMaterial().uniforms.strength.value = value;\n      this.uniforms.get(\"scale\").value = value;\n    }\n  }, {\n    key: \"calculateFocusDistance\",\n    value: function calculateFocusDistance(target) {\n      var camera = this.camera;\n      var viewDistance = camera.far - camera.near;\n      var distance = camera.position.distanceTo(target);\n      return Math.min(Math.max(distance / viewDistance, 0), 1);\n    }\n  }, {\n    key: \"setDepthTexture\",\n    value: function setDepthTexture(depthTexture) {\n      var depthPacking = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var material = this.circleOfConfusionMaterial;\n      material.uniforms.depthBuffer.value = depthTexture;\n      material.depthPacking = depthPacking;\n    }\n  }, {\n    key: \"update\",\n    value: function update(renderer, inputBuffer, deltaTime) {\n      var renderTarget = this.renderTarget;\n      var renderTargetCoC = this.renderTargetCoC;\n      var renderTargetCoCBlurred = this.renderTargetCoCBlurred;\n      var renderTargetMasked = this.renderTargetMasked;\n      var bokehFarBasePass = this.bokehFarBasePass;\n      var bokehFarFillPass = this.bokehFarFillPass;\n      var farBaseUniforms = bokehFarBasePass.getFullscreenMaterial().uniforms;\n      var farFillUniforms = bokehFarFillPass.getFullscreenMaterial().uniforms;\n      var bokehNearBasePass = this.bokehNearBasePass;\n      var bokehNearFillPass = this.bokehNearFillPass;\n      var nearBaseUniforms = bokehNearBasePass.getFullscreenMaterial().uniforms;\n      var nearFillUniforms = bokehNearFillPass.getFullscreenMaterial().uniforms;\n\n      if (this.target !== null) {\n        var distance = this.calculateFocusDistance(this.target);\n        this.circleOfConfusionMaterial.uniforms.focusDistance.value = distance;\n      }\n\n      this.cocPass.render(renderer, null, renderTargetCoC);\n      this.blurPass.render(renderer, renderTargetCoC, renderTargetCoCBlurred);\n      this.maskPass.render(renderer, inputBuffer, renderTargetMasked);\n      farBaseUniforms.cocBuffer.value = farFillUniforms.cocBuffer.value = renderTargetCoC.texture;\n      bokehFarBasePass.render(renderer, renderTargetMasked, renderTarget);\n      bokehFarFillPass.render(renderer, renderTarget, this.renderTargetFar);\n      nearBaseUniforms.cocBuffer.value = nearFillUniforms.cocBuffer.value = renderTargetCoCBlurred.texture;\n      bokehNearBasePass.render(renderer, inputBuffer, renderTarget);\n      bokehNearFillPass.render(renderer, renderTarget, this.renderTargetNear);\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      var resolution = this.resolution;\n      var resizables = [this.cocPass, this.blurPass, this.maskPass, this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass];\n      resizables.push(this.renderTargetCoC, this.renderTargetMasked);\n      resizables.forEach(function (r) {\n        return r.setSize(width, height);\n      });\n      var w = resolution.width;\n      var h = resolution.height;\n      resizables = [this.renderTarget, this.renderTargetNear, this.renderTargetFar, this.renderTargetCoCBlurred];\n      resizables.forEach(function (r) {\n        return r.setSize(w, h);\n      });\n      var passes = [this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass];\n      passes.forEach(function (p) {\n        return p.getFullscreenMaterial().setTexelSize(1 / w, 1 / h);\n      });\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize(renderer, alpha, frameBufferType) {\n      var initializables = [this.cocPass, this.maskPass, this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass];\n      initializables.forEach(function (i) {\n        return i.initialize(renderer, alpha, frameBufferType);\n      });\n      this.blurPass.initialize(renderer, alpha, UnsignedByteType5);\n\n      if (!alpha && frameBufferType === UnsignedByteType5) {\n        this.renderTargetNear.texture.type = RGBFormat6;\n      }\n\n      if (frameBufferType !== void 0) {\n        this.renderTarget.texture.type = frameBufferType;\n        this.renderTargetNear.texture.type = frameBufferType;\n        this.renderTargetFar.texture.type = frameBufferType;\n        this.renderTargetMasked.texture.type = frameBufferType;\n      }\n    }\n  }]);\n\n  return DepthOfFieldEffect;\n}(Effect); // src/effects/DotScreenEffect.js\n\n\nimport { Uniform as Uniform25, Vector2 as Vector214 } from \"three\"; // src/effects/glsl/dot-screen/shader.frag\n\nvar shader_default53 = \"uniform vec2 angle;\\r\\nuniform float scale;\\r\\n\\r\\nfloat pattern(const in vec2 uv) {\\r\\n\\r\\n\tvec2 point = scale * vec2(\\r\\n\t\tdot(angle.yx, vec2(uv.x, -uv.y)),\\r\\n\t\tdot(angle, uv)\\r\\n\t);\\r\\n\\r\\n\treturn (sin(point.x) * sin(point.y)) * 4.0;\\r\\n\\r\\n}\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\tvec3 color = vec3(inputColor.rgb * 10.0 - 5.0 + pattern(uv * resolution));\\r\\n\toutputColor = vec4(color, inputColor.a);\\r\\n\\r\\n}\\r\\n\"; // src/effects/DotScreenEffect.js\n\nvar DotScreenEffect = /*#__PURE__*/function (_Effect9) {\n  _inherits(DotScreenEffect, _Effect9);\n\n  var _super43 = _createSuper(DotScreenEffect);\n\n  function DotScreenEffect() {\n    var _this41;\n\n    var _ref16 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref16$blendFunction = _ref16.blendFunction,\n        blendFunction = _ref16$blendFunction === void 0 ? BlendFunction.NORMAL : _ref16$blendFunction,\n        _ref16$angle = _ref16.angle,\n        angle = _ref16$angle === void 0 ? Math.PI * 0.5 : _ref16$angle,\n        _ref16$scale = _ref16.scale,\n        scale = _ref16$scale === void 0 ? 1 : _ref16$scale;\n\n    _classCallCheck(this, DotScreenEffect);\n\n    _this41 = _super43.call(this, \"DotScreenEffect\", shader_default53, {\n      blendFunction: blendFunction,\n      uniforms: new Map([[\"angle\", new Uniform25(new Vector214())], [\"scale\", new Uniform25(scale)]])\n    });\n\n    _this41.setAngle(angle);\n\n    return _this41;\n  }\n\n  _createClass(DotScreenEffect, [{\n    key: \"setAngle\",\n    value: function setAngle(angle) {\n      this.uniforms.get(\"angle\").value.set(Math.sin(angle), Math.cos(angle));\n    }\n  }]);\n\n  return DotScreenEffect;\n}(Effect); // src/effects/GammaCorrectionEffect.js\n\n\nimport { Uniform as Uniform26 } from \"three\"; // src/effects/glsl/gamma-correction/shader.frag\n\nvar shader_default54 = \"uniform float gamma;\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\toutputColor = LinearToGamma(max(inputColor, 0.0), gamma);\\r\\n\\r\\n}\\r\\n\"; // src/effects/GammaCorrectionEffect.js\n\nvar GammaCorrectionEffect = /*#__PURE__*/function (_Effect10) {\n  _inherits(GammaCorrectionEffect, _Effect10);\n\n  var _super44 = _createSuper(GammaCorrectionEffect);\n\n  function GammaCorrectionEffect() {\n    var _ref17 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref17$blendFunction = _ref17.blendFunction,\n        blendFunction = _ref17$blendFunction === void 0 ? BlendFunction.NORMAL : _ref17$blendFunction,\n        _ref17$gamma = _ref17.gamma,\n        gamma = _ref17$gamma === void 0 ? 2 : _ref17$gamma;\n\n    _classCallCheck(this, GammaCorrectionEffect);\n\n    return _super44.call(this, \"GammaCorrectionEffect\", shader_default54, {\n      blendFunction: blendFunction,\n      uniforms: new Map([[\"gamma\", new Uniform26(gamma)]])\n    });\n  }\n\n  return GammaCorrectionEffect;\n}(Effect); // src/effects/GlitchEffect.js\n\n\nimport { NearestFilter as NearestFilter5, RepeatWrapping, RGBFormat as RGBFormat8, Uniform as Uniform27, Vector2 as Vector215 } from \"three\"; // src/images/textures/NoiseTexture.js\n\nimport { DataTexture, LuminanceFormat as LuminanceFormat2, RedFormat, RGFormat, RGBFormat as RGBFormat7, RGBAFormat as RGBAFormat4, UnsignedByteType as UnsignedByteType6 } from \"three\";\n\nfunction getNoise(size, format, type) {\n  var channels = new Map([[LuminanceFormat2, 1], [RedFormat, 1], [RGFormat, 2], [RGBFormat7, 3], [RGBAFormat4, 4]]);\n  var data;\n\n  if (!channels.has(format)) {\n    console.error(\"Invalid noise texture format\");\n  }\n\n  if (type === UnsignedByteType6) {\n    data = new Uint8Array(size * channels.get(format));\n\n    for (var i = 0, l = data.length; i < l; ++i) {\n      data[i] = Math.random() * 255;\n    }\n  } else {\n    data = new Float32Array(size * channels.get(format));\n\n    for (var _i6 = 0, _l = data.length; _i6 < _l; ++_i6) {\n      data[_i6] = Math.random();\n    }\n  }\n\n  return data;\n}\n\nvar NoiseTexture = /*#__PURE__*/function (_DataTexture) {\n  _inherits(NoiseTexture, _DataTexture);\n\n  var _super45 = _createSuper(NoiseTexture);\n\n  function NoiseTexture(width, height) {\n    var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : LuminanceFormat2;\n    var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : UnsignedByteType6;\n\n    _classCallCheck(this, NoiseTexture);\n\n    return _super45.call(this, getNoise(width * height, format, type), width, height, format, type);\n  }\n\n  return NoiseTexture;\n}(DataTexture); // src/effects/glsl/glitch/shader.frag\n\n\nvar shader_default55 = \"uniform sampler2D perturbationMap;\\r\\n\\r\\nuniform bool active;\\r\\nuniform float columns;\\r\\nuniform float random;\\r\\nuniform vec2 seed;\\r\\nuniform vec2 distortion;\\r\\n\\r\\nvoid mainUv(inout vec2 uv) {\\r\\n\\r\\n\tif(active) {\\r\\n\\r\\n\t\tif(uv.y < distortion.x + columns && uv.y > distortion.x - columns * random) {\\r\\n\\r\\n\t\t\tfloat sx = clamp(ceil(seed.x), 0.0, 1.0);\\r\\n\t\t\tuv.y = sx * (1.0 - (uv.y + distortion.y)) + (1.0 - sx) * distortion.y;\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t\tif(uv.x < distortion.y + columns && uv.x > distortion.y - columns * random) {\\r\\n\\r\\n\t\t\tfloat sy = clamp(ceil(seed.y), 0.0, 1.0);\\r\\n\t\t\tuv.x = sy * distortion.x + (1.0 - sy) * (1.0 - (uv.x + distortion.x));\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t\tvec2 normal = texture2D(perturbationMap, uv * random * random).rg;\\r\\n\t\tuv += normal * seed * (random * 0.2);\\r\\n\\r\\n\t}\\r\\n\\r\\n}\\r\\n\"; // src/effects/GlitchEffect.js\n\nvar tag = \"Glitch.Generated\";\n\nfunction randomFloat(low, high) {\n  return low + Math.random() * (high - low);\n}\n\nvar GlitchEffect = /*#__PURE__*/function (_Effect11) {\n  _inherits(GlitchEffect, _Effect11);\n\n  var _super46 = _createSuper(GlitchEffect);\n\n  function GlitchEffect() {\n    var _this42;\n\n    var _ref18 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref18$blendFunction = _ref18.blendFunction,\n        blendFunction = _ref18$blendFunction === void 0 ? BlendFunction.NORMAL : _ref18$blendFunction,\n        _ref18$chromaticAberr = _ref18.chromaticAberrationOffset,\n        chromaticAberrationOffset = _ref18$chromaticAberr === void 0 ? null : _ref18$chromaticAberr,\n        _ref18$delay = _ref18.delay,\n        delay = _ref18$delay === void 0 ? new Vector215(1.5, 3.5) : _ref18$delay,\n        _ref18$duration = _ref18.duration,\n        duration = _ref18$duration === void 0 ? new Vector215(0.6, 1) : _ref18$duration,\n        _ref18$strength = _ref18.strength,\n        strength = _ref18$strength === void 0 ? new Vector215(0.3, 1) : _ref18$strength,\n        _ref18$columns = _ref18.columns,\n        columns = _ref18$columns === void 0 ? 0.05 : _ref18$columns,\n        _ref18$ratio = _ref18.ratio,\n        ratio = _ref18$ratio === void 0 ? 0.85 : _ref18$ratio,\n        _ref18$perturbationMa = _ref18.perturbationMap,\n        perturbationMap = _ref18$perturbationMa === void 0 ? null : _ref18$perturbationMa,\n        _ref18$dtSize = _ref18.dtSize,\n        dtSize = _ref18$dtSize === void 0 ? 64 : _ref18$dtSize;\n\n    _classCallCheck(this, GlitchEffect);\n\n    _this42 = _super46.call(this, \"GlitchEffect\", shader_default55, {\n      blendFunction: blendFunction,\n      uniforms: new Map([[\"perturbationMap\", new Uniform27(null)], [\"columns\", new Uniform27(columns)], [\"active\", new Uniform27(false)], [\"random\", new Uniform27(1)], [\"seed\", new Uniform27(new Vector215())], [\"distortion\", new Uniform27(new Vector215())]])\n    });\n\n    _this42.setPerturbationMap(perturbationMap === null ? _this42.generatePerturbationMap(dtSize) : perturbationMap);\n\n    _this42.delay = delay;\n    _this42.duration = duration;\n    _this42.breakPoint = new Vector215(randomFloat(_this42.delay.x, _this42.delay.y), randomFloat(_this42.duration.x, _this42.duration.y));\n    _this42.time = 0;\n    _this42.seed = _this42.uniforms.get(\"seed\").value;\n    _this42.distortion = _this42.uniforms.get(\"distortion\").value;\n    _this42.mode = GlitchMode.SPORADIC;\n    _this42.strength = strength;\n    _this42.ratio = ratio;\n    _this42.chromaticAberrationOffset = chromaticAberrationOffset;\n    return _this42;\n  }\n\n  _createClass(GlitchEffect, [{\n    key: \"active\",\n    get: function get() {\n      return this.uniforms.get(\"active\").value;\n    }\n  }, {\n    key: \"getPerturbationMap\",\n    value: function getPerturbationMap() {\n      return this.uniforms.get(\"perturbationMap\").value;\n    }\n  }, {\n    key: \"setPerturbationMap\",\n    value: function setPerturbationMap(map) {\n      var currentMap = this.getPerturbationMap();\n\n      if (currentMap !== null && currentMap.name === tag) {\n        currentMap.dispose();\n      }\n\n      map.minFilter = map.magFilter = NearestFilter5;\n      map.wrapS = map.wrapT = RepeatWrapping;\n      map.generateMipmaps = false;\n      this.uniforms.get(\"perturbationMap\").value = map;\n    }\n  }, {\n    key: \"generatePerturbationMap\",\n    value: function generatePerturbationMap() {\n      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 64;\n      var map = new NoiseTexture(size, size, RGBFormat8);\n      map.name = tag;\n      return map;\n    }\n  }, {\n    key: \"update\",\n    value: function update(renderer, inputBuffer, deltaTime) {\n      var mode = this.mode;\n      var breakPoint = this.breakPoint;\n      var offset = this.chromaticAberrationOffset;\n      var s = this.strength;\n      var time = this.time;\n      var active = false;\n      var r = 0,\n          a = 0;\n      var trigger;\n\n      if (mode !== GlitchMode.DISABLED) {\n        if (mode === GlitchMode.SPORADIC) {\n          time += deltaTime;\n          trigger = time > breakPoint.x;\n\n          if (time >= breakPoint.x + breakPoint.y) {\n            breakPoint.set(randomFloat(this.delay.x, this.delay.y), randomFloat(this.duration.x, this.duration.y));\n            time = 0;\n          }\n        }\n\n        r = Math.random();\n        this.uniforms.get(\"random\").value = r;\n\n        if (trigger && r > this.ratio || mode === GlitchMode.CONSTANT_WILD) {\n          active = true;\n          r *= s.y * 0.03;\n          a = randomFloat(-Math.PI, Math.PI);\n          this.seed.set(randomFloat(-s.y, s.y), randomFloat(-s.y, s.y));\n          this.distortion.set(randomFloat(0, 1), randomFloat(0, 1));\n        } else if (trigger || mode === GlitchMode.CONSTANT_MILD) {\n          active = true;\n          r *= s.x * 0.03;\n          a = randomFloat(-Math.PI, Math.PI);\n          this.seed.set(randomFloat(-s.x, s.x), randomFloat(-s.x, s.x));\n          this.distortion.set(randomFloat(0, 1), randomFloat(0, 1));\n        }\n\n        this.time = time;\n      }\n\n      if (offset !== null) {\n        if (active) {\n          offset.set(Math.cos(a), Math.sin(a)).multiplyScalar(r);\n        } else {\n          offset.set(0, 0);\n        }\n      }\n\n      this.uniforms.get(\"active\").value = active;\n    }\n  }]);\n\n  return GlitchEffect;\n}(Effect);\n\nvar GlitchMode = {\n  DISABLED: 0,\n  SPORADIC: 1,\n  CONSTANT_MILD: 2,\n  CONSTANT_WILD: 3\n}; // src/effects/GodRaysEffect.js\n\nimport { Color as Color4, DepthTexture as DepthTexture2, LinearFilter as LinearFilter7, Matrix4 as Matrix42, RGBFormat as RGBFormat9, Scene as Scene3, Uniform as Uniform28, Vector2 as Vector216, Vector3, UnsignedByteType as UnsignedByteType7, WebGLRenderTarget as WebGLRenderTarget11 } from \"three\"; // src/effects/glsl/god-rays/shader.frag\n\nvar shader_default56 = \"uniform sampler2D texture;\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\toutputColor = texture2D(texture, uv);\\r\\n\\r\\n}\\r\\n\"; // src/effects/GodRaysEffect.js\n\nvar v = new Vector3();\nvar m = new Matrix42();\n\nvar GodRaysEffect = /*#__PURE__*/function (_Effect12) {\n  _inherits(GodRaysEffect, _Effect12);\n\n  var _super47 = _createSuper(GodRaysEffect);\n\n  function GodRaysEffect(camera, lightSource) {\n    var _this43;\n\n    var _ref19 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref19$blendFunction = _ref19.blendFunction,\n        blendFunction = _ref19$blendFunction === void 0 ? BlendFunction.SCREEN : _ref19$blendFunction,\n        _ref19$samples = _ref19.samples,\n        samples = _ref19$samples === void 0 ? 60 : _ref19$samples,\n        _ref19$density = _ref19.density,\n        density = _ref19$density === void 0 ? 0.96 : _ref19$density,\n        _ref19$decay = _ref19.decay,\n        decay = _ref19$decay === void 0 ? 0.9 : _ref19$decay,\n        _ref19$weight = _ref19.weight,\n        weight = _ref19$weight === void 0 ? 0.4 : _ref19$weight,\n        _ref19$exposure = _ref19.exposure,\n        exposure = _ref19$exposure === void 0 ? 0.6 : _ref19$exposure,\n        _ref19$clampMax = _ref19.clampMax,\n        clampMax = _ref19$clampMax === void 0 ? 1 : _ref19$clampMax,\n        _ref19$resolutionScal = _ref19.resolutionScale,\n        resolutionScale = _ref19$resolutionScal === void 0 ? 0.5 : _ref19$resolutionScal,\n        _ref19$width = _ref19.width,\n        width = _ref19$width === void 0 ? Resizer.AUTO_SIZE : _ref19$width,\n        _ref19$height = _ref19.height,\n        height = _ref19$height === void 0 ? Resizer.AUTO_SIZE : _ref19$height,\n        _ref19$kernelSize = _ref19.kernelSize,\n        kernelSize = _ref19$kernelSize === void 0 ? KernelSize.SMALL : _ref19$kernelSize,\n        _ref19$blur = _ref19.blur,\n        blur = _ref19$blur === void 0 ? true : _ref19$blur;\n\n    _classCallCheck(this, GodRaysEffect);\n\n    _this43 = _super47.call(this, \"GodRaysEffect\", shader_default56, {\n      blendFunction: blendFunction,\n      attributes: EffectAttribute.DEPTH,\n      uniforms: new Map([[\"texture\", new Uniform28(null)]])\n    });\n    _this43.camera = camera;\n    _this43.lightSource = lightSource;\n    _this43.lightSource.material.depthWrite = false;\n    _this43.lightSource.material.transparent = true;\n    _this43.lightScene = new Scene3();\n    _this43.screenPosition = new Vector216();\n    _this43.renderTargetA = new WebGLRenderTarget11(1, 1, {\n      minFilter: LinearFilter7,\n      magFilter: LinearFilter7,\n      stencilBuffer: false,\n      depthBuffer: false\n    });\n    _this43.renderTargetA.texture.name = \"GodRays.Target.A\";\n    _this43.renderTargetB = _this43.renderTargetA.clone();\n    _this43.renderTargetB.texture.name = \"GodRays.Target.B\";\n    _this43.uniforms.get(\"texture\").value = _this43.renderTargetB.texture;\n    _this43.renderTargetLight = _this43.renderTargetA.clone();\n    _this43.renderTargetLight.texture.name = \"GodRays.Light\";\n    _this43.renderTargetLight.depthBuffer = true;\n    _this43.renderTargetLight.depthTexture = new DepthTexture2();\n    _this43.renderPassLight = new RenderPass(_this43.lightScene, camera);\n    _this43.renderPassLight.getClearPass().overrideClearColor = new Color4(0);\n    _this43.clearPass = new ClearPass(true, false, false);\n    _this43.clearPass.overrideClearColor = new Color4(0);\n    _this43.blurPass = new BlurPass({\n      resolutionScale: resolutionScale,\n      width: width,\n      height: height,\n      kernelSize: kernelSize\n    });\n    _this43.blurPass.resolution.resizable = _assertThisInitialized(_this43);\n    _this43.depthMaskPass = new ShaderPass(new DepthMaskMaterial());\n\n    var depthMaskMaterial = _this43.depthMaskPass.getFullscreenMaterial();\n\n    depthMaskMaterial.uniforms.depthBuffer1.value = _this43.renderTargetLight.depthTexture;\n    _this43.godRaysPass = new ShaderPass(new GodRaysMaterial(_this43.screenPosition));\n\n    var godRaysMaterial = _this43.godRaysPass.getFullscreenMaterial();\n\n    godRaysMaterial.uniforms.density.value = density;\n    godRaysMaterial.uniforms.decay.value = decay;\n    godRaysMaterial.uniforms.weight.value = weight;\n    godRaysMaterial.uniforms.exposure.value = exposure;\n    godRaysMaterial.uniforms.clampMax.value = clampMax;\n    _this43.samples = samples;\n    _this43.blur = blur;\n    return _this43;\n  }\n\n  _createClass(GodRaysEffect, [{\n    key: \"texture\",\n    get: function get() {\n      return this.renderTargetB.texture;\n    }\n  }, {\n    key: \"godRaysMaterial\",\n    get: function get() {\n      return this.godRaysPass.getFullscreenMaterial();\n    }\n  }, {\n    key: \"resolution\",\n    get: function get() {\n      return this.blurPass.resolution;\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.resolution.width;\n    },\n    set: function set(value) {\n      this.resolution.width = value;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.resolution.height;\n    },\n    set: function set(value) {\n      this.resolution.height = value;\n    }\n  }, {\n    key: \"dithering\",\n    get: function get() {\n      return this.godRaysMaterial.dithering;\n    },\n    set: function set(value) {\n      var material = this.godRaysMaterial;\n      material.dithering = value;\n      material.needsUpdate = true;\n    }\n  }, {\n    key: \"blur\",\n    get: function get() {\n      return this.blurPass.enabled;\n    },\n    set: function set(value) {\n      this.blurPass.enabled = value;\n    }\n  }, {\n    key: \"kernelSize\",\n    get: function get() {\n      return this.blurPass.kernelSize;\n    },\n    set: function set(value) {\n      this.blurPass.kernelSize = value;\n    }\n  }, {\n    key: \"getResolutionScale\",\n    value: function getResolutionScale() {\n      return this.resolution.scale;\n    }\n  }, {\n    key: \"setResolutionScale\",\n    value: function setResolutionScale(scale) {\n      this.resolution.scale = scale;\n    }\n  }, {\n    key: \"samples\",\n    get: function get() {\n      return this.godRaysMaterial.samples;\n    },\n    set: function set(value) {\n      this.godRaysMaterial.samples = value;\n    }\n  }, {\n    key: \"setDepthTexture\",\n    value: function setDepthTexture(depthTexture) {\n      var depthPacking = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var material = this.depthMaskPass.getFullscreenMaterial();\n      material.uniforms.depthBuffer0.value = depthTexture;\n      material.defines.DEPTH_PACKING_0 = depthPacking.toFixed(0);\n      material.needsUpdate = true;\n    }\n  }, {\n    key: \"update\",\n    value: function update(renderer, inputBuffer, deltaTime) {\n      var lightSource = this.lightSource;\n      var parent = lightSource.parent;\n      var matrixAutoUpdate = lightSource.matrixAutoUpdate;\n      var renderTargetA = this.renderTargetA;\n      var renderTargetLight = this.renderTargetLight;\n      lightSource.material.depthWrite = true;\n      lightSource.matrixAutoUpdate = false;\n      lightSource.updateWorldMatrix(true, false);\n\n      if (parent !== null) {\n        if (!matrixAutoUpdate) {\n          m.copy(lightSource.matrix);\n        }\n\n        lightSource.matrix.copy(lightSource.matrixWorld);\n      }\n\n      this.lightScene.add(lightSource);\n      this.renderPassLight.render(renderer, renderTargetLight);\n      this.clearPass.render(renderer, renderTargetA);\n      this.depthMaskPass.render(renderer, renderTargetLight, renderTargetA);\n      lightSource.material.depthWrite = false;\n      lightSource.matrixAutoUpdate = matrixAutoUpdate;\n\n      if (parent !== null) {\n        if (!matrixAutoUpdate) {\n          lightSource.matrix.copy(m);\n        }\n\n        parent.add(lightSource);\n      }\n\n      v.setFromMatrixPosition(lightSource.matrixWorld).project(this.camera);\n      this.screenPosition.set(Math.min(Math.max((v.x + 1) * 0.5, -1), 2), Math.min(Math.max((v.y + 1) * 0.5, -1), 2));\n\n      if (this.blur) {\n        this.blurPass.render(renderer, renderTargetA, renderTargetA);\n      }\n\n      this.godRaysPass.render(renderer, renderTargetA, this.renderTargetB);\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      this.blurPass.setSize(width, height);\n      this.renderPassLight.setSize(width, height);\n      this.depthMaskPass.setSize(width, height);\n      this.godRaysPass.setSize(width, height);\n      var w = this.resolution.width;\n      var h = this.resolution.height;\n      this.renderTargetA.setSize(w, h);\n      this.renderTargetB.setSize(w, h);\n      this.renderTargetLight.setSize(w, h);\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize(renderer, alpha, frameBufferType) {\n      this.blurPass.initialize(renderer, alpha, frameBufferType);\n      this.renderPassLight.initialize(renderer, alpha, frameBufferType);\n      this.depthMaskPass.initialize(renderer, alpha, frameBufferType);\n      this.godRaysPass.initialize(renderer, alpha, frameBufferType);\n\n      if (!alpha && frameBufferType === UnsignedByteType7) {\n        this.renderTargetA.texture.format = RGBFormat9;\n        this.renderTargetB.texture.format = RGBFormat9;\n        this.renderTargetLight.texture.format = RGBFormat9;\n      }\n\n      if (frameBufferType !== void 0) {\n        this.renderTargetA.texture.type = frameBufferType;\n        this.renderTargetB.texture.type = frameBufferType;\n        this.renderTargetLight.texture.type = frameBufferType;\n      }\n    }\n  }]);\n\n  return GodRaysEffect;\n}(Effect); // src/effects/GridEffect.js\n\n\nimport { Uniform as Uniform29, Vector2 as Vector217 } from \"three\"; // src/effects/glsl/grid/shader.frag\n\nvar shader_default57 = \"uniform vec2 scale;\\r\\nuniform float lineWidth;\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\tfloat grid = 0.5 - max(abs(mod(uv.x * scale.x, 1.0) - 0.5), abs(mod(uv.y * scale.y, 1.0) - 0.5));\\r\\n\toutputColor = vec4(vec3(smoothstep(0.0, lineWidth, grid)), inputColor.a);\\r\\n\\r\\n}\\r\\n\"; // src/effects/GridEffect.js\n\nvar GridEffect = /*#__PURE__*/function (_Effect13) {\n  _inherits(GridEffect, _Effect13);\n\n  var _super48 = _createSuper(GridEffect);\n\n  function GridEffect() {\n    var _this44;\n\n    var _ref20 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref20$blendFunction = _ref20.blendFunction,\n        blendFunction = _ref20$blendFunction === void 0 ? BlendFunction.OVERLAY : _ref20$blendFunction,\n        _ref20$scale = _ref20.scale,\n        scale = _ref20$scale === void 0 ? 1 : _ref20$scale,\n        _ref20$lineWidth = _ref20.lineWidth,\n        lineWidth = _ref20$lineWidth === void 0 ? 0 : _ref20$lineWidth;\n\n    _classCallCheck(this, GridEffect);\n\n    _this44 = _super48.call(this, \"GridEffect\", shader_default57, {\n      blendFunction: blendFunction,\n      uniforms: new Map([[\"scale\", new Uniform29(new Vector217())], [\"lineWidth\", new Uniform29(lineWidth)]])\n    });\n    _this44.resolution = new Vector217();\n    _this44.scale = Math.max(scale, 1e-6);\n    _this44.lineWidth = Math.max(lineWidth, 0);\n    return _this44;\n  }\n\n  _createClass(GridEffect, [{\n    key: \"getScale\",\n    value: function getScale() {\n      return this.scale;\n    }\n  }, {\n    key: \"setScale\",\n    value: function setScale(scale) {\n      this.scale = scale;\n      this.setSize(this.resolution.x, this.resolution.y);\n    }\n  }, {\n    key: \"getLineWidth\",\n    value: function getLineWidth() {\n      return this.lineWidth;\n    }\n  }, {\n    key: \"setLineWidth\",\n    value: function setLineWidth(lineWidth) {\n      this.lineWidth = lineWidth;\n      this.setSize(this.resolution.x, this.resolution.y);\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      this.resolution.set(width, height);\n      var aspect = width / height;\n      var scale = this.scale * (height * 0.125);\n      this.uniforms.get(\"scale\").value.set(aspect * scale, scale);\n      this.uniforms.get(\"lineWidth\").value = scale / height + this.lineWidth;\n    }\n  }]);\n\n  return GridEffect;\n}(Effect); // src/effects/HueSaturationEffect.js\n\n\nimport { Uniform as Uniform30, Vector3 as Vector32 } from \"three\"; // src/effects/glsl/hue-saturation/shader.frag\n\nvar shader_default58 = \"uniform vec3 hue;\\r\\nuniform float saturation;\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\t// Hue.\\r\\n\tvec3 color = vec3(\\r\\n\t\tdot(inputColor.rgb, hue.xyz),\\r\\n\t\tdot(inputColor.rgb, hue.zxy),\\r\\n\t\tdot(inputColor.rgb, hue.yzx)\\r\\n\t);\\r\\n\\r\\n\t// Saturation.\\r\\n\tfloat average = (color.r + color.g + color.b) / 3.0;\\r\\n\tvec3 diff = average - color;\\r\\n\\r\\n\tif(saturation > 0.0) {\\r\\n\\r\\n\t\tcolor += diff * (1.0 - 1.0 / (1.001 - saturation));\\r\\n\\r\\n\t} else {\\r\\n\\r\\n\t\tcolor += diff * -saturation;\\r\\n\\r\\n\t}\\r\\n\\r\\n\toutputColor = vec4(min(color, 1.0), inputColor.a);\\r\\n\\r\\n}\\r\\n\"; // src/effects/HueSaturationEffect.js\n\nvar HueSaturationEffect = /*#__PURE__*/function (_Effect14) {\n  _inherits(HueSaturationEffect, _Effect14);\n\n  var _super49 = _createSuper(HueSaturationEffect);\n\n  function HueSaturationEffect() {\n    var _this45;\n\n    var _ref21 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref21$blendFunction = _ref21.blendFunction,\n        blendFunction = _ref21$blendFunction === void 0 ? BlendFunction.NORMAL : _ref21$blendFunction,\n        _ref21$hue = _ref21.hue,\n        hue = _ref21$hue === void 0 ? 0 : _ref21$hue,\n        _ref21$saturation = _ref21.saturation,\n        saturation = _ref21$saturation === void 0 ? 0 : _ref21$saturation;\n\n    _classCallCheck(this, HueSaturationEffect);\n\n    _this45 = _super49.call(this, \"HueSaturationEffect\", shader_default58, {\n      blendFunction: blendFunction,\n      uniforms: new Map([[\"hue\", new Uniform30(new Vector32())], [\"saturation\", new Uniform30(saturation)]])\n    });\n\n    _this45.setHue(hue);\n\n    return _this45;\n  }\n\n  _createClass(HueSaturationEffect, [{\n    key: \"setHue\",\n    value: function setHue(hue) {\n      var s = Math.sin(hue),\n          c2 = Math.cos(hue);\n      this.uniforms.get(\"hue\").value.set(2 * c2, -Math.sqrt(3) * s - c2, Math.sqrt(3) * s - c2).addScalar(1).divideScalar(3);\n    }\n  }]);\n\n  return HueSaturationEffect;\n}(Effect); // src/effects/LUTEffect.js\n\n\nimport { DataTexture3D as DataTexture3D2, FloatType as FloatType3, HalfFloatType as HalfFloatType2, LinearEncoding as LinearEncoding2, LinearFilter as LinearFilter9, NearestFilter as NearestFilter6, sRGBEncoding as sRGBEncoding2, Uniform as Uniform31, Vector3 as Vector34 } from \"three\"; // src/images/textures/LookupTexture3D.js\n\nimport { Color as Color5, ClampToEdgeWrapping, DataTexture as DataTexture2, DataTexture3D, FloatType as FloatType2, LinearFilter as LinearFilter8, LinearEncoding, RGBFormat as RGBFormat10, RGBAFormat as RGBAFormat5, sRGBEncoding, UnsignedByteType as UnsignedByteType8, Vector3 as Vector33 } from \"three\"; // src/images/RawImageData.js\n\nfunction createCanvas(width, height, data) {\n  var canvas = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\");\n  var context = canvas.getContext(\"2d\");\n  canvas.width = width;\n  canvas.height = height;\n\n  if (data instanceof Image) {\n    context.drawImage(data, 0, 0);\n  } else {\n    var imageData = context.createImageData(width, height);\n    imageData.data.set(data);\n    context.putImageData(imageData, 0, 0);\n  }\n\n  return canvas;\n}\n\nvar RawImageData = /*#__PURE__*/function () {\n  function RawImageData() {\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, RawImageData);\n\n    this.width = width;\n    this.height = height;\n    this.data = data;\n  }\n\n  _createClass(RawImageData, [{\n    key: \"toCanvas\",\n    value: function toCanvas() {\n      return typeof document === \"undefined\" ? null : createCanvas(this.width, this.height, this.data);\n    }\n  }], [{\n    key: \"from\",\n    value: function from(image) {\n      var width = image.width,\n          height = image.height;\n      var data;\n\n      if (image instanceof Image) {\n        var canvas = createCanvas(width, height, image);\n\n        if (canvas !== null) {\n          var context = canvas.getContext(\"2d\");\n          data = context.getImageData(0, 0, width, height).data;\n        }\n      } else {\n        data = image.data;\n      }\n\n      return new RawImageData(width, height, data);\n    }\n  }]);\n\n  return RawImageData;\n}(); // src/images/lut/LUTOperation.js\n\n\nvar LUTOperation = {\n  SCALE_UP: \"lut.scaleup\"\n}; // tmp/lut.worker\n\nvar lut_default = '(()=>{var q={SCALE_UP:\"lut.scaleup\"};var _=[new Float32Array(3),new Float32Array(3)],t=[new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3)],U=[[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([0,1,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([0,1,1]),new Float32Array([1,1,1])]];function L(a,n,r,m){let h=r[0]-n[0],e=r[1]-n[1],s=r[2]-n[2],l=a[0]-n[0],w=a[1]-n[1],c=a[2]-n[2],y=e*c-s*w,A=s*l-h*c,g=h*w-e*l,p=Math.sqrt(y*y+A*A+g*g),V=p*.5,F=y/p,f=A/p,i=g/p,u=-(a[0]*F+a[1]*f+a[2]*i),M=m[0]*F+m[1]*f+m[2]*i;return Math.abs(M+u)*V/3}function X(a,n,r,m,h,e){let s=(r+m*n+h*n*n)*3;e[0]=a[s+0],e[1]=a[s+1],e[2]=a[s+2]}function k(a,n,r,m,h,e){let s=r*(n-1),l=m*(n-1),w=h*(n-1),c=Math.floor(s),y=Math.floor(l),A=Math.floor(w),g=Math.ceil(s),p=Math.ceil(l),V=Math.ceil(w),F=s-c,f=l-y,i=w-A;if(c===s&&y===l&&A===w)X(a,n,s,l,w,e);else{let u;F>=f&&f>=i?u=U[0]:F>=i&&i>=f?u=U[1]:i>=F&&F>=f?u=U[2]:f>=F&&F>=i?u=U[3]:f>=i&&i>=F?u=U[4]:i>=f&&f>=F&&(u=U[5]);let[M,x,P,T]=u,d=_[0];d[0]=F,d[1]=f,d[2]=i;let o=_[1],Y=g-c,Z=p-y,b=V-A;o[0]=Y*M[0]+c,o[1]=Z*M[1]+y,o[2]=b*M[2]+A,X(a,n,o[0],o[1],o[2],t[0]),o[0]=Y*x[0]+c,o[1]=Z*x[1]+y,o[2]=b*x[2]+A,X(a,n,o[0],o[1],o[2],t[1]),o[0]=Y*P[0]+c,o[1]=Z*P[1]+y,o[2]=b*P[2]+A,X(a,n,o[0],o[1],o[2],t[2]),o[0]=Y*T[0]+c,o[1]=Z*T[1]+y,o[2]=b*T[2]+A,X(a,n,o[0],o[1],o[2],t[3]);let v=L(x,P,T,d)*6,S=L(M,P,T,d)*6,C=L(M,x,T,d)*6,E=L(M,x,P,d)*6;t[0][0]*=v,t[0][1]*=v,t[0][2]*=v,t[1][0]*=S,t[1][1]*=S,t[1][2]*=S,t[2][0]*=C,t[2][1]*=C,t[2][2]*=C,t[3][0]*=E,t[3][1]*=E,t[3][2]*=E,e[0]=t[0][0]+t[1][0]+t[2][0]+t[3][0],e[1]=t[0][1]+t[1][1]+t[2][1]+t[3][1],e[2]=t[0][2]+t[1][2]+t[2][2]+t[3][2]}}var O=class{static expand(n,r){let m=Math.cbrt(n.length/3),h=new Float32Array(3),e=new n.constructor(r**3*3),s=1/(r-1);for(let l=0;l<r;++l)for(let w=0;w<r;++w)for(let c=0;c<r;++c){let y=c*s,A=w*s,g=l*s,p=Math.round(c+w*r+l*r*r)*3;k(n,m,y,A,g,h),e[p+0]=h[0],e[p+1]=h[1],e[p+2]=h[2]}return e}};self.addEventListener(\"message\",a=>{let n=a.data,r=n.data;switch(n.operation){case q.SCALE_UP:r=O.expand(r,n.size);break}postMessage(r,[r.buffer]),close()});})();\\n'; // src/images/textures/LookupTexture3D.js\n\nvar c = new Color5();\n\nvar LookupTexture3D = /*#__PURE__*/function (_DataTexture3D) {\n  _inherits(LookupTexture3D, _DataTexture3D);\n\n  var _super50 = _createSuper(LookupTexture3D);\n\n  function LookupTexture3D(data, size) {\n    var _this46;\n\n    _classCallCheck(this, LookupTexture3D);\n\n    _this46 = _super50.call(this, data, size, size, size);\n    _this46.type = FloatType2;\n    _this46.format = RGBFormat10;\n    _this46.encoding = LinearEncoding;\n    _this46.minFilter = LinearFilter8;\n    _this46.magFilter = LinearFilter8;\n    _this46.wrapS = ClampToEdgeWrapping;\n    _this46.wrapT = ClampToEdgeWrapping;\n    _this46.wrapR = ClampToEdgeWrapping;\n    _this46.unpackAlignment = 1;\n    _this46.domainMin = new Vector33(0, 0, 0);\n    _this46.domainMax = new Vector33(1, 1, 1);\n    return _this46;\n  }\n\n  _createClass(LookupTexture3D, [{\n    key: \"isLookupTexture3D\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"scaleUp\",\n    value: function scaleUp(size) {\n      var _this47 = this;\n\n      var transferData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var image = this.image;\n      var promise;\n\n      if (size <= image.width) {\n        promise = Promise.reject(new Error(\"The target size must be greater than the current size\"));\n      } else {\n        var workerURL = URL.createObjectURL(new Blob([lut_default], {\n          type: \"text/javascript\"\n        }));\n        var worker = new Worker(workerURL);\n        promise = new Promise(function (resolve, reject) {\n          worker.addEventListener(\"error\", function (event) {\n            return reject(event.error);\n          });\n          worker.addEventListener(\"message\", function (event) {\n            var lut = new LookupTexture3D(event.data, size);\n            lut.encoding = _this47.encoding;\n            lut.type = _this47.type;\n            lut.name = _this47.name;\n            URL.revokeObjectURL(workerURL);\n            resolve(lut);\n          });\n          var transferList = transferData ? [image.data.buffer] : [];\n          worker.postMessage({\n            operation: LUTOperation.SCALE_UP,\n            data: image.data,\n            size: size\n          }, transferList);\n        });\n      }\n\n      return promise;\n    }\n  }, {\n    key: \"applyLUT\",\n    value: function applyLUT(lut) {\n      var img0 = this.image;\n      var img1 = lut.image;\n      var size0 = Math.min(img0.width, img0.height, img0.depth);\n      var size1 = Math.min(img1.width, img1.height, img1.depth);\n\n      if (size0 !== size1) {\n        console.error(\"Size mismatch\");\n      } else if (lut.type !== FloatType2 || this.type !== FloatType2) {\n        console.error(\"Both LUTs must be FloatType textures\");\n      } else if (lut.format !== RGBFormat10 || this.format !== RGBFormat10) {\n        console.error(\"Both LUTs must be RGB textures\");\n      } else {\n        var data0 = img0.data;\n        var data1 = img1.data;\n        var size = size0;\n        var s = size - 1;\n\n        for (var i = 0, l = Math.pow(size, 3); i < l; ++i) {\n          var i3 = i * 3;\n          var r = data0[i3 + 0] * s;\n          var g = data0[i3 + 1] * s;\n          var b = data0[i3 + 2] * s;\n          var iRGB = Math.round(r + g * size + b * size * size) * 3;\n          data0[i3 + 0] = data1[iRGB + 0];\n          data0[i3 + 1] = data1[iRGB + 1];\n          data0[i3 + 2] = data1[iRGB + 2];\n        }\n\n        this.needsUpdate = true;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"convertToUint8\",\n    value: function convertToUint8() {\n      if (this.type === FloatType2) {\n        var floatData = this.image.data;\n        var uint8Data = new Uint8ClampedArray(floatData.length);\n\n        for (var i = 0, l = floatData.length; i < l; ++i) {\n          uint8Data[i] = floatData[i] * 255;\n        }\n\n        this.image.data = uint8Data;\n        this.type = UnsignedByteType8;\n        this.needsUpdate = true;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"convertToFloat\",\n    value: function convertToFloat() {\n      if (this.type === UnsignedByteType8) {\n        var uint8Data = this.image.data;\n        var floatData = new Float32Array(uint8Data.length);\n\n        for (var i = 0, l = uint8Data.length; i < l; ++i) {\n          floatData[i] = uint8Data[i] / 255;\n        }\n\n        this.image.data = floatData;\n        this.type = FloatType2;\n        this.needsUpdate = true;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"convertLinearToSRGB\",\n    value: function convertLinearToSRGB() {\n      var data = this.image.data;\n\n      if (this.type === FloatType2) {\n        var stride = this.format === RGBAFormat5 ? 4 : 3;\n\n        for (var i = 0, l = data.length; i < l; i += stride) {\n          c.fromArray(data, i).convertLinearToSRGB().toArray(data, i);\n        }\n\n        this.encoding = sRGBEncoding;\n        this.needsUpdate = true;\n      } else {\n        console.error(\"Color space conversion requires FloatType data\");\n      }\n\n      return this;\n    }\n  }, {\n    key: \"convertSRGBToLinear\",\n    value: function convertSRGBToLinear() {\n      var data = this.image.data;\n\n      if (this.type === FloatType2) {\n        var stride = this.format === RGBAFormat5 ? 4 : 3;\n\n        for (var i = 0, l = data.length; i < l; i += stride) {\n          c.fromArray(data, i).convertSRGBToLinear().toArray(data, i);\n        }\n\n        this.encoding = LinearEncoding;\n        this.needsUpdate = true;\n      } else {\n        console.error(\"Color space conversion requires FloatType data\");\n      }\n\n      return this;\n    }\n  }, {\n    key: \"convertToRGBA\",\n    value: function convertToRGBA() {\n      if (this.format === RGBFormat10) {\n        var size = this.image.width;\n        var rgbData = this.image.data;\n        var rgbaData = new rgbData.constructor(Math.pow(size, 3) * 4);\n        var maxValue = this.type === FloatType2 ? 1 : 255;\n\n        for (var i = 0, j = 0, l = rgbData.length; i < l; i += 3, j += 4) {\n          rgbaData[j + 0] = rgbData[i + 0];\n          rgbaData[j + 1] = rgbData[i + 1];\n          rgbaData[j + 2] = rgbData[i + 2];\n          rgbaData[j + 3] = maxValue;\n        }\n\n        this.image.data = rgbaData;\n        this.format = RGBAFormat5;\n        this.needsUpdate = true;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"toDataTexture\",\n    value: function toDataTexture() {\n      var width = this.image.width;\n      var height = this.image.height * this.image.depth;\n      var texture = new DataTexture2(this.image.data, width, height);\n      texture.name = this.name;\n      texture.type = this.type;\n      texture.format = this.format;\n      texture.encoding = this.encoding;\n      texture.minFilter = LinearFilter8;\n      texture.magFilter = LinearFilter8;\n      texture.wrapS = this.wrapS;\n      texture.wrapT = this.wrapT;\n      texture.generateMipmaps = false;\n      return texture;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(texture) {\n      var image = texture.image;\n      var width = image.width,\n          height = image.height;\n      var size = Math.min(width, height);\n      var data;\n\n      if (image instanceof Image) {\n        var rawImageData = RawImageData.from(image);\n        data = rawImageData.data;\n        var rearrangedData = new Uint8Array(Math.pow(size, 3) * 3);\n\n        if (width > height) {\n          for (var z = 0; z < size; ++z) {\n            for (var y = 0; y < size; ++y) {\n              for (var x = 0; x < size; ++x) {\n                var i4 = (x + z * size + y * size * size) * 4;\n                var i3 = (x + y * size + z * size * size) * 3;\n                rearrangedData[i3 + 0] = data[i4 + 0];\n                rearrangedData[i3 + 1] = data[i4 + 1];\n                rearrangedData[i3 + 2] = data[i4 + 2];\n              }\n            }\n          }\n        } else {\n          for (var i = 0, l = Math.pow(size, 3); i < l; ++i) {\n            var _i7 = i * 4;\n\n            var _i8 = i * 3;\n\n            rearrangedData[_i8 + 0] = data[_i7 + 0];\n            rearrangedData[_i8 + 1] = data[_i7 + 1];\n            rearrangedData[_i8 + 2] = data[_i7 + 2];\n          }\n        }\n\n        data = rearrangedData;\n      } else {\n        data = image.data.slice();\n      }\n\n      var lut = new LookupTexture3D(data, size);\n      lut.type = texture.type;\n      lut.encoding = texture.encoding;\n      lut.name = texture.name;\n      return lut;\n    }\n  }, {\n    key: \"createNeutral\",\n    value: function createNeutral(size) {\n      var data = new Float32Array(Math.pow(size, 3) * 3);\n      var s = 1 / (size - 1);\n\n      for (var r = 0; r < size; ++r) {\n        for (var g = 0; g < size; ++g) {\n          for (var b = 0; b < size; ++b) {\n            var i3 = (r + g * size + b * size * size) * 3;\n            data[i3 + 0] = r * s;\n            data[i3 + 1] = g * s;\n            data[i3 + 2] = b * s;\n          }\n        }\n      }\n\n      var lut = new LookupTexture3D(data, size);\n      lut.name = \"neutral\";\n      return lut;\n    }\n  }]);\n\n  return LookupTexture3D;\n}(DataTexture3D); // src/effects/glsl/lut/shader.frag\n\n\nvar shader_default59 = \"uniform vec3 scale;\\r\\nuniform vec3 offset;\\r\\n\\r\\n#ifdef CUSTOM_INPUT_DOMAIN\\r\\n\\r\\n\tuniform vec3 domainMin;\\r\\n\tuniform vec3 domainMax;\\r\\n\\r\\n#endif\\r\\n\\r\\n#ifdef LUT_3D\\r\\n\\r\\n\t#ifdef LUT_PRECISION_HIGH\\r\\n\\r\\n\t\t#ifdef GL_FRAGMENT_PRECISION_HIGH\\r\\n\\r\\n\t\t\tuniform highp sampler3D lut;\\r\\n\\r\\n\t\t#else\\r\\n\\r\\n\t\t\tuniform mediump sampler3D lut;\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tuniform lowp sampler3D lut;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tvec4 applyLUT(const in vec3 rgb) {\\r\\n\\r\\n\t\t#ifdef TETRAHEDRAL_INTERPOLATION\\r\\n\\r\\n\t\t\t/* Strategy: Fetch the four corners (v1, v2, v3, v4) of the tetrahedron\\r\\n\t\t\tthat corresponds to the input coordinates, calculate the barycentric\\r\\n\t\t\tweights and interpolate the nearest color samples. */\\r\\n\\r\\n\t\t\tvec3 p = floor(rgb);\\r\\n\t\t\tvec3 f = rgb - p;\\r\\n\\r\\n\t\t\tvec3 v1 = (p + 0.5) * LUT_TEXEL_WIDTH;\\r\\n\t\t\tvec3 v4 = (p + 1.5) * LUT_TEXEL_WIDTH;\\r\\n\t\t\tvec3 v2, v3; // Must be identified.\\r\\n\t\t\tvec3 frac;\\r\\n\\r\\n\t\t\tif(f.r >= f.g) {\\r\\n\\r\\n\t\t\t\tif(f.g > f.b) {\\r\\n\\r\\n\t\t\t\t\t// T4: R >= G > B\\r\\n\t\t\t\t\tfrac = f.rgb;\\r\\n\t\t\t\t\tv2 = vec3(v4.x, v1.y, v1.z);\\r\\n\t\t\t\t\tv3 = vec3(v4.x, v4.y, v1.z);\\r\\n\\r\\n\t\t\t\t} else if(f.r >= f.b) {\\r\\n\\r\\n\t\t\t\t\t// T6: R >= B >= G\\r\\n\t\t\t\t\tfrac = f.rbg;\\r\\n\t\t\t\t\tv2 = vec3(v4.x, v1.y, v1.z);\\r\\n\t\t\t\t\tv3 = vec3(v4.x, v1.y, v4.z);\\r\\n\\r\\n\t\t\t\t} else {\\r\\n\\r\\n\t\t\t\t\t// T2: B > R >= G\\r\\n\t\t\t\t\tfrac = f.brg;\\r\\n\t\t\t\t\tv2 = vec3(v1.x, v1.y, v4.z);\\r\\n\t\t\t\t\tv3 = vec3(v4.x, v1.y, v4.z);\\r\\n\\r\\n\t\t\t\t}\\r\\n\\r\\n\t\t\t} else {\\r\\n\\r\\n\t\t\t\tif(f.b > f.g) {\\r\\n\\r\\n\t\t\t\t\t// T3: B > G > R\\r\\n\t\t\t\t\tfrac = f.bgr;\\r\\n\t\t\t\t\tv2 = vec3(v1.x, v1.y, v4.z);\\r\\n\t\t\t\t\tv3 = vec3(v1.x, v4.y, v4.z);\\r\\n\\r\\n\t\t\t\t} else if(f.r >= f.b) {\\r\\n\\r\\n\t\t\t\t\t// T5: G > R >= B\\r\\n\t\t\t\t\tfrac = f.grb;\\r\\n\t\t\t\t\tv2 = vec3(v1.x, v4.y, v1.z);\\r\\n\t\t\t\t\tv3 = vec3(v4.x, v4.y, v1.z);\\r\\n\\r\\n\t\t\t\t} else {\\r\\n\\r\\n\t\t\t\t\t// T1: G >= B > R\\r\\n\t\t\t\t\tfrac = f.gbr;\\r\\n\t\t\t\t\tv2 = vec3(v1.x, v4.y, v1.z);\\r\\n\t\t\t\t\tv3 = vec3(v1.x, v4.y, v4.z);\\r\\n\\r\\n\t\t\t\t}\\r\\n\\r\\n\t\t\t}\\r\\n\\r\\n\t\t\t// Interpolate manually to avoid 8-bit quantization of fractions.\\r\\n\t\t\tvec4 n1 = texture(lut, v1);\\r\\n\t\t\tvec4 n2 = texture(lut, v2);\\r\\n\t\t\tvec4 n3 = texture(lut, v3);\\r\\n\t\t\tvec4 n4 = texture(lut, v4);\\r\\n\\r\\n\t\t\tvec4 weights = vec4(\\r\\n\t\t\t\t1.0 - frac.x,\\r\\n\t\t\t\tfrac.x - frac.y,\\r\\n\t\t\t\tfrac.y - frac.z,\\r\\n\t\t\t\tfrac.z\\r\\n\t\t\t);\\r\\n\\r\\n\t\t\t// weights.x * n1 + weights.y * n2 + weights.z * n3 + weights.w * n4\\r\\n\t\t\tvec4 result = weights * mat4(\\r\\n\t\t\t\tvec4(n1.r, n2.r, n3.r, n4.r),\\r\\n\t\t\t\tvec4(n1.g, n2.g, n3.g, n4.g),\\r\\n\t\t\t\tvec4(n1.b, n2.b, n3.b, n4.b),\\r\\n\t\t\t\tvec4(1.0)\\r\\n\t\t\t);\\r\\n\\r\\n\t\t\treturn vec4(result.rgb, 1.0);\\r\\n\\r\\n\t\t#else\\r\\n\\r\\n\t\t\t/* Built-in trilinear interpolation. Note that the fractional components\\r\\n\t\t\tare quantized to 8 bits on common hardware, which introduces significant\\r\\n\t\t\terror with small grid sizes. */\\r\\n\\r\\n\t\t\treturn texture(lut, rgb);\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t}\\r\\n\\r\\n#else\\r\\n\\r\\n\t#ifdef LUT_PRECISION_HIGH\\r\\n\\r\\n\t\t#ifdef GL_FRAGMENT_PRECISION_HIGH\\r\\n\\r\\n\t\t\tuniform highp sampler2D lut;\\r\\n\\r\\n\t\t#else\\r\\n\\r\\n\t\t\tuniform mediump sampler2D lut;\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tuniform lowp sampler2D lut;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tvec4 applyLUT(const in vec3 rgb) {\\r\\n\\r\\n\t\t// Get the slices on either side of the sample.\\r\\n\t\tfloat slice = rgb.b * LUT_SIZE;\\r\\n\t\tfloat slice0 = floor(slice);\\r\\n\t\tfloat interp = slice - slice0;\\r\\n\t\tfloat centeredInterp = interp - 0.5;\\r\\n\t\tfloat slice1 = slice0 + sign(centeredInterp);\\r\\n\\r\\n\t\t#ifdef LUT_STRIP_HORIZONTAL\\r\\n\\r\\n\t\t\t// Pull X in by half a texel in each direction to avoid slice bleeding.\\r\\n\t\t\tfloat xOffset = clamp(\\r\\n\t\t\t\trgb.r * LUT_TEXEL_HEIGHT,\\r\\n\t\t\t\tLUT_TEXEL_WIDTH * 0.5,\\r\\n\t\t\t\tLUT_TEXEL_HEIGHT - LUT_TEXEL_WIDTH * 0.5\\r\\n\t\t\t);\\r\\n\\r\\n\t\t\tvec2 uv0 = vec2(slice0 * LUT_TEXEL_HEIGHT + xOffset, rgb.g);\\r\\n\t\t\tvec2 uv1 = vec2(slice1 * LUT_TEXEL_HEIGHT + xOffset, rgb.g);\\r\\n\\r\\n\t\t#else\\r\\n\\r\\n\t\t\t// Pull Y in by half a texel in each direction to avoid slice bleeding.\\r\\n\t\t\tfloat yOffset = clamp(\\r\\n\t\t\t\trgb.g * LUT_TEXEL_WIDTH,\\r\\n\t\t\t\tLUT_TEXEL_HEIGHT * 0.5,\\r\\n\t\t\t\tLUT_TEXEL_WIDTH - LUT_TEXEL_HEIGHT * 0.5\\r\\n\t\t\t);\\r\\n\\r\\n\t\t\tvec2 uv0 = vec2(rgb.r, slice0 * LUT_TEXEL_WIDTH + yOffset);\\r\\n\t\t\tvec2 uv1 = vec2(rgb.r, slice1 * LUT_TEXEL_WIDTH + yOffset);\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t\t// Manual trilinear interpolation (subject to quantization errors).\\r\\n\t\tvec4 sample0 = texture2D(lut, uv0);\\r\\n\t\tvec4 sample1 = texture2D(lut, uv1);\\r\\n\\r\\n\t\treturn mix(sample0, sample1, abs(centeredInterp));\\r\\n\\r\\n\t}\\r\\n\\r\\n#endif\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\tvec3 c = linearToInputTexel(inputColor).rgb;\\r\\n\\r\\n\t#ifdef CUSTOM_INPUT_DOMAIN\\r\\n\\r\\n\t\tif(c.r >= domainMin.r && c.g >= domainMin.g && c.b >= domainMin.b &&\\r\\n\t\t\tc.r <= domainMax.r && c.g <= domainMax.g && c.b <= domainMax.b) {\\r\\n\\r\\n\t\t\tc = texelToLinear(applyLUT(scale * c + offset)).rgb;\\r\\n\\r\\n\t\t} else {\\r\\n\\r\\n\t\t\tc = inputColor.rgb;\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\t#if !defined(LUT_3D) || defined(TETRAHEDRAL_INTERPOLATION)\\r\\n\\r\\n\t\t\tc = clamp(c, 0.0, 1.0);\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t\tc = texelToLinear(applyLUT(scale * c + offset)).rgb;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\toutputColor = vec4(c, inputColor.a);\\r\\n\\r\\n}\\r\\n\"; // src/effects/LUTEffect.js\n\nvar LUTEffect = /*#__PURE__*/function (_Effect15) {\n  _inherits(LUTEffect, _Effect15);\n\n  var _super51 = _createSuper(LUTEffect);\n\n  function LUTEffect(lut) {\n    var _this48;\n\n    var _ref22 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref22$blendFunction = _ref22.blendFunction,\n        blendFunction = _ref22$blendFunction === void 0 ? BlendFunction.NORMAL : _ref22$blendFunction,\n        _ref22$tetrahedralInt = _ref22.tetrahedralInterpolation,\n        tetrahedralInterpolation = _ref22$tetrahedralInt === void 0 ? false : _ref22$tetrahedralInt;\n\n    _classCallCheck(this, LUTEffect);\n\n    _this48 = _super51.call(this, \"LUTEffect\", shader_default59, {\n      blendFunction: blendFunction,\n      uniforms: new Map([[\"lut\", new Uniform31(null)], [\"scale\", new Uniform31(new Vector34())], [\"offset\", new Uniform31(new Vector34())], [\"domainMin\", new Uniform31(null)], [\"domainMax\", new Uniform31(null)]])\n    });\n    _this48.tetrahedralInterpolation = tetrahedralInterpolation;\n    _this48.inputEncoding = sRGBEncoding2;\n    _this48.outputEncoding = _this48.inputEncoding;\n\n    _this48.setInputEncoding(sRGBEncoding2);\n\n    _this48.setLUT(lut);\n\n    return _this48;\n  }\n\n  _createClass(LUTEffect, [{\n    key: \"getOutputEncoding\",\n    value: function getOutputEncoding() {\n      return this.outputEncoding;\n    }\n  }, {\n    key: \"getInputEncoding\",\n    value: function getInputEncoding() {\n      return this.inputEncoding;\n    }\n  }, {\n    key: \"setInputEncoding\",\n    value: function setInputEncoding(value) {\n      var defines = this.defines;\n      var lut = this.getLUT();\n\n      switch (value) {\n        case sRGBEncoding2:\n          defines.set(\"linearToInputTexel(texel)\", \"LinearTosRGB(texel)\");\n          break;\n\n        case LinearEncoding2:\n          defines.set(\"linearToInputTexel(texel)\", \"texel\");\n          break;\n\n        default:\n          console.error(\"Unsupported input encoding:\", value);\n          break;\n      }\n\n      if (lut !== null) {\n        this.outputEncoding = lut.encoding === LinearEncoding2 ? value : lut.encoding;\n\n        switch (this.outputEncoding) {\n          case sRGBEncoding2:\n            defines.set(\"texelToLinear(texel)\", \"sRGBToLinear(texel)\");\n            break;\n\n          case LinearEncoding2:\n            defines.set(\"texelToLinear(texel)\", \"texel\");\n            break;\n\n          default:\n            console.error(\"Unsupported LUT encoding:\", lut.encoding);\n            break;\n        }\n      }\n\n      if (this.inputEncoding !== value) {\n        this.inputEncoding = value;\n        this.setChanged();\n      }\n    }\n  }, {\n    key: \"getLUT\",\n    value: function getLUT() {\n      return this.uniforms.get(\"lut\").value;\n    }\n  }, {\n    key: \"setLUT\",\n    value: function setLUT(lut) {\n      var defines = this.defines;\n      var uniforms = this.uniforms;\n\n      if (this.getLUT() !== lut) {\n        var image = lut.image;\n        defines.clear();\n        defines.set(\"LUT_SIZE\", Math.min(image.width, image.height).toFixed(16));\n        defines.set(\"LUT_TEXEL_WIDTH\", (1 / image.width).toFixed(16));\n        defines.set(\"LUT_TEXEL_HEIGHT\", (1 / image.height).toFixed(16));\n        uniforms.get(\"lut\").value = lut;\n        uniforms.get(\"domainMin\").value = null;\n        uniforms.get(\"domainMax\").value = null;\n\n        if (lut.type === FloatType3 || lut.type === HalfFloatType2) {\n          defines.set(\"LUT_PRECISION_HIGH\", \"1\");\n        }\n\n        if (image.width > image.height) {\n          defines.set(\"LUT_STRIP_HORIZONTAL\", \"1\");\n        } else if (lut instanceof DataTexture3D2) {\n          defines.set(\"LUT_3D\", \"1\");\n        }\n\n        if (lut instanceof LookupTexture3D) {\n          var min = lut.domainMin;\n          var max = lut.domainMax;\n\n          if (min.x !== 0 || min.y !== 0 || min.z !== 0 || max.x !== 1 || max.y !== 1 || max.z !== 1) {\n            defines.set(\"CUSTOM_INPUT_DOMAIN\", \"1\");\n            uniforms.get(\"domainMin\").value = min.clone();\n            uniforms.get(\"domainMax\").value = max.clone();\n          }\n        }\n\n        this.configureTetrahedralInterpolation();\n        this.updateScaleOffset();\n        this.setInputEncoding(this.inputEncoding);\n        this.setChanged();\n      }\n    }\n  }, {\n    key: \"updateScaleOffset\",\n    value: function updateScaleOffset() {\n      var lut = this.getLUT();\n      var size = Math.min(lut.image.width, lut.image.height);\n      var scale = this.uniforms.get(\"scale\").value;\n      var offset = this.uniforms.get(\"offset\").value;\n\n      if (this.defines.has(\"TETRAHEDRAL_INTERPOLATION\")) {\n        if (this.defines.has(\"CUSTOM_INPUT_DOMAIN\")) {\n          var domainScale = lut.domainMax.clone().sub(lut.domainMin);\n          scale.setScalar(size - 1).divide(domainScale);\n          offset.copy(lut.domainMin).negate().multiply(scale);\n        } else {\n          scale.setScalar(size - 1);\n          offset.setScalar(0);\n        }\n      } else {\n        if (this.defines.has(\"CUSTOM_INPUT_DOMAIN\")) {\n          var _domainScale = lut.domainMax.clone().sub(lut.domainMin).multiplyScalar(size);\n\n          scale.setScalar(size - 1).divide(_domainScale);\n          offset.copy(lut.domainMin).negate().multiply(scale).addScalar(1 / (2 * size));\n        } else {\n          scale.setScalar((size - 1) / size);\n          offset.setScalar(1 / (2 * size));\n        }\n      }\n    }\n  }, {\n    key: \"configureTetrahedralInterpolation\",\n    value: function configureTetrahedralInterpolation() {\n      var lut = this.getLUT();\n      lut.minFilter = LinearFilter9;\n      lut.magFilter = LinearFilter9;\n      this.defines.delete(\"TETRAHEDRAL_INTERPOLATION\");\n\n      if (this.tetrahedralInterpolation && lut !== null) {\n        if (lut instanceof DataTexture3D2) {\n          this.defines.set(\"TETRAHEDRAL_INTERPOLATION\", \"1\");\n          lut.minFilter = NearestFilter6;\n          lut.magFilter = NearestFilter6;\n        } else {\n          console.warn(\"Tetrahedral interpolation requires a 3D texture\");\n        }\n      }\n\n      lut.needsUpdate = true;\n    }\n  }, {\n    key: \"setTetrahedralInterpolationEnabled\",\n    value: function setTetrahedralInterpolationEnabled(enabled) {\n      this.tetrahedralInterpolation = enabled;\n      this.configureTetrahedralInterpolation();\n      this.updateScaleOffset();\n      this.setChanged();\n    }\n  }]);\n\n  return LUTEffect;\n}(Effect); // src/effects/glsl/noise/shader.frag\n\n\nvar shader_default60 = \"void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\tvec3 noise = vec3(rand(uv * time));\\r\\n\\r\\n\t#ifdef PREMULTIPLY\\r\\n\\r\\n\t\toutputColor = vec4(min(inputColor.rgb * noise, vec3(1.0)), inputColor.a);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\toutputColor = vec4(noise, inputColor.a);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n}\\r\\n\"; // src/effects/NoiseEffect.js\n\nvar NoiseEffect = /*#__PURE__*/function (_Effect16) {\n  _inherits(NoiseEffect, _Effect16);\n\n  var _super52 = _createSuper(NoiseEffect);\n\n  function NoiseEffect() {\n    var _this49;\n\n    var _ref23 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref23$blendFunction = _ref23.blendFunction,\n        blendFunction = _ref23$blendFunction === void 0 ? BlendFunction.SCREEN : _ref23$blendFunction,\n        _ref23$premultiply = _ref23.premultiply,\n        premultiply = _ref23$premultiply === void 0 ? false : _ref23$premultiply;\n\n    _classCallCheck(this, NoiseEffect);\n\n    _this49 = _super52.call(this, \"NoiseEffect\", shader_default60, {\n      blendFunction: blendFunction\n    });\n    _this49.premultiply = premultiply;\n    return _this49;\n  }\n\n  _createClass(NoiseEffect, [{\n    key: \"premultiply\",\n    get: function get() {\n      return this.defines.has(\"PREMULTIPLY\");\n    },\n    set: function set(value) {\n      if (this.premultiply !== value) {\n        if (value) {\n          this.defines.set(\"PREMULTIPLY\", \"1\");\n        } else {\n          this.defines.delete(\"PREMULTIPLY\");\n        }\n\n        this.setChanged();\n      }\n    }\n  }]);\n\n  return NoiseEffect;\n}(Effect); // src/effects/OutlineEffect.js\n\n\nimport { Color as Color6, LinearFilter as LinearFilter10, RepeatWrapping as RepeatWrapping2, RGBFormat as RGBFormat11, Uniform as Uniform32, UnsignedByteType as UnsignedByteType9, WebGLRenderTarget as WebGLRenderTarget12 } from \"three\"; // src/effects/glsl/outline/shader.frag\n\nvar shader_default61 = \"uniform sampler2D edgeTexture;\\r\\nuniform sampler2D maskTexture;\\r\\n\\r\\nuniform vec3 visibleEdgeColor;\\r\\nuniform vec3 hiddenEdgeColor;\\r\\nuniform float pulse;\\r\\nuniform float edgeStrength;\\r\\n\\r\\n#ifdef USE_PATTERN\\r\\n\\r\\n\tuniform sampler2D patternTexture;\\r\\n\tvarying vec2 vUvPattern;\\r\\n\\r\\n#endif\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\tvec2 edge = texture2D(edgeTexture, uv).rg;\\r\\n\tvec2 mask = texture2D(maskTexture, uv).rg;\\r\\n\\r\\n\t#ifndef X_RAY\\r\\n\\r\\n\t\tedge.y = 0.0;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tedge *= (edgeStrength * mask.x * pulse);\\r\\n\tvec3 color = edge.x * visibleEdgeColor + edge.y * hiddenEdgeColor;\\r\\n\\r\\n\tfloat visibilityFactor = 0.0;\\r\\n\\r\\n\t#ifdef USE_PATTERN\\r\\n\\r\\n\t\tvec4 patternColor = texture2D(patternTexture, vUvPattern);\\r\\n\\r\\n\t\t#ifdef X_RAY\\r\\n\\r\\n\t\t\tfloat hiddenFactor = 0.5;\\r\\n\\r\\n\t\t#else\\r\\n\\r\\n\t\t\tfloat hiddenFactor = 0.0;\\r\\n\\r\\n\t\t#endif\\r\\n\\r\\n\t\tvisibilityFactor = (1.0 - mask.y > 0.0) ? 1.0 : hiddenFactor;\\r\\n\t\tvisibilityFactor *= (1.0 - mask.x) * patternColor.a;\\r\\n\t\tcolor += visibilityFactor * patternColor.rgb;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tfloat alpha = max(max(edge.x, edge.y), visibilityFactor);\\r\\n\\r\\n\t#ifdef ALPHA\\r\\n\\r\\n\t\t// Alpha blending already accounts for input alpha.\\r\\n\t\toutputColor = vec4(color, alpha);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\t// Preserve input alpha.\\r\\n\t\toutputColor = vec4(color, max(alpha, inputColor.a));\\r\\n\\r\\n\t#endif\\r\\n\\r\\n}\\r\\n\"; // src/effects/glsl/outline/shader.vert\n\nvar shader_default62 = \"uniform float patternScale;\\r\\n\\r\\nvarying vec2 vUvPattern;\\r\\n\\r\\nvoid mainSupport(const in vec2 uv) {\\r\\n\\r\\n\tvUvPattern = uv * vec2(aspect, 1.0) * patternScale;\\r\\n\\r\\n}\\r\\n\"; // src/effects/OutlineEffect.js\n\nvar OutlineEffect = /*#__PURE__*/function (_Effect17) {\n  _inherits(OutlineEffect, _Effect17);\n\n  var _super53 = _createSuper(OutlineEffect);\n\n  function OutlineEffect(scene, camera) {\n    var _this50;\n\n    var _ref24 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref24$blendFunction = _ref24.blendFunction,\n        blendFunction = _ref24$blendFunction === void 0 ? BlendFunction.SCREEN : _ref24$blendFunction,\n        _ref24$patternTexture = _ref24.patternTexture,\n        patternTexture = _ref24$patternTexture === void 0 ? null : _ref24$patternTexture,\n        _ref24$edgeStrength = _ref24.edgeStrength,\n        edgeStrength = _ref24$edgeStrength === void 0 ? 1 : _ref24$edgeStrength,\n        _ref24$pulseSpeed = _ref24.pulseSpeed,\n        pulseSpeed = _ref24$pulseSpeed === void 0 ? 0 : _ref24$pulseSpeed,\n        _ref24$visibleEdgeCol = _ref24.visibleEdgeColor,\n        visibleEdgeColor = _ref24$visibleEdgeCol === void 0 ? 16777215 : _ref24$visibleEdgeCol,\n        _ref24$hiddenEdgeColo = _ref24.hiddenEdgeColor,\n        hiddenEdgeColor = _ref24$hiddenEdgeColo === void 0 ? 2230538 : _ref24$hiddenEdgeColo,\n        _ref24$resolutionScal = _ref24.resolutionScale,\n        resolutionScale = _ref24$resolutionScal === void 0 ? 0.5 : _ref24$resolutionScal,\n        _ref24$width = _ref24.width,\n        width = _ref24$width === void 0 ? Resizer.AUTO_SIZE : _ref24$width,\n        _ref24$height = _ref24.height,\n        height = _ref24$height === void 0 ? Resizer.AUTO_SIZE : _ref24$height,\n        _ref24$kernelSize = _ref24.kernelSize,\n        kernelSize = _ref24$kernelSize === void 0 ? KernelSize.VERY_SMALL : _ref24$kernelSize,\n        _ref24$blur = _ref24.blur,\n        blur = _ref24$blur === void 0 ? false : _ref24$blur,\n        _ref24$xRay = _ref24.xRay,\n        xRay = _ref24$xRay === void 0 ? true : _ref24$xRay;\n\n    _classCallCheck(this, OutlineEffect);\n\n    _this50 = _super53.call(this, \"OutlineEffect\", shader_default61, {\n      uniforms: new Map([[\"maskTexture\", new Uniform32(null)], [\"edgeTexture\", new Uniform32(null)], [\"edgeStrength\", new Uniform32(edgeStrength)], [\"visibleEdgeColor\", new Uniform32(new Color6(visibleEdgeColor))], [\"hiddenEdgeColor\", new Uniform32(new Color6(hiddenEdgeColor))], [\"pulse\", new Uniform32(1)], [\"patternScale\", new Uniform32(1)], [\"patternTexture\", new Uniform32(null)]])\n    });\n\n    _this50.blendMode.addEventListener(\"change\", function (event) {\n      if (_this50.blendMode.getBlendFunction() === BlendFunction.ALPHA) {\n        _this50.defines.set(\"ALPHA\", \"1\");\n      } else {\n        _this50.defines.delete(\"ALPHA\");\n      }\n\n      _this50.setChanged();\n    });\n\n    _this50.blendMode.setBlendFunction(blendFunction);\n\n    _this50.setPatternTexture(patternTexture);\n\n    _this50.xRay = xRay;\n    _this50.scene = scene;\n    _this50.camera = camera;\n    _this50.renderTargetMask = new WebGLRenderTarget12(1, 1, {\n      minFilter: LinearFilter10,\n      magFilter: LinearFilter10,\n      stencilBuffer: false,\n      format: RGBFormat11\n    });\n    _this50.renderTargetMask.texture.name = \"Outline.Mask\";\n    _this50.uniforms.get(\"maskTexture\").value = _this50.renderTargetMask.texture;\n    _this50.renderTargetOutline = _this50.renderTargetMask.clone();\n    _this50.renderTargetOutline.texture.name = \"Outline.Edges\";\n    _this50.renderTargetOutline.depthBuffer = false;\n    _this50.renderTargetBlurredOutline = _this50.renderTargetOutline.clone();\n    _this50.renderTargetBlurredOutline.texture.name = \"Outline.BlurredEdges\";\n    _this50.clearPass = new ClearPass();\n    _this50.clearPass.overrideClearColor = new Color6(0);\n    _this50.clearPass.overrideClearAlpha = 1;\n    _this50.depthPass = new DepthPass(scene, camera);\n    _this50.maskPass = new RenderPass(scene, camera, new DepthComparisonMaterial(_this50.depthPass.texture, camera));\n\n    var clearPass = _this50.maskPass.getClearPass();\n\n    clearPass.overrideClearColor = new Color6(16777215);\n    clearPass.overrideClearAlpha = 1;\n    _this50.blurPass = new BlurPass({\n      resolutionScale: resolutionScale,\n      width: width,\n      height: height,\n      kernelSize: kernelSize\n    });\n    _this50.blurPass.resolution.resizable = _assertThisInitialized(_this50);\n    _this50.blur = blur;\n    _this50.outlinePass = new ShaderPass(new OutlineMaterial());\n    _this50.outlinePass.getFullscreenMaterial().uniforms.inputBuffer.value = _this50.renderTargetMask.texture;\n    _this50.time = 0;\n    _this50.selection = new Selection();\n    _this50.pulseSpeed = pulseSpeed;\n    return _this50;\n  }\n\n  _createClass(OutlineEffect, [{\n    key: \"resolution\",\n    get: function get() {\n      return this.blurPass.resolution;\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.resolution.width;\n    },\n    set: function set(value) {\n      this.resolution.width = value;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.resolution.height;\n    },\n    set: function set(value) {\n      this.resolution.height = value;\n    }\n  }, {\n    key: \"selectionLayer\",\n    get: function get() {\n      return this.selection.layer;\n    },\n    set: function set(value) {\n      this.selection.layer = value;\n    }\n  }, {\n    key: \"dithering\",\n    get: function get() {\n      return this.blurPass.dithering;\n    },\n    set: function set(value) {\n      this.blurPass.dithering = value;\n    }\n  }, {\n    key: \"kernelSize\",\n    get: function get() {\n      return this.blurPass.kernelSize;\n    },\n    set: function set(value) {\n      this.blurPass.kernelSize = value;\n    }\n  }, {\n    key: \"blur\",\n    get: function get() {\n      return this.blurPass.enabled;\n    },\n    set: function set(value) {\n      this.blurPass.enabled = value;\n      this.uniforms.get(\"edgeTexture\").value = value ? this.renderTargetBlurredOutline.texture : this.renderTargetOutline.texture;\n    }\n  }, {\n    key: \"xRay\",\n    get: function get() {\n      return this.defines.has(\"X_RAY\");\n    },\n    set: function set(value) {\n      if (this.xRay !== value) {\n        if (value) {\n          this.defines.set(\"X_RAY\", \"1\");\n        } else {\n          this.defines.delete(\"X_RAY\");\n        }\n\n        this.setChanged();\n      }\n    }\n  }, {\n    key: \"setPatternTexture\",\n    value: function setPatternTexture(texture) {\n      if (texture !== null) {\n        texture.wrapS = texture.wrapT = RepeatWrapping2;\n        this.defines.set(\"USE_PATTERN\", \"1\");\n        this.uniforms.get(\"patternTexture\").value = texture;\n        this.setVertexShader(shader_default62);\n      } else {\n        this.defines.delete(\"USE_PATTERN\");\n        this.uniforms.get(\"patternTexture\").value = null;\n        this.setVertexShader(null);\n      }\n\n      this.setChanged();\n    }\n  }, {\n    key: \"getResolutionScale\",\n    value: function getResolutionScale() {\n      return this.resolution.scale;\n    }\n  }, {\n    key: \"setResolutionScale\",\n    value: function setResolutionScale(scale) {\n      this.resolution.scale = scale;\n    }\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(objects) {\n      this.selection.set(objects);\n      return this;\n    }\n  }, {\n    key: \"clearSelection\",\n    value: function clearSelection() {\n      this.selection.clear();\n      return this;\n    }\n  }, {\n    key: \"selectObject\",\n    value: function selectObject(object) {\n      this.selection.add(object);\n      return this;\n    }\n  }, {\n    key: \"deselectObject\",\n    value: function deselectObject(object) {\n      this.selection.delete(object);\n      return this;\n    }\n  }, {\n    key: \"update\",\n    value: function update(renderer, inputBuffer, deltaTime) {\n      var scene = this.scene;\n      var camera = this.camera;\n      var selection = this.selection;\n      var pulse = this.uniforms.get(\"pulse\");\n      var background = scene.background;\n      var mask = camera.layers.mask;\n\n      if (selection.size > 0) {\n        scene.background = null;\n        pulse.value = 1;\n\n        if (this.pulseSpeed > 0) {\n          pulse.value = 0.625 + Math.cos(this.time * this.pulseSpeed * 10) * 0.375;\n        }\n\n        this.time += deltaTime;\n        selection.setVisible(false);\n        this.depthPass.render(renderer);\n        selection.setVisible(true);\n        camera.layers.set(selection.layer);\n        this.maskPass.render(renderer, this.renderTargetMask);\n        camera.layers.mask = mask;\n        scene.background = background;\n        this.outlinePass.render(renderer, null, this.renderTargetOutline);\n\n        if (this.blur) {\n          this.blurPass.render(renderer, this.renderTargetOutline, this.renderTargetBlurredOutline);\n        }\n      } else if (this.time > 0) {\n        this.clearPass.render(renderer, this.renderTargetMask);\n        this.time = 0;\n      }\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      this.blurPass.setSize(width, height);\n      this.renderTargetMask.setSize(width, height);\n      var w = this.resolution.width;\n      var h = this.resolution.height;\n      this.depthPass.setSize(w, h);\n      this.renderTargetOutline.setSize(w, h);\n      this.renderTargetBlurredOutline.setSize(w, h);\n      this.outlinePass.getFullscreenMaterial().setTexelSize(1 / w, 1 / h);\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize(renderer, alpha, frameBufferType) {\n      this.blurPass.initialize(renderer, alpha, UnsignedByteType9);\n\n      if (frameBufferType !== void 0) {\n        this.depthPass.initialize(renderer, alpha, frameBufferType);\n        this.maskPass.initialize(renderer, alpha, frameBufferType);\n        this.outlinePass.initialize(renderer, alpha, frameBufferType);\n      }\n    }\n  }]);\n\n  return OutlineEffect;\n}(Effect); // src/effects/PixelationEffect.js\n\n\nimport { Uniform as Uniform33, Vector2 as Vector218 } from \"three\"; // src/effects/glsl/pixelation/shader.frag\n\nvar shader_default63 = \"uniform bool active;\\r\\nuniform vec2 d;\\r\\n\\r\\nvoid mainUv(inout vec2 uv) {\\r\\n\\r\\n\tif(active) {\\r\\n\\r\\n\t\tuv = vec2(\\r\\n\t\t\td.x * (floor(uv.x / d.x) + 0.5),\\r\\n\t\t\td.y * (floor(uv.y / d.y) + 0.5)\\r\\n\t\t);\\r\\n\\r\\n\t}\\r\\n\\r\\n}\\r\\n\"; // src/effects/PixelationEffect.js\n\nvar PixelationEffect = /*#__PURE__*/function (_Effect18) {\n  _inherits(PixelationEffect, _Effect18);\n\n  var _super54 = _createSuper(PixelationEffect);\n\n  function PixelationEffect() {\n    var _this51;\n\n    var granularity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30;\n\n    _classCallCheck(this, PixelationEffect);\n\n    _this51 = _super54.call(this, \"PixelationEffect\", shader_default63, {\n      uniforms: new Map([[\"active\", new Uniform33(false)], [\"d\", new Uniform33(new Vector218())]])\n    });\n    _this51.resolution = new Vector218();\n    _this51.granularity = granularity;\n    return _this51;\n  }\n\n  _createClass(PixelationEffect, [{\n    key: \"getGranularity\",\n    value: function getGranularity() {\n      return this.granularity;\n    }\n  }, {\n    key: \"setGranularity\",\n    value: function setGranularity(granularity) {\n      granularity = Math.floor(granularity);\n\n      if (granularity % 2 > 0) {\n        granularity += 1;\n      }\n\n      var uniforms = this.uniforms;\n      uniforms.get(\"active\").value = granularity > 0;\n      uniforms.get(\"d\").value.set(granularity, granularity).divide(this.resolution);\n      this.granularity = granularity;\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      this.resolution.set(width, height);\n      this.setGranularity(this.granularity);\n    }\n  }]);\n\n  return PixelationEffect;\n}(Effect); // src/effects/RealisticBokehEffect.js\n\n\nimport { Uniform as Uniform34, Vector4 as Vector42 } from \"three\"; // src/effects/glsl/realistic-bokeh/shader.frag\n\nvar shader_default64 = \"uniform float focus;\\r\\nuniform float focalLength;\\r\\nuniform float fStop;\\r\\nuniform float maxBlur;\\r\\nuniform float luminanceThreshold;\\r\\nuniform float luminanceGain;\\r\\nuniform float bias;\\r\\nuniform float fringe;\\r\\n\\r\\n#ifdef MANUAL_DOF\\r\\n\\r\\n\tuniform vec4 dof;\\r\\n\\r\\n#endif\\r\\n\\r\\n#ifdef PENTAGON\\r\\n\\r\\n\tfloat pentagon(const in vec2 coords) {\\r\\n\\r\\n\t\tconst vec4 HS0 = vec4( 1.0,          0.0,         0.0, 1.0);\\r\\n\t\tconst vec4 HS1 = vec4( 0.309016994,  0.951056516, 0.0, 1.0);\\r\\n\t\tconst vec4 HS2 = vec4(-0.809016994,  0.587785252, 0.0, 1.0);\\r\\n\t\tconst vec4 HS3 = vec4(-0.809016994, -0.587785252, 0.0, 1.0);\\r\\n\t\tconst vec4 HS4 = vec4( 0.309016994, -0.951056516, 0.0, 1.0);\\r\\n\t\tconst vec4 HS5 = vec4( 0.0,          0.0,         1.0, 1.0);\\r\\n\\r\\n\t\tconst vec4 ONE = vec4(1.0);\\r\\n\\r\\n\t\tconst float P_FEATHER = 0.4;\\r\\n\t\tconst float N_FEATHER = -P_FEATHER;\\r\\n\\r\\n\t\tfloat inOrOut = -4.0;\\r\\n\\r\\n\t\tvec4 P = vec4(coords, vec2(RINGS_FLOAT - 1.3));\\r\\n\\r\\n\t\tvec4 dist = vec4(\\r\\n\t\t\tdot(P, HS0),\\r\\n\t\t\tdot(P, HS1),\\r\\n\t\t\tdot(P, HS2),\\r\\n\t\t\tdot(P, HS3)\\r\\n\t\t);\\r\\n\\r\\n\t\tdist = smoothstep(N_FEATHER, P_FEATHER, dist);\\r\\n\\r\\n\t\tinOrOut += dot(dist, ONE);\\r\\n\\r\\n\t\tdist.x = dot(P, HS4);\\r\\n\t\tdist.y = HS5.w - abs(P.z);\\r\\n\\r\\n\t\tdist = smoothstep(N_FEATHER, P_FEATHER, dist);\\r\\n\t\tinOrOut += dist.x;\\r\\n\\r\\n\t\treturn clamp(inOrOut, 0.0, 1.0);\\r\\n\\r\\n\t}\\r\\n\\r\\n#endif\\r\\n\\r\\nvec3 processTexel(const in vec2 coords, const in float blur) {\\r\\n\\r\\n\tvec2 scale = texelSize * fringe * blur;\\r\\n\\r\\n\tvec3 c = vec3(\\r\\n\t\ttexture2D(inputBuffer, coords + vec2(0.0, 1.0) * scale).r,\\r\\n\t\ttexture2D(inputBuffer, coords + vec2(-0.866, -0.5) * scale).g,\\r\\n\t\ttexture2D(inputBuffer, coords + vec2(0.866, -0.5) * scale).b\\r\\n\t);\\r\\n\\r\\n\t// Calculate the luminance of the constructed color.\\r\\n\tfloat luminance = linearToRelativeLuminance(c);\\r\\n\tfloat threshold = max((luminance - luminanceThreshold) * luminanceGain, 0.0);\\r\\n\\r\\n\treturn c + mix(vec3(0.0), c, threshold * blur);\\r\\n\\r\\n}\\r\\n\\r\\nfloat gather(const in float i, const in float j, const in float ringSamples,\\r\\n\tconst in vec2 uv, const in vec2 blurFactor, const in float blur, inout vec3 color) {\\r\\n\\r\\n\tfloat step = PI2 / ringSamples;\\r\\n\tvec2 wh = vec2(cos(j * step) * i, sin(j * step) * i);\\r\\n\\r\\n\t#ifdef PENTAGON\\r\\n\\r\\n\t\tfloat p = pentagon(wh);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tfloat p = 1.0;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tcolor += processTexel(wh * blurFactor + uv, blur) * mix(1.0, i / RINGS_FLOAT, bias) * p;\\r\\n\\r\\n\treturn mix(1.0, i / RINGS_FLOAT, bias) * p;\\r\\n\\r\\n}\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, const in float depth, out vec4 outputColor) {\\r\\n\\r\\n\t#ifdef PERSPECTIVE_CAMERA\\r\\n\\r\\n\t\tfloat viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\\r\\n\t\tfloat linearDepth = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tfloat linearDepth = depth;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\t#ifdef MANUAL_DOF\\r\\n\\r\\n\t\tfloat focalPlane = linearDepth - focus;\\r\\n\t\tfloat farDoF = (focalPlane - dof.z) / dof.w;\\r\\n\t\tfloat nearDoF = (-focalPlane - dof.x) / dof.y;\\r\\n\\r\\n\t\tfloat blur = (focalPlane > 0.0) ? farDoF : nearDoF;\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tconst float CIRCLE_OF_CONFUSION = 0.03; // 35mm film = 0.03mm CoC.\\r\\n\\r\\n\t\tfloat focalPlaneMM = focus * 1000.0;\\r\\n\t\tfloat depthMM = linearDepth * 1000.0;\\r\\n\\r\\n\t\tfloat focalPlane = (depthMM * focalLength) / (depthMM - focalLength);\\r\\n\t\tfloat farDoF = (focalPlaneMM * focalLength) / (focalPlaneMM - focalLength);\\r\\n\t\tfloat nearDoF = (focalPlaneMM - focalLength) / (focalPlaneMM * fStop * CIRCLE_OF_CONFUSION);\\r\\n\\r\\n\t\tfloat blur = abs(focalPlane - farDoF) * nearDoF;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tconst int MAX_RING_SAMPLES = RINGS_INT * SAMPLES_INT;\\r\\n\\r\\n\tblur = clamp(blur, 0.0, 1.0);\\r\\n\tvec3 color = inputColor.rgb;\\r\\n\\r\\n\tif(blur >= 0.05) {\\r\\n\\r\\n\t\tvec2 blurFactor = blur * maxBlur * texelSize;\\r\\n\\r\\n\t\tfloat s = 1.0;\\r\\n\t\tint ringSamples;\\r\\n\\r\\n\t\tfor(int i = 1; i <= RINGS_INT; i++) {\\r\\n\\r\\n\t\t\tringSamples = i * SAMPLES_INT;\\r\\n\\r\\n\t\t\tfor(int j = 0; j < MAX_RING_SAMPLES; j++) {\\r\\n\\r\\n\t\t\t\tif(j >= ringSamples) {\\r\\n\\r\\n\t\t\t\t\tbreak;\\r\\n\\r\\n\t\t\t\t}\\r\\n\\r\\n\t\t\t\ts += gather(float(i), float(j), float(ringSamples), uv, blurFactor, blur, color);\\r\\n\\r\\n\t\t\t}\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t\tcolor /= s;\\r\\n\\r\\n\t}\\r\\n\\r\\n\t#ifdef SHOW_FOCUS\\r\\n\\r\\n\t\tfloat edge = 0.002 * linearDepth;\\r\\n\t\tfloat m = clamp(smoothstep(0.0, edge, blur), 0.0, 1.0);\\r\\n\t\tfloat e = clamp(smoothstep(1.0 - edge, 1.0, blur), 0.0, 1.0);\\r\\n\\r\\n\t\tcolor = mix(color, vec3(1.0, 0.5, 0.0), (1.0 - m) * 0.6);\\r\\n\t\tcolor = mix(color, vec3(0.0, 0.5, 1.0), ((1.0 - e) - (1.0 - m)) * 0.2);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\toutputColor = vec4(color, inputColor.a);\\r\\n\\r\\n}\\r\\n\"; // src/effects/RealisticBokehEffect.js\n\nvar RealisticBokehEffect = /*#__PURE__*/function (_Effect19) {\n  _inherits(RealisticBokehEffect, _Effect19);\n\n  var _super55 = _createSuper(RealisticBokehEffect);\n\n  function RealisticBokehEffect() {\n    var _this52;\n\n    var _ref25 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref25$blendFunction = _ref25.blendFunction,\n        blendFunction = _ref25$blendFunction === void 0 ? BlendFunction.NORMAL : _ref25$blendFunction,\n        _ref25$focus = _ref25.focus,\n        focus = _ref25$focus === void 0 ? 1 : _ref25$focus,\n        _ref25$focalLength = _ref25.focalLength,\n        focalLength = _ref25$focalLength === void 0 ? 24 : _ref25$focalLength,\n        _ref25$fStop = _ref25.fStop,\n        fStop = _ref25$fStop === void 0 ? 0.9 : _ref25$fStop,\n        _ref25$luminanceThres = _ref25.luminanceThreshold,\n        luminanceThreshold = _ref25$luminanceThres === void 0 ? 0.5 : _ref25$luminanceThres,\n        _ref25$luminanceGain = _ref25.luminanceGain,\n        luminanceGain = _ref25$luminanceGain === void 0 ? 2 : _ref25$luminanceGain,\n        _ref25$bias = _ref25.bias,\n        bias = _ref25$bias === void 0 ? 0.5 : _ref25$bias,\n        _ref25$fringe = _ref25.fringe,\n        fringe = _ref25$fringe === void 0 ? 0.7 : _ref25$fringe,\n        _ref25$maxBlur = _ref25.maxBlur,\n        maxBlur = _ref25$maxBlur === void 0 ? 1 : _ref25$maxBlur,\n        _ref25$rings = _ref25.rings,\n        rings = _ref25$rings === void 0 ? 3 : _ref25$rings,\n        _ref25$samples = _ref25.samples,\n        samples = _ref25$samples === void 0 ? 2 : _ref25$samples,\n        _ref25$showFocus = _ref25.showFocus,\n        showFocus = _ref25$showFocus === void 0 ? false : _ref25$showFocus,\n        _ref25$manualDoF = _ref25.manualDoF,\n        manualDoF = _ref25$manualDoF === void 0 ? false : _ref25$manualDoF,\n        _ref25$pentagon = _ref25.pentagon,\n        pentagon = _ref25$pentagon === void 0 ? false : _ref25$pentagon;\n\n    _classCallCheck(this, RealisticBokehEffect);\n\n    _this52 = _super55.call(this, \"RealisticBokehEffect\", shader_default64, {\n      blendFunction: blendFunction,\n      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,\n      uniforms: new Map([[\"focus\", new Uniform34(focus)], [\"focalLength\", new Uniform34(focalLength)], [\"fStop\", new Uniform34(fStop)], [\"luminanceThreshold\", new Uniform34(luminanceThreshold)], [\"luminanceGain\", new Uniform34(luminanceGain)], [\"bias\", new Uniform34(bias)], [\"fringe\", new Uniform34(fringe)], [\"maxBlur\", new Uniform34(maxBlur)], [\"dof\", new Uniform34(null)]])\n    });\n    _this52.rings = rings;\n    _this52.samples = samples;\n    _this52.showFocus = showFocus;\n    _this52.manualDoF = manualDoF;\n    _this52.pentagon = pentagon;\n    return _this52;\n  }\n\n  _createClass(RealisticBokehEffect, [{\n    key: \"rings\",\n    get: function get() {\n      return Number.parseInt(this.defines.get(\"RINGS_INT\"));\n    },\n    set: function set(value) {\n      var r = Math.floor(value);\n      this.defines.set(\"RINGS_INT\", r.toFixed(0));\n      this.defines.set(\"RINGS_FLOAT\", r.toFixed(1));\n      this.setChanged();\n    }\n  }, {\n    key: \"samples\",\n    get: function get() {\n      return Number.parseInt(this.defines.get(\"SAMPLES_INT\"));\n    },\n    set: function set(value) {\n      var s = Math.floor(value);\n      this.defines.set(\"SAMPLES_INT\", s.toFixed(0));\n      this.defines.set(\"SAMPLES_FLOAT\", s.toFixed(1));\n      this.setChanged();\n    }\n  }, {\n    key: \"showFocus\",\n    get: function get() {\n      return this.defines.has(\"SHOW_FOCUS\");\n    },\n    set: function set(value) {\n      if (this.showFocus !== value) {\n        if (value) {\n          this.defines.set(\"SHOW_FOCUS\", \"1\");\n        } else {\n          this.defines.delete(\"SHOW_FOCUS\");\n        }\n\n        this.setChanged();\n      }\n    }\n  }, {\n    key: \"manualDoF\",\n    get: function get() {\n      return this.defines.has(\"MANUAL_DOF\");\n    },\n    set: function set(value) {\n      if (this.manualDoF !== value) {\n        if (value) {\n          this.defines.set(\"MANUAL_DOF\", \"1\");\n          this.uniforms.get(\"dof\").value = new Vector42(0.2, 1, 0.2, 2);\n        } else {\n          this.defines.delete(\"MANUAL_DOF\");\n          this.uniforms.get(\"dof\").value = null;\n        }\n\n        this.setChanged();\n      }\n    }\n  }, {\n    key: \"pentagon\",\n    get: function get() {\n      return this.defines.has(\"PENTAGON\");\n    },\n    set: function set(value) {\n      if (this.pentagon !== value) {\n        if (value) {\n          this.defines.set(\"PENTAGON\", \"1\");\n        } else {\n          this.defines.delete(\"PENTAGON\");\n        }\n\n        this.setChanged();\n      }\n    }\n  }]);\n\n  return RealisticBokehEffect;\n}(Effect); // src/effects/ScanlineEffect.js\n\n\nimport { Uniform as Uniform35, Vector2 as Vector219 } from \"three\"; // src/effects/glsl/scanlines/shader.frag\n\nvar shader_default65 = \"uniform float count;\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\tvec2 sl = vec2(sin(uv.y * count), cos(uv.y * count));\\r\\n\tvec3 scanlines = vec3(sl.x, sl.y, sl.x);\\r\\n\\r\\n\toutputColor = vec4(scanlines, inputColor.a);\\r\\n\\r\\n}\\r\\n\"; // src/effects/ScanlineEffect.js\n\nvar ScanlineEffect = /*#__PURE__*/function (_Effect20) {\n  _inherits(ScanlineEffect, _Effect20);\n\n  var _super56 = _createSuper(ScanlineEffect);\n\n  function ScanlineEffect() {\n    var _this53;\n\n    var _ref26 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref26$blendFunction = _ref26.blendFunction,\n        blendFunction = _ref26$blendFunction === void 0 ? BlendFunction.OVERLAY : _ref26$blendFunction,\n        _ref26$density = _ref26.density,\n        density = _ref26$density === void 0 ? 1.25 : _ref26$density;\n\n    _classCallCheck(this, ScanlineEffect);\n\n    _this53 = _super56.call(this, \"ScanlineEffect\", shader_default65, {\n      blendFunction: blendFunction,\n      uniforms: new Map([[\"count\", new Uniform35(0)]])\n    });\n    _this53.resolution = new Vector219();\n    _this53.density = density;\n    return _this53;\n  }\n\n  _createClass(ScanlineEffect, [{\n    key: \"getDensity\",\n    value: function getDensity() {\n      return this.density;\n    }\n  }, {\n    key: \"setDensity\",\n    value: function setDensity(density) {\n      this.density = density;\n      this.setSize(this.resolution.x, this.resolution.y);\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      this.resolution.set(width, height);\n      this.uniforms.get(\"count\").value = Math.round(height * this.density);\n    }\n  }]);\n\n  return ScanlineEffect;\n}(Effect); // src/effects/ShockWaveEffect.js\n\n\nimport { Uniform as Uniform36, Vector2 as Vector220, Vector3 as Vector35 } from \"three\"; // src/effects/glsl/shock-wave/shader.frag\n\nvar shader_default66 = \"uniform bool active;\\r\\nuniform vec2 center;\\r\\nuniform float waveSize;\\r\\nuniform float radius;\\r\\nuniform float maxRadius;\\r\\nuniform float amplitude;\\r\\n\\r\\nvarying float vSize;\\r\\n\\r\\nvoid mainUv(inout vec2 uv) {\\r\\n\\r\\n\tif(active) {\\r\\n\\r\\n\t\tvec2 aspectCorrection = vec2(aspect, 1.0);\\r\\n\t\tvec2 difference = uv * aspectCorrection - center * aspectCorrection;\\r\\n\t\tfloat distance = sqrt(dot(difference, difference)) * vSize;\\r\\n\\r\\n\t\tif(distance > radius) {\\r\\n\\r\\n\t\t\tif(distance < radius + waveSize) {\\r\\n\\r\\n\t\t\t\tfloat angle = (distance - radius) * PI2 / waveSize;\\r\\n\t\t\t\tfloat cosSin = (1.0 - cos(angle)) * 0.5;\\r\\n\\r\\n\t\t\t\tfloat extent = maxRadius + waveSize;\\r\\n\t\t\t\tfloat decay = max(extent - distance * distance, 0.0) / extent;\\r\\n\\r\\n\t\t\t\tuv -= ((cosSin * amplitude * difference) / distance) * decay;\\r\\n\\r\\n\t\t\t}\\r\\n\\r\\n\t\t}\\r\\n\\r\\n\t}\\r\\n\\r\\n}\\r\\n\"; // src/effects/glsl/shock-wave/shader.vert\n\nvar shader_default67 = \"uniform float size;\\r\\nuniform float cameraDistance;\\r\\n\\r\\nvarying float vSize;\\r\\n\\r\\nvoid mainSupport() {\\r\\n\\r\\n\tvSize = (0.1 * cameraDistance) / size;\\r\\n\\r\\n}\\r\\n\"; // src/effects/ShockWaveEffect.js\n\nvar HALF_PI = Math.PI * 0.5;\nvar v2 = new Vector35();\nvar ab = new Vector35();\n\nvar ShockWaveEffect = /*#__PURE__*/function (_Effect21) {\n  _inherits(ShockWaveEffect, _Effect21);\n\n  var _super57 = _createSuper(ShockWaveEffect);\n\n  function ShockWaveEffect(camera) {\n    var _this54;\n\n    var epicenter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector35();\n\n    var _ref27 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref27$speed = _ref27.speed,\n        speed = _ref27$speed === void 0 ? 2 : _ref27$speed,\n        _ref27$maxRadius = _ref27.maxRadius,\n        maxRadius = _ref27$maxRadius === void 0 ? 1 : _ref27$maxRadius,\n        _ref27$waveSize = _ref27.waveSize,\n        waveSize = _ref27$waveSize === void 0 ? 0.2 : _ref27$waveSize,\n        _ref27$amplitude = _ref27.amplitude,\n        amplitude = _ref27$amplitude === void 0 ? 0.05 : _ref27$amplitude;\n\n    _classCallCheck(this, ShockWaveEffect);\n\n    _this54 = _super57.call(this, \"ShockWaveEffect\", shader_default66, {\n      vertexShader: shader_default67,\n      uniforms: new Map([[\"active\", new Uniform36(false)], [\"center\", new Uniform36(new Vector220(0.5, 0.5))], [\"cameraDistance\", new Uniform36(1)], [\"size\", new Uniform36(1)], [\"radius\", new Uniform36(-waveSize)], [\"maxRadius\", new Uniform36(maxRadius)], [\"waveSize\", new Uniform36(waveSize)], [\"amplitude\", new Uniform36(amplitude)]])\n    });\n    _this54.camera = camera;\n    _this54.epicenter = epicenter;\n    _this54.screenPosition = _this54.uniforms.get(\"center\").value;\n    _this54.speed = speed;\n    _this54.time = 0;\n    _this54.active = false;\n    return _this54;\n  }\n\n  _createClass(ShockWaveEffect, [{\n    key: \"explode\",\n    value: function explode() {\n      this.time = 0;\n      this.active = true;\n      this.uniforms.get(\"active\").value = true;\n    }\n  }, {\n    key: \"update\",\n    value: function update(renderer, inputBuffer, delta) {\n      var epicenter = this.epicenter;\n      var camera = this.camera;\n      var uniforms = this.uniforms;\n      var uniformActive = uniforms.get(\"active\");\n\n      if (this.active) {\n        var waveSize = uniforms.get(\"waveSize\").value;\n        camera.getWorldDirection(v2);\n        ab.copy(camera.position).sub(epicenter);\n        uniformActive.value = v2.angleTo(ab) > HALF_PI;\n\n        if (uniformActive.value) {\n          uniforms.get(\"cameraDistance\").value = camera.position.distanceTo(epicenter);\n          v2.copy(epicenter).project(camera);\n          this.screenPosition.set((v2.x + 1) * 0.5, (v2.y + 1) * 0.5);\n        }\n\n        this.time += delta * this.speed;\n        var radius = this.time - waveSize;\n        uniforms.get(\"radius\").value = radius;\n\n        if (radius >= (uniforms.get(\"maxRadius\").value + waveSize) * 2) {\n          this.active = false;\n          uniformActive.value = false;\n        }\n      }\n    }\n  }]);\n\n  return ShockWaveEffect;\n}(Effect); // src/effects/SelectiveBloomEffect.js\n\n\nimport { LinearFilter as LinearFilter11, NotEqualDepth as NotEqualDepth2, EqualDepth as EqualDepth2, RGBADepthPacking as RGBADepthPacking2, RGBFormat as RGBFormat12, UnsignedByteType as UnsignedByteType10, WebGLRenderTarget as WebGLRenderTarget13 } from \"three\";\n\nvar SelectiveBloomEffect = /*#__PURE__*/function (_BloomEffect) {\n  _inherits(SelectiveBloomEffect, _BloomEffect);\n\n  var _super58 = _createSuper(SelectiveBloomEffect);\n\n  function SelectiveBloomEffect(scene, camera, options) {\n    var _this55;\n\n    _classCallCheck(this, SelectiveBloomEffect);\n\n    _this55 = _super58.call(this, options);\n\n    _this55.setAttributes(_this55.getAttributes() | EffectAttribute.DEPTH);\n\n    _this55.camera = camera;\n    _this55.depthPass = new DepthPass(scene, camera);\n    _this55.clearPass = new ClearPass(true, false, false);\n    _this55.depthMaskPass = new ShaderPass(new DepthMaskMaterial());\n    var depthMaskMaterial = _this55.depthMaskMaterial;\n    depthMaskMaterial.uniforms.depthBuffer1.value = _this55.depthPass.texture;\n    depthMaskMaterial.defines.DEPTH_PACKING_1 = RGBADepthPacking2.toFixed(0);\n    depthMaskMaterial.setDepthMode(EqualDepth2);\n    _this55.renderTargetMasked = new WebGLRenderTarget13(1, 1, {\n      minFilter: LinearFilter11,\n      magFilter: LinearFilter11,\n      stencilBuffer: false,\n      depthBuffer: false\n    });\n    _this55.renderTargetMasked.texture.name = \"Bloom.Masked\";\n    _this55.renderTargetMasked.texture.generateMipmaps = false;\n    _this55.selection = new Selection();\n    return _this55;\n  }\n\n  _createClass(SelectiveBloomEffect, [{\n    key: \"depthMaskMaterial\",\n    get: function get() {\n      return this.depthMaskPass.getFullscreenMaterial();\n    }\n  }, {\n    key: \"inverted\",\n    get: function get() {\n      return this.depthMaskMaterial.getDepthMode() === NotEqualDepth2;\n    },\n    set: function set(value) {\n      this.depthMaskMaterial.setDepthMode(value ? NotEqualDepth2 : EqualDepth2);\n    }\n  }, {\n    key: \"ignoreBackground\",\n    get: function get() {\n      return !this.depthMaskMaterial.keepFar;\n    },\n    set: function set(value) {\n      this.depthMaskMaterial.keepFar = !value;\n    }\n  }, {\n    key: \"setDepthTexture\",\n    value: function setDepthTexture(depthTexture) {\n      var depthPacking = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var material = this.depthMaskPass.getFullscreenMaterial();\n      material.uniforms.depthBuffer0.value = depthTexture;\n      material.defines.DEPTH_PACKING_0 = depthPacking.toFixed(0);\n      material.needsUpdate = true;\n    }\n  }, {\n    key: \"update\",\n    value: function update(renderer, inputBuffer, deltaTime) {\n      var camera = this.camera;\n      var selection = this.selection;\n      var renderTarget = this.renderTargetMasked;\n      var mask = camera.layers.mask;\n      camera.layers.set(selection.layer);\n      this.depthPass.render(renderer);\n      camera.layers.mask = mask;\n      this.clearPass.render(renderer, renderTarget);\n      this.depthMaskPass.render(renderer, inputBuffer, renderTarget);\n\n      _get(_getPrototypeOf(SelectiveBloomEffect.prototype), \"update\", this).call(this, renderer, renderTarget, deltaTime);\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      _get(_getPrototypeOf(SelectiveBloomEffect.prototype), \"setSize\", this).call(this, width, height);\n\n      this.clearPass.setSize(width, height);\n      this.depthPass.setSize(width, height);\n      this.depthMaskPass.setSize(width, height);\n      this.renderTargetMasked.setSize(width, height);\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize(renderer, alpha, frameBufferType) {\n      _get(_getPrototypeOf(SelectiveBloomEffect.prototype), \"initialize\", this).call(this, renderer, alpha, frameBufferType);\n\n      this.clearPass.initialize(renderer, alpha, frameBufferType);\n      this.depthPass.initialize(renderer, alpha, frameBufferType);\n      this.depthMaskPass.initialize(renderer, alpha, frameBufferType);\n\n      if (!alpha && frameBufferType === UnsignedByteType10) {\n        this.renderTargetMasked.texture.format = RGBFormat12;\n      }\n\n      if (frameBufferType !== void 0) {\n        this.renderTargetMasked.texture.type = frameBufferType;\n      }\n    }\n  }]);\n\n  return SelectiveBloomEffect;\n}(BloomEffect); // src/effects/SepiaEffect.js\n\n\nimport { Uniform as Uniform37 } from \"three\"; // src/effects/glsl/sepia/shader.frag\n\nvar shader_default68 = \"uniform float intensity;\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\tvec3 color = vec3(\\r\\n\t\tdot(inputColor.rgb, vec3(1.0 - 0.607 * intensity, 0.769 * intensity, 0.189 * intensity)),\\r\\n\t\tdot(inputColor.rgb, vec3(0.349 * intensity, 1.0 - 0.314 * intensity, 0.168 * intensity)),\\r\\n\t\tdot(inputColor.rgb, vec3(0.272 * intensity, 0.534 * intensity, 1.0 - 0.869 * intensity))\\r\\n\t);\\r\\n\\r\\n\toutputColor = vec4(color, inputColor.a);\\r\\n\\r\\n}\\r\\n\"; // src/effects/SepiaEffect.js\n\nvar SepiaEffect = /*#__PURE__*/function (_Effect22) {\n  _inherits(SepiaEffect, _Effect22);\n\n  var _super59 = _createSuper(SepiaEffect);\n\n  function SepiaEffect() {\n    var _ref28 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref28$blendFunction = _ref28.blendFunction,\n        blendFunction = _ref28$blendFunction === void 0 ? BlendFunction.NORMAL : _ref28$blendFunction,\n        _ref28$intensity = _ref28.intensity,\n        intensity = _ref28$intensity === void 0 ? 1 : _ref28$intensity;\n\n    _classCallCheck(this, SepiaEffect);\n\n    return _super59.call(this, \"SepiaEffect\", shader_default68, {\n      blendFunction: blendFunction,\n      uniforms: new Map([[\"intensity\", new Uniform37(intensity)]])\n    });\n  }\n\n  return SepiaEffect;\n}(Effect); // src/effects/SMAAEffect.js\n\n\nimport { Color as Color7, LinearFilter as LinearFilter12, NearestFilter as NearestFilter7, RGBAFormat as RGBAFormat6, RGBFormat as RGBFormat13, Texture, Uniform as Uniform38, Vector2 as Vector221, WebGLRenderTarget as WebGLRenderTarget14 } from \"three\"; // src/images/smaa/searchImageDataURL.js\n\nvar searchImageDataURL_default = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC\"; // src/images/smaa/areaImageDataURL.js\n\nvar areaImageDataURL_default = \"data:image/png;base64,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\"; // src/effects/glsl/smaa/shader.frag\n\nvar shader_default69 = \"uniform sampler2D weightMap;\\r\\n\\r\\nvarying vec2 vOffset0;\\r\\nvarying vec2 vOffset1;\\r\\n\\r\\n/**\\r\\n * Moves values to a target vector based on a given conditional vector.\\r\\n */\\r\\n\\r\\nvoid movec(const in bvec2 c, inout vec2 variable, const in vec2 value) {\\r\\n\\r\\n\tif(c.x) { variable.x = value.x; }\\r\\n\tif(c.y) { variable.y = value.y; }\\r\\n\\r\\n}\\r\\n\\r\\nvoid movec(const in bvec4 c, inout vec4 variable, const in vec4 value) {\\r\\n\\r\\n\tmovec(c.xy, variable.xy, value.xy);\\r\\n\tmovec(c.zw, variable.zw, value.zw);\\r\\n\\r\\n}\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\t// Fetch the blending weights for the current pixel.\\r\\n\tvec4 a;\\r\\n\ta.x = texture2D(weightMap, vOffset0).a;\\r\\n\ta.y = texture2D(weightMap, vOffset1).g;\\r\\n\ta.wz = texture2D(weightMap, uv).rb;\\r\\n\\r\\n\tvec4 color = inputColor;\\r\\n\\r\\n\t// Ignore tiny blending weights.\\r\\n\tif(dot(a, vec4(1.0)) >= 1e-5) {\\r\\n\\r\\n\t\t// max(horizontal) > max(vertical)\\r\\n\t\tbool h = max(a.x, a.z) > max(a.y, a.w);\\r\\n\\r\\n\t\t// Calculate the blending offsets.\\r\\n\t\tvec4 blendingOffset = vec4(0.0, a.y, 0.0, a.w);\\r\\n\t\tvec2 blendingWeight = a.yw;\\r\\n\t\tmovec(bvec4(h), blendingOffset, vec4(a.x, 0.0, a.z, 0.0));\\r\\n\t\tmovec(bvec2(h), blendingWeight, a.xz);\\r\\n\t\tblendingWeight /= dot(blendingWeight, vec2(1.0));\\r\\n\\r\\n\t\t// Calculate the texture coordinates.\\r\\n\t\tvec4 blendingCoord = blendingOffset * vec4(texelSize, -texelSize) + uv.xyxy;\\r\\n\\r\\n\t\t// Rely on bilinear filtering to mix the current pixel with the neighbor.\\r\\n\t\tcolor = blendingWeight.x * texture2D(inputBuffer, blendingCoord.xy);\\r\\n\t\tcolor += blendingWeight.y * texture2D(inputBuffer, blendingCoord.zw);\\r\\n\\r\\n\t}\\r\\n\\r\\n\toutputColor = color;\\r\\n\\r\\n}\\r\\n\"; // src/effects/glsl/smaa/shader.vert\n\nvar shader_default70 = \"varying vec2 vOffset0;\\r\\nvarying vec2 vOffset1;\\r\\n\\r\\nvoid mainSupport(const in vec2 uv) {\\r\\n\\r\\n\tvOffset0 = uv + texelSize * vec2(1.0, 0.0);\\r\\n\tvOffset1 = uv + texelSize * vec2(0.0, 1.0);\\r\\n\\r\\n}\\r\\n\"; // src/effects/SMAAEffect.js\n\nvar SMAAEffect = /*#__PURE__*/function (_Effect23) {\n  _inherits(SMAAEffect, _Effect23);\n\n  var _super60 = _createSuper(SMAAEffect);\n\n  function SMAAEffect(searchImage, areaImage) {\n    var _this56;\n\n    var preset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : SMAAPreset.HIGH;\n    var edgeDetectionMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : EdgeDetectionMode.COLOR;\n\n    _classCallCheck(this, SMAAEffect);\n\n    _this56 = _super60.call(this, \"SMAAEffect\", shader_default69, {\n      vertexShader: shader_default70,\n      blendFunction: BlendFunction.NORMAL,\n      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,\n      uniforms: new Map([[\"weightMap\", new Uniform38(null)]])\n    });\n    _this56.renderTargetEdges = new WebGLRenderTarget14(1, 1, {\n      minFilter: LinearFilter12,\n      stencilBuffer: false,\n      depthBuffer: false,\n      format: RGBFormat13\n    });\n    _this56.renderTargetEdges.texture.name = \"SMAA.Edges\";\n    _this56.renderTargetWeights = _this56.renderTargetEdges.clone();\n    _this56.renderTargetWeights.texture.name = \"SMAA.Weights\";\n    _this56.renderTargetWeights.texture.format = RGBAFormat6;\n    _this56.uniforms.get(\"weightMap\").value = _this56.renderTargetWeights.texture;\n    _this56.clearPass = new ClearPass(true, false, false);\n    _this56.clearPass.overrideClearColor = new Color7(0);\n    _this56.clearPass.overrideClearAlpha = 1;\n    _this56.edgeDetectionPass = new ShaderPass(new EdgeDetectionMaterial(new Vector221(), edgeDetectionMode));\n    _this56.weightsPass = new ShaderPass(new SMAAWeightsMaterial());\n    var searchTexture = new Texture(searchImage);\n    searchTexture.name = \"SMAA.Search\";\n    searchTexture.magFilter = NearestFilter7;\n    searchTexture.minFilter = NearestFilter7;\n    searchTexture.format = RGBAFormat6;\n    searchTexture.generateMipmaps = false;\n    searchTexture.needsUpdate = true;\n    searchTexture.flipY = true;\n    var areaTexture = new Texture(areaImage);\n    areaTexture.name = \"SMAA.Area\";\n    areaTexture.minFilter = LinearFilter12;\n    areaTexture.format = RGBAFormat6;\n    areaTexture.generateMipmaps = false;\n    areaTexture.needsUpdate = true;\n    areaTexture.flipY = false;\n\n    var weightsMaterial = _this56.weightsPass.getFullscreenMaterial();\n\n    weightsMaterial.uniforms.searchTexture.value = searchTexture;\n    weightsMaterial.uniforms.areaTexture.value = areaTexture;\n\n    _this56.applyPreset(preset);\n\n    return _this56;\n  }\n\n  _createClass(SMAAEffect, [{\n    key: \"edgeDetectionMaterial\",\n    get: function get() {\n      return this.edgeDetectionPass.getFullscreenMaterial();\n    }\n  }, {\n    key: \"colorEdgesMaterial\",\n    get: function get() {\n      return this.edgeDetectionMaterial;\n    }\n  }, {\n    key: \"weightsMaterial\",\n    get: function get() {\n      return this.weightsPass.getFullscreenMaterial();\n    }\n  }, {\n    key: \"setEdgeDetectionThreshold\",\n    value: function setEdgeDetectionThreshold(threshold) {\n      this.edgeDetectionPass.getFullscreenMaterial().setEdgeDetectionThreshold(threshold);\n    }\n  }, {\n    key: \"setOrthogonalSearchSteps\",\n    value: function setOrthogonalSearchSteps(steps) {\n      this.weightsPass.getFullscreenMaterial().setOrthogonalSearchSteps(steps);\n    }\n  }, {\n    key: \"applyPreset\",\n    value: function applyPreset(preset) {\n      var edgeDetectionMaterial = this.edgeDetectionMaterial;\n      var weightsMaterial = this.weightsMaterial;\n\n      switch (preset) {\n        case SMAAPreset.LOW:\n          edgeDetectionMaterial.setEdgeDetectionThreshold(0.15);\n          weightsMaterial.setOrthogonalSearchSteps(4);\n          weightsMaterial.diagonalDetection = false;\n          weightsMaterial.cornerRounding = false;\n          break;\n\n        case SMAAPreset.MEDIUM:\n          edgeDetectionMaterial.setEdgeDetectionThreshold(0.1);\n          weightsMaterial.setOrthogonalSearchSteps(8);\n          weightsMaterial.diagonalDetection = false;\n          weightsMaterial.cornerRounding = false;\n          break;\n\n        case SMAAPreset.HIGH:\n          edgeDetectionMaterial.setEdgeDetectionThreshold(0.1);\n          weightsMaterial.setOrthogonalSearchSteps(16);\n          weightsMaterial.setDiagonalSearchSteps(8);\n          weightsMaterial.setCornerRounding(25);\n          weightsMaterial.diagonalDetection = true;\n          weightsMaterial.cornerRounding = true;\n          break;\n\n        case SMAAPreset.ULTRA:\n          edgeDetectionMaterial.setEdgeDetectionThreshold(0.05);\n          weightsMaterial.setOrthogonalSearchSteps(32);\n          weightsMaterial.setDiagonalSearchSteps(16);\n          weightsMaterial.setCornerRounding(25);\n          weightsMaterial.diagonalDetection = true;\n          weightsMaterial.cornerRounding = true;\n          break;\n      }\n    }\n  }, {\n    key: \"setDepthTexture\",\n    value: function setDepthTexture(depthTexture) {\n      var depthPacking = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var material = this.edgeDetectionMaterial;\n      material.uniforms.depthBuffer.value = depthTexture;\n      material.depthPacking = depthPacking;\n    }\n  }, {\n    key: \"update\",\n    value: function update(renderer, inputBuffer, deltaTime) {\n      this.clearPass.render(renderer, this.renderTargetEdges);\n      this.edgeDetectionPass.render(renderer, inputBuffer, this.renderTargetEdges);\n      this.weightsPass.render(renderer, this.renderTargetEdges, this.renderTargetWeights);\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      var edgeDetectionMaterial = this.edgeDetectionPass.getFullscreenMaterial();\n      var weightsMaterial = this.weightsPass.getFullscreenMaterial();\n      this.renderTargetEdges.setSize(width, height);\n      this.renderTargetWeights.setSize(width, height);\n      weightsMaterial.uniforms.resolution.value.set(width, height);\n      weightsMaterial.uniforms.texelSize.value.set(1 / width, 1 / height);\n      edgeDetectionMaterial.uniforms.texelSize.value.copy(weightsMaterial.uniforms.texelSize.value);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var uniforms = this.weightsPass.getFullscreenMaterial().uniforms;\n      uniforms.searchTexture.value.dispose();\n      uniforms.areaTexture.value.dispose();\n\n      _get(_getPrototypeOf(SMAAEffect.prototype), \"dispose\", this).call(this);\n    }\n  }], [{\n    key: \"searchImageDataURL\",\n    get: function get() {\n      return searchImageDataURL_default;\n    }\n  }, {\n    key: \"areaImageDataURL\",\n    get: function get() {\n      return areaImageDataURL_default;\n    }\n  }]);\n\n  return SMAAEffect;\n}(Effect);\n\nvar SMAAPreset = {\n  LOW: 0,\n  MEDIUM: 1,\n  HIGH: 2,\n  ULTRA: 3\n}; // src/effects/SSAOEffect.js\n\nimport { Color as Color8, LinearFilter as LinearFilter13, RepeatWrapping as RepeatWrapping3, RGBFormat as RGBFormat14, Uniform as Uniform39, WebGLRenderTarget as WebGLRenderTarget15 } from \"three\"; // src/effects/glsl/ssao/shader.frag\n\nvar shader_default71 = \"uniform sampler2D aoBuffer;\\r\\nuniform float luminanceInfluence;\\r\\n\\r\\n#ifdef DEPTH_AWARE_UPSAMPLING\\r\\n\\r\\n\t#ifdef GL_FRAGMENT_PRECISION_HIGH\\r\\n\\r\\n\t\tuniform highp sampler2D normalDepthBuffer;\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tuniform mediump sampler2D normalDepthBuffer;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n#endif\\r\\n\\r\\n#ifdef COLORIZE\\r\\n\\r\\n\tuniform vec3 color;\\r\\n\\r\\n#endif\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, const in float depth, out vec4 outputColor) {\\r\\n\\r\\n\tfloat aoLinear = texture2D(aoBuffer, uv).r;\\r\\n\\r\\n\t#if defined(DEPTH_AWARE_UPSAMPLING) && __VERSION__ == 300\\r\\n\\r\\n\t\t// Gather normals and depth in a 2x2 neighborhood.\\r\\n\t\tvec4 normalDepth[4] = vec4[](\\r\\n\t\t\ttextureOffset(normalDepthBuffer, uv, ivec2(0, 0)),\\r\\n\t\t\ttextureOffset(normalDepthBuffer, uv, ivec2(0, 1)),\\r\\n\t\t\ttextureOffset(normalDepthBuffer, uv, ivec2(1, 0)),\\r\\n\t\t\ttextureOffset(normalDepthBuffer, uv, ivec2(1, 1))\\r\\n\t\t);\\r\\n\\r\\n\t\t// Determine the smoothness of the surface around this fragment.\\r\\n\t\tfloat dot01 = dot(normalDepth[0].rgb, normalDepth[1].rgb);\\r\\n\t\tfloat dot02 = dot(normalDepth[0].rgb, normalDepth[2].rgb);\\r\\n\t\tfloat dot03 = dot(normalDepth[0].rgb, normalDepth[3].rgb);\\r\\n\\r\\n\t\tfloat minDot = min(dot01, min(dot02, dot03));\\r\\n\t\tfloat s = step(THRESHOLD, minDot);\\r\\n\\r\\n\t\t// Find the best AO based on depth.\\r\\n\t\tfloat smallestDistance = 1.0;\\r\\n\t\tint index;\\r\\n\\r\\n\t\tfor(int i = 0; i < 4; ++i) {\\r\\n\\r\\n\t\t\tfloat distance = abs(depth - normalDepth[i].a);\\r\\n\\r\\n\t\t\tif(distance < smallestDistance) {\\r\\n\\r\\n\t\t\t\tsmallestDistance = distance;\\r\\n\t\t\t\tindex = i;\\r\\n\\r\\n\t\t\t}\\r\\n\\r\\n\t\t}\\r\\n \\r\\n\t\t// Fetch the exact AO texel that corresponds to the best depth.\\r\\n\t\tivec2 offsets[4] = ivec2[](\\r\\n\t\t\tivec2(0, 0), ivec2(0, 1),\\r\\n\t\t\tivec2(1, 0), ivec2(1, 1)\\r\\n\t\t);\\r\\n\\r\\n\t\tivec2 coord = ivec2(uv * vec2(textureSize(aoBuffer, 0))) + offsets[index];\\r\\n\t\tfloat aoNearest = texelFetch(aoBuffer, coord, 0).r;\\r\\n\\r\\n\t\t// Smooth surfaces benefit more from linear filtering.\\r\\n\t\tfloat ao = mix(aoNearest, aoLinear, s);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tfloat ao = aoLinear;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\t// Fade AO based on luminance.\\r\\n\tfloat l = linearToRelativeLuminance(inputColor.rgb);\\r\\n\tao = mix(ao, 1.0, l * luminanceInfluence);\\r\\n\\r\\n\t#ifdef COLORIZE\\r\\n\\r\\n\t\toutputColor = vec4(1.0 - (1.0 - ao) * (1.0 - color), inputColor.a);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\toutputColor = vec4(vec3(ao), inputColor.a);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n}\\r\\n\"; // src/effects/SSAOEffect.js\n\nvar NOISE_TEXTURE_SIZE = 64;\n\nvar SSAOEffect = /*#__PURE__*/function (_Effect24) {\n  _inherits(SSAOEffect, _Effect24);\n\n  var _super61 = _createSuper(SSAOEffect);\n\n  function SSAOEffect(camera, normalBuffer) {\n    var _this57;\n\n    var _ref29 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref29$blendFunction = _ref29.blendFunction,\n        blendFunction = _ref29$blendFunction === void 0 ? BlendFunction.MULTIPLY : _ref29$blendFunction,\n        _ref29$distanceScalin = _ref29.distanceScaling,\n        distanceScaling = _ref29$distanceScalin === void 0 ? true : _ref29$distanceScalin,\n        _ref29$depthAwareUpsa = _ref29.depthAwareUpsampling,\n        depthAwareUpsampling = _ref29$depthAwareUpsa === void 0 ? true : _ref29$depthAwareUpsa,\n        _ref29$normalDepthBuf = _ref29.normalDepthBuffer,\n        normalDepthBuffer = _ref29$normalDepthBuf === void 0 ? null : _ref29$normalDepthBuf,\n        _ref29$samples = _ref29.samples,\n        samples = _ref29$samples === void 0 ? 9 : _ref29$samples,\n        _ref29$rings = _ref29.rings,\n        rings = _ref29$rings === void 0 ? 7 : _ref29$rings,\n        _ref29$distanceThresh = _ref29.distanceThreshold,\n        distanceThreshold = _ref29$distanceThresh === void 0 ? 0.97 : _ref29$distanceThresh,\n        _ref29$distanceFallof = _ref29.distanceFalloff,\n        distanceFalloff = _ref29$distanceFallof === void 0 ? 0.03 : _ref29$distanceFallof,\n        _ref29$rangeThreshold = _ref29.rangeThreshold,\n        rangeThreshold = _ref29$rangeThreshold === void 0 ? 5e-4 : _ref29$rangeThreshold,\n        _ref29$rangeFalloff = _ref29.rangeFalloff,\n        rangeFalloff = _ref29$rangeFalloff === void 0 ? 1e-3 : _ref29$rangeFalloff,\n        _ref29$minRadiusScale = _ref29.minRadiusScale,\n        minRadiusScale = _ref29$minRadiusScale === void 0 ? 0.33 : _ref29$minRadiusScale,\n        _ref29$luminanceInflu = _ref29.luminanceInfluence,\n        luminanceInfluence = _ref29$luminanceInflu === void 0 ? 0.7 : _ref29$luminanceInflu,\n        _ref29$radius = _ref29.radius,\n        radius = _ref29$radius === void 0 ? 0.1825 : _ref29$radius,\n        _ref29$intensity = _ref29.intensity,\n        intensity = _ref29$intensity === void 0 ? 1 : _ref29$intensity,\n        _ref29$bias = _ref29.bias,\n        bias = _ref29$bias === void 0 ? 0.025 : _ref29$bias,\n        _ref29$fade = _ref29.fade,\n        fade = _ref29$fade === void 0 ? 0.01 : _ref29$fade,\n        _ref29$color = _ref29.color,\n        color2 = _ref29$color === void 0 ? null : _ref29$color,\n        _ref29$resolutionScal = _ref29.resolutionScale,\n        resolutionScale = _ref29$resolutionScal === void 0 ? 1 : _ref29$resolutionScal,\n        _ref29$width = _ref29.width,\n        width = _ref29$width === void 0 ? Resizer.AUTO_SIZE : _ref29$width,\n        _ref29$height = _ref29.height,\n        height = _ref29$height === void 0 ? Resizer.AUTO_SIZE : _ref29$height;\n\n    _classCallCheck(this, SSAOEffect);\n\n    _this57 = _super61.call(this, \"SSAOEffect\", shader_default71, {\n      blendFunction: blendFunction,\n      attributes: EffectAttribute.DEPTH,\n      uniforms: new Map([[\"aoBuffer\", new Uniform39(null)], [\"normalDepthBuffer\", new Uniform39(null)], [\"luminanceInfluence\", new Uniform39(luminanceInfluence)], [\"color\", new Uniform39(null)], [\"scale\", new Uniform39(0)]])\n    });\n    _this57.renderTargetAO = new WebGLRenderTarget15(1, 1, {\n      minFilter: LinearFilter13,\n      magFilter: LinearFilter13,\n      stencilBuffer: false,\n      depthBuffer: false,\n      format: RGBFormat14\n    });\n    _this57.renderTargetAO.texture.name = \"AO.Target\";\n    _this57.renderTargetAO.texture.generateMipmaps = false;\n    _this57.uniforms.get(\"aoBuffer\").value = _this57.renderTargetAO.texture;\n    _this57.resolution = new Resizer(_assertThisInitialized(_this57), width, height, resolutionScale);\n    _this57.r = 1;\n    _this57.camera = camera;\n    _this57.ssaoPass = new ShaderPass(function () {\n      var noiseTexture = new NoiseTexture(NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE);\n      noiseTexture.wrapS = noiseTexture.wrapT = RepeatWrapping3;\n      var material = new SSAOMaterial(camera);\n      material.uniforms.noiseTexture.value = noiseTexture;\n      material.uniforms.intensity.value = intensity;\n      material.uniforms.minRadiusScale.value = minRadiusScale;\n      material.uniforms.fade.value = fade;\n      material.uniforms.bias.value = bias;\n\n      if (normalDepthBuffer !== null) {\n        material.uniforms.normalDepthBuffer.value = normalDepthBuffer;\n        material.defines.NORMAL_DEPTH = \"1\";\n\n        if (depthAwareUpsampling) {\n          _this57.depthAwareUpsampling = depthAwareUpsampling;\n          _this57.uniforms.get(\"normalDepthBuffer\").value = normalDepthBuffer;\n\n          _this57.defines.set(\"THRESHOLD\", \"0.997\");\n        }\n      } else {\n        material.uniforms.normalBuffer.value = normalBuffer;\n      }\n\n      return material;\n    }());\n    _this57.distanceScaling = distanceScaling;\n    _this57.samples = samples;\n    _this57.rings = rings;\n    _this57.color = color2;\n    _this57.radius = radius > 1 ? radius / 100 : radius;\n\n    _this57.setDistanceCutoff(distanceThreshold, distanceFalloff);\n\n    _this57.setProximityCutoff(rangeThreshold, rangeFalloff);\n\n    return _this57;\n  }\n\n  _createClass(SSAOEffect, [{\n    key: \"ssaoMaterial\",\n    get: function get() {\n      return this.ssaoPass.getFullscreenMaterial();\n    }\n  }, {\n    key: \"samples\",\n    get: function get() {\n      return Number(this.ssaoMaterial.defines.SAMPLES_INT);\n    },\n    set: function set(value) {\n      var material = this.ssaoMaterial;\n      material.defines.SAMPLES_INT = value.toFixed(0);\n      material.defines.SAMPLES_FLOAT = value.toFixed(1);\n      material.needsUpdate = true;\n    }\n  }, {\n    key: \"rings\",\n    get: function get() {\n      return Number(this.ssaoMaterial.defines.SPIRAL_TURNS);\n    },\n    set: function set(value) {\n      var material = this.ssaoMaterial;\n      material.defines.SPIRAL_TURNS = value.toFixed(1);\n      material.needsUpdate = true;\n    }\n  }, {\n    key: \"radius\",\n    get: function get() {\n      return this.r;\n    },\n    set: function set(value) {\n      this.r = Math.min(Math.max(value, 1e-6), 1);\n      var radius = this.r * this.resolution.height;\n      var material = this.ssaoMaterial;\n      material.defines.RADIUS = radius.toFixed(11);\n      material.defines.RADIUS_SQ = (radius * radius).toFixed(11);\n      material.needsUpdate = true;\n    }\n  }, {\n    key: \"depthAwareUpsampling\",\n    get: function get() {\n      return this.defines.has(\"DEPTH_AWARE_UPSAMPLING\");\n    },\n    set: function set(value) {\n      if (this.depthAwareUpsampling !== value) {\n        if (value) {\n          this.defines.set(\"DEPTH_AWARE_UPSAMPLING\", \"1\");\n        } else {\n          this.defines.delete(\"DEPTH_AWARE_UPSAMPLING\");\n        }\n\n        this.setChanged();\n      }\n    }\n  }, {\n    key: \"distanceScaling\",\n    get: function get() {\n      return this.ssaoMaterial.defines.DISTANCE_SCALING !== void 0;\n    },\n    set: function set(value) {\n      if (this.distanceScaling !== value) {\n        var material = this.ssaoMaterial;\n\n        if (value) {\n          material.defines.DISTANCE_SCALING = \"1\";\n        } else {\n          delete material.defines.DISTANCE_SCALING;\n        }\n\n        material.needsUpdate = true;\n      }\n    }\n  }, {\n    key: \"color\",\n    get: function get() {\n      return this.uniforms.get(\"color\").value;\n    },\n    set: function set(value) {\n      var uniforms = this.uniforms;\n      var defines = this.defines;\n\n      if (value !== null) {\n        if (defines.has(\"COLORIZE\")) {\n          uniforms.get(\"color\").value.set(value);\n        } else {\n          defines.set(\"COLORIZE\", \"1\");\n          uniforms.get(\"color\").value = new Color8(value);\n          this.setChanged();\n        }\n      } else if (defines.has(\"COLORIZE\")) {\n        defines.delete(\"COLORIZE\");\n        uniforms.get(\"color\").value = null;\n        this.setChanged();\n      }\n    }\n  }, {\n    key: \"setDistanceCutoff\",\n    value: function setDistanceCutoff(threshold, falloff) {\n      this.ssaoMaterial.uniforms.distanceCutoff.value.set(Math.min(Math.max(threshold, 0), 1), Math.min(Math.max(threshold + falloff, 0), 1));\n    }\n  }, {\n    key: \"setProximityCutoff\",\n    value: function setProximityCutoff(threshold, falloff) {\n      this.ssaoMaterial.uniforms.proximityCutoff.value.set(Math.min(Math.max(threshold, 0), 1), Math.min(Math.max(threshold + falloff, 0), 1));\n    }\n  }, {\n    key: \"setDepthTexture\",\n    value: function setDepthTexture(depthTexture) {\n      var depthPacking = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var material = this.ssaoMaterial;\n\n      if (material.defines.NORMAL_DEPTH === void 0) {\n        material.uniforms.normalDepthBuffer.value = depthTexture;\n        material.depthPacking = depthPacking;\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(renderer, inputBuffer, deltaTime) {\n      this.ssaoPass.render(renderer, null, this.renderTargetAO);\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      var resolution = this.resolution;\n      resolution.base.set(width, height);\n      var w = resolution.width;\n      var h = resolution.height;\n      this.renderTargetAO.setSize(w, h);\n      this.ssaoMaterial.setTexelSize(1 / w, 1 / h);\n      var camera = this.camera;\n      var uniforms = this.ssaoMaterial.uniforms;\n      uniforms.noiseScale.value.set(w, h).divideScalar(NOISE_TEXTURE_SIZE);\n      uniforms.inverseProjectionMatrix.value.copy(camera.projectionMatrix).invert();\n      uniforms.projectionMatrix.value.copy(camera.projectionMatrix);\n      this.radius = this.r;\n    }\n  }]);\n\n  return SSAOEffect;\n}(Effect); // src/effects/TextureEffect.js\n\n\nimport { LinearEncoding as LinearEncoding3, Matrix3, sRGBEncoding as sRGBEncoding3, Uniform as Uniform40 } from \"three\"; // src/effects/glsl/texture/shader.frag\n\nvar shader_default72 = \"uniform sampler2D texture;\\r\\n\\r\\n#if defined(ASPECT_CORRECTION) || defined(UV_TRANSFORM)\\r\\n\\r\\n\tvarying vec2 vUv2;\\r\\n\\r\\n#endif\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\t#if defined(ASPECT_CORRECTION) || defined(UV_TRANSFORM)\\r\\n\\r\\n\t\tvec4 texel = texelToLinear(texture2D(texture, vUv2));\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tvec4 texel = texelToLinear(texture2D(texture, uv));\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\toutputColor = TEXEL;\\r\\n\\r\\n}\\r\\n\"; // src/effects/glsl/texture/shader.vert\n\nvar shader_default73 = \"#ifdef ASPECT_CORRECTION\\r\\n\\r\\n\tuniform float scale;\\r\\n\\r\\n#else\\r\\n\\r\\n\tuniform mat3 uvTransform;\\r\\n\\r\\n#endif\\r\\n\\r\\nvarying vec2 vUv2;\\r\\n\\r\\nvoid mainSupport(const in vec2 uv) {\\r\\n\\r\\n\t#ifdef ASPECT_CORRECTION\\r\\n\\r\\n\t\tvUv2 = uv * vec2(aspect, 1.0) * scale;\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tvUv2 = (uvTransform * vec3(uv, 1.0)).xy;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n}\\r\\n\"; // src/effects/TextureEffect.js\n\nvar TextureEffect = /*#__PURE__*/function (_Effect25) {\n  _inherits(TextureEffect, _Effect25);\n\n  var _super62 = _createSuper(TextureEffect);\n\n  function TextureEffect() {\n    var _this58;\n\n    var _ref30 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref30$blendFunction = _ref30.blendFunction,\n        blendFunction = _ref30$blendFunction === void 0 ? BlendFunction.NORMAL : _ref30$blendFunction,\n        _ref30$texture = _ref30.texture,\n        texture = _ref30$texture === void 0 ? null : _ref30$texture,\n        _ref30$aspectCorrecti = _ref30.aspectCorrection,\n        aspectCorrection = _ref30$aspectCorrecti === void 0 ? false : _ref30$aspectCorrecti;\n\n    _classCallCheck(this, TextureEffect);\n\n    _this58 = _super62.call(this, \"TextureEffect\", shader_default72, {\n      blendFunction: blendFunction,\n      defines: new Map([[\"TEXEL\", \"texel\"]]),\n      uniforms: new Map([[\"texture\", new Uniform40(null)], [\"scale\", new Uniform40(1)], [\"uvTransform\", new Uniform40(null)]])\n    });\n    _this58.texture = texture;\n    _this58.aspectCorrection = aspectCorrection;\n    return _this58;\n  }\n\n  _createClass(TextureEffect, [{\n    key: \"texture\",\n    get: function get() {\n      return this.uniforms.get(\"texture\").value;\n    },\n    set: function set(value) {\n      var currentTexture = this.texture;\n\n      if (currentTexture !== value) {\n        var previousEncoding = currentTexture !== null ? currentTexture.encoding : null;\n        this.uniforms.get(\"texture\").value = value;\n\n        if (value !== null) {\n          switch (value.encoding) {\n            case sRGBEncoding3:\n              this.defines.set(\"texelToLinear(texel)\", \"sRGBToLinear(texel)\");\n              break;\n\n            case LinearEncoding3:\n              this.defines.set(\"texelToLinear(texel)\", \"texel\");\n              break;\n\n            default:\n              console.error(\"Unsupported encoding:\", value.encoding);\n              break;\n          }\n\n          if (previousEncoding !== value.encoding) {\n            this.setChanged();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"aspectCorrection\",\n    get: function get() {\n      return this.defines.has(\"ASPECT_CORRECTION\");\n    },\n    set: function set(value) {\n      if (this.aspectCorrection !== value) {\n        if (value) {\n          if (this.uvTransform) {\n            this.uvTransform = false;\n          }\n\n          this.defines.set(\"ASPECT_CORRECTION\", \"1\");\n          this.setVertexShader(shader_default73);\n        } else {\n          this.defines.delete(\"ASPECT_CORRECTION\");\n          this.setVertexShader(null);\n        }\n\n        this.setChanged();\n      }\n    }\n  }, {\n    key: \"uvTransform\",\n    get: function get() {\n      return this.defines.has(\"UV_TRANSFORM\");\n    },\n    set: function set(value) {\n      if (this.uvTransform !== value) {\n        if (value) {\n          if (this.aspectCorrection) {\n            this.aspectCorrection = false;\n          }\n\n          this.defines.set(\"UV_TRANSFORM\", \"1\");\n          this.uniforms.get(\"uvTransform\").value = new Matrix3();\n          this.setVertexShader(shader_default73);\n        } else {\n          this.defines.delete(\"UV_TRANSFORM\");\n          this.uniforms.get(\"uvTransform\").value = null;\n          this.setVertexShader(null);\n        }\n\n        this.setChanged();\n      }\n    }\n  }, {\n    key: \"setTextureSwizzleRGBA\",\n    value: function setTextureSwizzleRGBA(r) {\n      var g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : r;\n      var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : r;\n      var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : r;\n      var rgba = \"rgba\";\n      var swizzle = \"\";\n\n      if (r !== ColorChannel.RED || g !== ColorChannel.GREEN || b !== ColorChannel.BLUE || a !== ColorChannel.ALPHA) {\n        swizzle = [\".\", rgba[r], rgba[g], rgba[b], rgba[a]].join(\"\");\n      }\n\n      this.defines.set(\"TEXEL\", \"texel\" + swizzle);\n      this.setChanged();\n    }\n  }, {\n    key: \"update\",\n    value: function update(renderer, inputBuffer, deltaTime) {\n      var texture = this.uniforms.get(\"texture\").value;\n\n      if (this.uvTransform && texture.matrixAutoUpdate) {\n        texture.updateMatrix();\n        this.uniforms.get(\"uvTransform\").value.copy(texture.matrix);\n      }\n    }\n  }]);\n\n  return TextureEffect;\n}(Effect); // src/effects/ToneMappingEffect.js\n\n\nimport { LinearFilter as LinearFilter14, LinearMipMapLinearFilter, LinearMipmapLinearFilter, RGBFormat as RGBFormat15, Uniform as Uniform41, WebGLRenderTarget as WebGLRenderTarget16 } from \"three\"; // src/effects/glsl/tone-mapping/shader.frag\n\nvar shader_default74 = \"#include <tonemapping_pars_fragment>\\r\\n\\r\\nuniform sampler2D luminanceBuffer;\\r\\nuniform float whitePoint;\\r\\nuniform float middleGrey;\\r\\n\\r\\n#ifndef ADAPTIVE\\r\\n\\r\\n\tuniform float averageLuminance;\\r\\n\\r\\n#endif\\r\\n\\r\\nvec3 Reinhard2ToneMapping(vec3 color) {\\r\\n\\r\\n\tcolor *= toneMappingExposure;\\r\\n\\r\\n\t// Calculate the luminance of the current pixel.\\r\\n\tfloat l = linearToRelativeLuminance(color);\\r\\n\\r\\n\t#ifdef ADAPTIVE\\r\\n\\r\\n\t\t// Get the average luminance from the adaptive 1x1 buffer.\\r\\n\t\tfloat lumAvg = texture2D(luminanceBuffer, vec2(0.5)).r;\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tfloat lumAvg = averageLuminance;\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\tfloat lumScaled = (l * middleGrey) / max(lumAvg, 1e-6);\\r\\n\tfloat lumCompressed = lumScaled * (1.0 + lumScaled / (whitePoint * whitePoint));\\r\\n\tlumCompressed /= (1.0 + lumScaled);\\r\\n\\r\\n\treturn clamp(lumCompressed * color, 0.0, 1.0);\\r\\n\\r\\n}\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\t#ifdef REINHARD2\\r\\n\\r\\n\t\toutputColor = vec4(Reinhard2ToneMapping(inputColor.rgb), inputColor.a);\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\toutputColor = vec4(toneMapping(inputColor.rgb), inputColor.a);\\r\\n\\r\\n\t#endif\\r\\n\\r\\n}\\r\\n\"; // src/effects/ToneMappingEffect.js\n\nvar ToneMappingEffect = /*#__PURE__*/function (_Effect26) {\n  _inherits(ToneMappingEffect, _Effect26);\n\n  var _super63 = _createSuper(ToneMappingEffect);\n\n  function ToneMappingEffect() {\n    var _this59;\n\n    var _ref31 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref31$blendFunction = _ref31.blendFunction,\n        blendFunction = _ref31$blendFunction === void 0 ? BlendFunction.NORMAL : _ref31$blendFunction,\n        _ref31$adaptive = _ref31.adaptive,\n        adaptive = _ref31$adaptive === void 0 ? true : _ref31$adaptive,\n        _ref31$mode = _ref31.mode,\n        mode = _ref31$mode === void 0 ? adaptive ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.REINHARD2 : _ref31$mode,\n        _ref31$resolution = _ref31.resolution,\n        resolution = _ref31$resolution === void 0 ? 256 : _ref31$resolution,\n        _ref31$maxLuminance = _ref31.maxLuminance,\n        maxLuminance = _ref31$maxLuminance === void 0 ? 16 : _ref31$maxLuminance,\n        _ref31$whitePoint = _ref31.whitePoint,\n        whitePoint = _ref31$whitePoint === void 0 ? maxLuminance : _ref31$whitePoint,\n        _ref31$middleGrey = _ref31.middleGrey,\n        middleGrey = _ref31$middleGrey === void 0 ? 0.6 : _ref31$middleGrey,\n        _ref31$minLuminance = _ref31.minLuminance,\n        minLuminance = _ref31$minLuminance === void 0 ? 0.01 : _ref31$minLuminance,\n        _ref31$averageLuminan = _ref31.averageLuminance,\n        averageLuminance = _ref31$averageLuminan === void 0 ? 1 : _ref31$averageLuminan,\n        _ref31$adaptationRate = _ref31.adaptationRate,\n        adaptationRate = _ref31$adaptationRate === void 0 ? 1 : _ref31$adaptationRate;\n\n    _classCallCheck(this, ToneMappingEffect);\n\n    _this59 = _super63.call(this, \"ToneMappingEffect\", shader_default74, {\n      blendFunction: blendFunction,\n      uniforms: new Map([[\"luminanceBuffer\", new Uniform41(null)], [\"maxLuminance\", new Uniform41(maxLuminance)], [\"whitePoint\", new Uniform41(whitePoint)], [\"middleGrey\", new Uniform41(middleGrey)], [\"averageLuminance\", new Uniform41(averageLuminance)]])\n    });\n    _this59.renderTargetLuminance = new WebGLRenderTarget16(1, 1, {\n      minFilter: LinearMipmapLinearFilter !== void 0 ? LinearMipmapLinearFilter : LinearMipMapLinearFilter,\n      magFilter: LinearFilter14,\n      stencilBuffer: false,\n      depthBuffer: false,\n      format: RGBFormat15\n    });\n    _this59.renderTargetLuminance.texture.name = \"Luminance\";\n    _this59.renderTargetLuminance.texture.generateMipmaps = true;\n    _this59.luminancePass = new LuminancePass({\n      renderTarget: _this59.renderTargetLuminance\n    });\n    _this59.adaptiveLuminancePass = new AdaptiveLuminancePass(_this59.luminancePass.texture, {\n      minLuminance: minLuminance,\n      adaptationRate: adaptationRate\n    });\n    _this59.uniforms.get(\"luminanceBuffer\").value = _this59.adaptiveLuminancePass.texture;\n    _this59.mode = null;\n\n    _this59.setMode(mode);\n\n    _this59.resolution = resolution;\n    return _this59;\n  }\n\n  _createClass(ToneMappingEffect, [{\n    key: \"getMode\",\n    value: function getMode() {\n      return this.mode;\n    }\n  }, {\n    key: \"setMode\",\n    value: function setMode(value) {\n      var currentMode = this.mode;\n\n      if (currentMode !== value) {\n        this.defines.clear();\n\n        switch (value) {\n          case ToneMappingMode.REINHARD:\n            this.defines.set(\"toneMapping(texel)\", \"ReinhardToneMapping(texel)\");\n            break;\n\n          case ToneMappingMode.OPTIMIZED_CINEON:\n            this.defines.set(\"toneMapping(texel)\", \"OptimizedCineonToneMapping(texel)\");\n            break;\n\n          case ToneMappingMode.ACES_FILMIC:\n            this.defines.set(\"toneMapping(texel)\", \"ACESFilmicToneMapping(texel)\");\n            break;\n\n          default:\n            this.defines.set(\"toneMapping(texel)\", \"texel\");\n            break;\n        }\n\n        if (value === ToneMappingMode.REINHARD2) {\n          this.defines.set(\"REINHARD2\", \"1\");\n        } else if (value === ToneMappingMode.REINHARD2_ADAPTIVE) {\n          this.defines.set(\"REINHARD2\", \"1\");\n          this.defines.set(\"ADAPTIVE\", \"1\");\n        }\n\n        this.mode = value;\n        this.setChanged();\n      }\n    }\n  }, {\n    key: \"resolution\",\n    get: function get() {\n      return this.luminancePass.resolution.width;\n    },\n    set: function set(value) {\n      var exponent = Math.max(0, Math.ceil(Math.log2(value)));\n      var size = Math.pow(2, exponent);\n      this.luminancePass.resolution.width = size;\n      this.luminancePass.resolution.height = size;\n      this.adaptiveLuminancePass.mipLevel1x1 = exponent;\n    }\n  }, {\n    key: \"adaptive\",\n    get: function get() {\n      return this.defines.has(\"ADAPTIVE\");\n    },\n    set: function set(value) {\n      this.mode = value ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.REINHARD2;\n    }\n  }, {\n    key: \"adaptationRate\",\n    get: function get() {\n      return this.adaptiveLuminancePass.adaptationRate;\n    },\n    set: function set(value) {\n      this.adaptiveLuminancePass.adaptationRate = value;\n    }\n  }, {\n    key: \"distinction\",\n    get: function get() {\n      console.warn(this.name, \"The distinction field has been removed.\");\n      return 1;\n    },\n    set: function set(value) {\n      console.warn(this.name, \"The distinction field has been removed.\");\n    }\n  }, {\n    key: \"update\",\n    value: function update(renderer, inputBuffer, deltaTime) {\n      if (this.mode === ToneMappingMode.REINHARD2_ADAPTIVE) {\n        this.luminancePass.render(renderer, inputBuffer);\n        this.adaptiveLuminancePass.render(renderer, null, null, deltaTime);\n      }\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize(renderer, alpha, frameBufferType) {\n      this.adaptiveLuminancePass.initialize(renderer, alpha, frameBufferType);\n    }\n  }]);\n\n  return ToneMappingEffect;\n}(Effect);\n\nvar ToneMappingMode = {\n  REINHARD: 0,\n  REINHARD2: 1,\n  REINHARD2_ADAPTIVE: 2,\n  OPTIMIZED_CINEON: 3,\n  ACES_FILMIC: 4\n}; // src/effects/VignetteEffect.js\n\nimport { Uniform as Uniform42 } from \"three\"; // src/effects/glsl/vignette/shader.frag\n\nvar shader_default75 = \"uniform float offset;\\r\\nuniform float darkness;\\r\\n\\r\\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\r\\n\\r\\n\tconst vec2 center = vec2(0.5);\\r\\n\tvec3 color = inputColor.rgb;\\r\\n\\r\\n\t#ifdef ESKIL\\r\\n\\r\\n\t\tvec2 coord = (uv - center) * vec2(offset);\\r\\n\t\tcolor = mix(color, vec3(1.0 - darkness), dot(coord, coord));\\r\\n\\r\\n\t#else\\r\\n\\r\\n\t\tfloat d = distance(uv, center);\\r\\n\t\tcolor *= smoothstep(0.8, offset * 0.799, d * (darkness + offset));\\r\\n\\r\\n\t#endif\\r\\n\\r\\n\toutputColor = vec4(color, inputColor.a);\\r\\n\\r\\n}\\r\\n\"; // src/effects/VignetteEffect.js\n\nvar VignetteEffect = /*#__PURE__*/function (_Effect27) {\n  _inherits(VignetteEffect, _Effect27);\n\n  var _super64 = _createSuper(VignetteEffect);\n\n  function VignetteEffect() {\n    var _this60;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, VignetteEffect);\n\n    var settings = Object.assign({\n      blendFunction: BlendFunction.NORMAL,\n      eskil: false,\n      offset: 0.5,\n      darkness: 0.5\n    }, options);\n    _this60 = _super64.call(this, \"VignetteEffect\", shader_default75, {\n      blendFunction: settings.blendFunction,\n      uniforms: new Map([[\"offset\", new Uniform42(settings.offset)], [\"darkness\", new Uniform42(settings.darkness)]])\n    });\n    _this60.eskil = settings.eskil;\n    return _this60;\n  }\n\n  _createClass(VignetteEffect, [{\n    key: \"eskil\",\n    get: function get() {\n      return this.defines.has(\"ESKIL\");\n    },\n    set: function set(value) {\n      if (this.eskil !== value) {\n        if (value) {\n          this.defines.set(\"ESKIL\", \"1\");\n        } else {\n          this.defines.delete(\"ESKIL\");\n        }\n\n        this.setChanged();\n      }\n    }\n  }]);\n\n  return VignetteEffect;\n}(Effect); // src/images/lut/TetrahedralUpscaler.js\n\n\nvar P = [new Float32Array(3), new Float32Array(3)];\nvar C = [new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3)];\nvar T = [[new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1])]];\n\nfunction calculateTetrahedronVolume(a, b, c2, d) {\n  var bcX = c2[0] - b[0];\n  var bcY = c2[1] - b[1];\n  var bcZ = c2[2] - b[2];\n  var baX = a[0] - b[0];\n  var baY = a[1] - b[1];\n  var baZ = a[2] - b[2];\n  var crossX = bcY * baZ - bcZ * baY;\n  var crossY = bcZ * baX - bcX * baZ;\n  var crossZ = bcX * baY - bcY * baX;\n  var length = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);\n  var triangleArea = length * 0.5;\n  var normalX = crossX / length;\n  var normalY = crossY / length;\n  var normalZ = crossZ / length;\n  var constant = -(a[0] * normalX + a[1] * normalY + a[2] * normalZ);\n  var dot = d[0] * normalX + d[1] * normalY + d[2] * normalZ;\n  var height = Math.abs(dot + constant);\n  return height * triangleArea / 3;\n}\n\nfunction sample(data, size, x, y, z, color2) {\n  var i3 = (x + y * size + z * size * size) * 3;\n  color2[0] = data[i3 + 0];\n  color2[1] = data[i3 + 1];\n  color2[2] = data[i3 + 2];\n}\n\nfunction tetrahedralSample(data, size, u, v3, w, color2) {\n  var px = u * (size - 1);\n  var py = v3 * (size - 1);\n  var pz = w * (size - 1);\n  var minX = Math.floor(px);\n  var minY = Math.floor(py);\n  var minZ = Math.floor(pz);\n  var maxX = Math.ceil(px);\n  var maxY = Math.ceil(py);\n  var maxZ = Math.ceil(pz);\n  var su = px - minX;\n  var sv = py - minY;\n  var sw = pz - minZ;\n\n  if (minX === px && minY === py && minZ === pz) {\n    sample(data, size, px, py, pz, color2);\n  } else {\n    var vertices;\n\n    if (su >= sv && sv >= sw) {\n      vertices = T[0];\n    } else if (su >= sw && sw >= sv) {\n      vertices = T[1];\n    } else if (sw >= su && su >= sv) {\n      vertices = T[2];\n    } else if (sv >= su && su >= sw) {\n      vertices = T[3];\n    } else if (sv >= sw && sw >= su) {\n      vertices = T[4];\n    } else if (sw >= sv && sv >= su) {\n      vertices = T[5];\n    }\n\n    var _vertices = vertices,\n        _vertices2 = _slicedToArray(_vertices, 4),\n        P0 = _vertices2[0],\n        P1 = _vertices2[1],\n        P2 = _vertices2[2],\n        P3 = _vertices2[3];\n\n    var coords = P[0];\n    coords[0] = su;\n    coords[1] = sv;\n    coords[2] = sw;\n    var tmp = P[1];\n    var diffX = maxX - minX;\n    var diffY = maxY - minY;\n    var diffZ = maxZ - minZ;\n    tmp[0] = diffX * P0[0] + minX;\n    tmp[1] = diffY * P0[1] + minY;\n    tmp[2] = diffZ * P0[2] + minZ;\n    sample(data, size, tmp[0], tmp[1], tmp[2], C[0]);\n    tmp[0] = diffX * P1[0] + minX;\n    tmp[1] = diffY * P1[1] + minY;\n    tmp[2] = diffZ * P1[2] + minZ;\n    sample(data, size, tmp[0], tmp[1], tmp[2], C[1]);\n    tmp[0] = diffX * P2[0] + minX;\n    tmp[1] = diffY * P2[1] + minY;\n    tmp[2] = diffZ * P2[2] + minZ;\n    sample(data, size, tmp[0], tmp[1], tmp[2], C[2]);\n    tmp[0] = diffX * P3[0] + minX;\n    tmp[1] = diffY * P3[1] + minY;\n    tmp[2] = diffZ * P3[2] + minZ;\n    sample(data, size, tmp[0], tmp[1], tmp[2], C[3]);\n    var V0 = calculateTetrahedronVolume(P1, P2, P3, coords) * 6;\n    var V1 = calculateTetrahedronVolume(P0, P2, P3, coords) * 6;\n    var V2 = calculateTetrahedronVolume(P0, P1, P3, coords) * 6;\n    var V3 = calculateTetrahedronVolume(P0, P1, P2, coords) * 6;\n    C[0][0] *= V0;\n    C[0][1] *= V0;\n    C[0][2] *= V0;\n    C[1][0] *= V1;\n    C[1][1] *= V1;\n    C[1][2] *= V1;\n    C[2][0] *= V2;\n    C[2][1] *= V2;\n    C[2][2] *= V2;\n    C[3][0] *= V3;\n    C[3][1] *= V3;\n    C[3][2] *= V3;\n    color2[0] = C[0][0] + C[1][0] + C[2][0] + C[3][0];\n    color2[1] = C[0][1] + C[1][1] + C[2][1] + C[3][1];\n    color2[2] = C[0][2] + C[1][2] + C[2][2] + C[3][2];\n  }\n}\n\nvar TetrahedralUpscaler = /*#__PURE__*/function () {\n  function TetrahedralUpscaler() {\n    _classCallCheck(this, TetrahedralUpscaler);\n  }\n\n  _createClass(TetrahedralUpscaler, null, [{\n    key: \"expand\",\n    value: function expand(data, size) {\n      var originalSize = Math.cbrt(data.length / 3);\n      var rgb = new Float32Array(3);\n      var array = new data.constructor(Math.pow(size, 3) * 3);\n      var s = 1 / (size - 1);\n\n      for (var z = 0; z < size; ++z) {\n        for (var y = 0; y < size; ++y) {\n          for (var x = 0; x < size; ++x) {\n            var u = x * s;\n            var v3 = y * s;\n            var w = z * s;\n            var i3 = Math.round(x + y * size + z * size * size) * 3;\n            tetrahedralSample(data, originalSize, u, v3, w, rgb);\n            array[i3 + 0] = rgb[0];\n            array[i3 + 1] = rgb[1];\n            array[i3 + 2] = rgb[2];\n          }\n        }\n      }\n\n      return array;\n    }\n  }]);\n\n  return TetrahedralUpscaler;\n}(); // src/images/smaa/SMAAAreaImageData.js\n\n\nvar area = [new Float32Array(2), new Float32Array(2)];\nvar ORTHOGONAL_SIZE = 16;\nvar DIAGONAL_SIZE = 20;\nvar DIAGONAL_SAMPLES = 30;\nvar SMOOTH_MAX_DISTANCE = 32;\nvar orthogonalSubsamplingOffsets = new Float32Array([0, -0.25, 0.25, -0.125, 0.125, -0.375, 0.375]);\nvar diagonalSubsamplingOffsets = [new Float32Array([0, 0]), new Float32Array([0.25, -0.25]), new Float32Array([-0.25, 0.25]), new Float32Array([0.125, -0.125]), new Float32Array([-0.125, 0.125])];\nvar orthogonalEdges = [new Uint8Array([0, 0]), new Uint8Array([3, 0]), new Uint8Array([0, 3]), new Uint8Array([3, 3]), new Uint8Array([1, 0]), new Uint8Array([4, 0]), new Uint8Array([1, 3]), new Uint8Array([4, 3]), new Uint8Array([0, 1]), new Uint8Array([3, 1]), new Uint8Array([0, 4]), new Uint8Array([3, 4]), new Uint8Array([1, 1]), new Uint8Array([4, 1]), new Uint8Array([1, 4]), new Uint8Array([4, 4])];\nvar diagonalEdges = [new Uint8Array([0, 0]), new Uint8Array([1, 0]), new Uint8Array([0, 2]), new Uint8Array([1, 2]), new Uint8Array([2, 0]), new Uint8Array([3, 0]), new Uint8Array([2, 2]), new Uint8Array([3, 2]), new Uint8Array([0, 1]), new Uint8Array([1, 1]), new Uint8Array([0, 3]), new Uint8Array([1, 3]), new Uint8Array([2, 1]), new Uint8Array([3, 1]), new Uint8Array([2, 3]), new Uint8Array([3, 3])];\n\nfunction lerp(a, b, p) {\n  return a + (b - a) * p;\n}\n\nfunction saturate(a) {\n  return Math.min(Math.max(a, 0), 1);\n}\n\nfunction smoothArea(d) {\n  var a1 = area[0];\n  var a2 = area[1];\n  var b1X = Math.sqrt(a1[0] * 2) * 0.5;\n  var b1Y = Math.sqrt(a1[1] * 2) * 0.5;\n  var b2X = Math.sqrt(a2[0] * 2) * 0.5;\n  var b2Y = Math.sqrt(a2[1] * 2) * 0.5;\n  var p = saturate(d / SMOOTH_MAX_DISTANCE);\n  a1[0] = lerp(b1X, a1[0], p);\n  a1[1] = lerp(b1Y, a1[1], p);\n  a2[0] = lerp(b2X, a2[0], p);\n  a2[1] = lerp(b2Y, a2[1], p);\n}\n\nfunction calculateOrthogonalArea(p1X, p1Y, p2X, p2Y, x, result) {\n  var dX = p2X - p1X;\n  var dY = p2Y - p1Y;\n  var x1 = x;\n  var x2 = x + 1;\n  var y1 = p1Y + dY * (x1 - p1X) / dX;\n  var y2 = p1Y + dY * (x2 - p1X) / dX;\n\n  if (x1 >= p1X && x1 < p2X || x2 > p1X && x2 <= p2X) {\n    if (Math.sign(y1) === Math.sign(y2) || Math.abs(y1) < 1e-4 || Math.abs(y2) < 1e-4) {\n      var a = (y1 + y2) / 2;\n\n      if (a < 0) {\n        result[0] = Math.abs(a);\n        result[1] = 0;\n      } else {\n        result[0] = 0;\n        result[1] = Math.abs(a);\n      }\n    } else {\n      var t = -p1Y * dX / dY + p1X;\n      var tInt = Math.trunc(t);\n      var a1 = t > p1X ? y1 * (t - tInt) / 2 : 0;\n      var a2 = t < p2X ? y2 * (1 - (t - tInt)) / 2 : 0;\n\n      var _a = Math.abs(a1) > Math.abs(a2) ? a1 : -a2;\n\n      if (_a < 0) {\n        result[0] = Math.abs(a1);\n        result[1] = Math.abs(a2);\n      } else {\n        result[0] = Math.abs(a2);\n        result[1] = Math.abs(a1);\n      }\n    }\n  } else {\n    result[0] = 0;\n    result[1] = 0;\n  }\n\n  return result;\n}\n\nfunction calculateOrthogonalAreaForPattern(pattern, left, right, offset, result) {\n  var a1 = area[0];\n  var a2 = area[1];\n  var o1 = 0.5 + offset;\n  var o2 = 0.5 + offset - 1;\n  var d = left + right + 1;\n\n  switch (pattern) {\n    case 0:\n      {\n        result[0] = 0;\n        result[1] = 0;\n        break;\n      }\n\n    case 1:\n      {\n        if (left <= right) {\n          calculateOrthogonalArea(0, o2, d / 2, 0, left, result);\n        } else {\n          result[0] = 0;\n          result[1] = 0;\n        }\n\n        break;\n      }\n\n    case 2:\n      {\n        if (left >= right) {\n          calculateOrthogonalArea(d / 2, 0, d, o2, left, result);\n        } else {\n          result[0] = 0;\n          result[1] = 0;\n        }\n\n        break;\n      }\n\n    case 3:\n      {\n        calculateOrthogonalArea(0, o2, d / 2, 0, left, a1);\n        calculateOrthogonalArea(d / 2, 0, d, o2, left, a2);\n        smoothArea(d, area);\n        result[0] = a1[0] + a2[0];\n        result[1] = a1[1] + a2[1];\n        break;\n      }\n\n    case 4:\n      {\n        if (left <= right) {\n          calculateOrthogonalArea(0, o1, d / 2, 0, left, result);\n        } else {\n          result[0] = 0;\n          result[1] = 0;\n        }\n\n        break;\n      }\n\n    case 5:\n      {\n        result[0] = 0;\n        result[1] = 0;\n        break;\n      }\n\n    case 6:\n      {\n        if (Math.abs(offset) > 0) {\n          calculateOrthogonalArea(0, o1, d, o2, left, a1);\n          calculateOrthogonalArea(0, o1, d / 2, 0, left, a2);\n          calculateOrthogonalArea(d / 2, 0, d, o2, left, result);\n          a2[0] = a2[0] + result[0];\n          a2[1] = a2[1] + result[1];\n          result[0] = (a1[0] + a2[0]) / 2;\n          result[1] = (a1[1] + a2[1]) / 2;\n        } else {\n          calculateOrthogonalArea(0, o1, d, o2, left, result);\n        }\n\n        break;\n      }\n\n    case 7:\n      {\n        calculateOrthogonalArea(0, o1, d, o2, left, result);\n        break;\n      }\n\n    case 8:\n      {\n        if (left >= right) {\n          calculateOrthogonalArea(d / 2, 0, d, o1, left, result);\n        } else {\n          result[0] = 0;\n          result[1] = 0;\n        }\n\n        break;\n      }\n\n    case 9:\n      {\n        if (Math.abs(offset) > 0) {\n          calculateOrthogonalArea(0, o2, d, o1, left, a1);\n          calculateOrthogonalArea(0, o2, d / 2, 0, left, a2);\n          calculateOrthogonalArea(d / 2, 0, d, o1, left, result);\n          a2[0] = a2[0] + result[0];\n          a2[1] = a2[1] + result[1];\n          result[0] = (a1[0] + a2[0]) / 2;\n          result[1] = (a1[1] + a2[1]) / 2;\n        } else {\n          calculateOrthogonalArea(0, o2, d, o1, left, result);\n        }\n\n        break;\n      }\n\n    case 10:\n      {\n        result[0] = 0;\n        result[1] = 0;\n        break;\n      }\n\n    case 11:\n      {\n        calculateOrthogonalArea(0, o2, d, o1, left, result);\n        break;\n      }\n\n    case 12:\n      {\n        calculateOrthogonalArea(0, o1, d / 2, 0, left, a1);\n        calculateOrthogonalArea(d / 2, 0, d, o1, left, a2);\n        smoothArea(d, area);\n        result[0] = a1[0] + a2[0];\n        result[1] = a1[1] + a2[1];\n        break;\n      }\n\n    case 13:\n      {\n        calculateOrthogonalArea(0, o2, d, o1, left, result);\n        break;\n      }\n\n    case 14:\n      {\n        calculateOrthogonalArea(0, o1, d, o2, left, result);\n        break;\n      }\n\n    case 15:\n      {\n        result[0] = 0;\n        result[1] = 0;\n        break;\n      }\n  }\n\n  return result;\n}\n\nfunction isInsideArea(a1X, a1Y, a2X, a2Y, x, y) {\n  var result = a1X === a2X && a1Y === a2Y;\n\n  if (!result) {\n    var xm = (a1X + a2X) / 2;\n    var ym = (a1Y + a2Y) / 2;\n    var a = a2Y - a1Y;\n    var b = a1X - a2X;\n    var c2 = a * (x - xm) + b * (y - ym);\n    result = c2 > 0;\n  }\n\n  return result;\n}\n\nfunction calculateDiagonalAreaForPixel(a1X, a1Y, a2X, a2Y, pX, pY) {\n  var n = 0;\n\n  for (var y = 0; y < DIAGONAL_SAMPLES; ++y) {\n    for (var x = 0; x < DIAGONAL_SAMPLES; ++x) {\n      var offsetX = x / (DIAGONAL_SAMPLES - 1);\n      var offsetY = y / (DIAGONAL_SAMPLES - 1);\n\n      if (isInsideArea(a1X, a1Y, a2X, a2Y, pX + offsetX, pY + offsetY)) {\n        ++n;\n      }\n    }\n  }\n\n  return n / (DIAGONAL_SAMPLES * DIAGONAL_SAMPLES);\n}\n\nfunction calculateDiagonalArea(pattern, a1X, a1Y, a2X, a2Y, left, offset, result) {\n  var e = diagonalEdges[pattern];\n  var e1 = e[0];\n  var e2 = e[1];\n\n  if (e1 > 0) {\n    a1X += offset[0];\n    a1Y += offset[1];\n  }\n\n  if (e2 > 0) {\n    a2X += offset[0];\n    a2Y += offset[1];\n  }\n\n  result[0] = 1 - calculateDiagonalAreaForPixel(a1X, a1Y, a2X, a2Y, 1 + left, 0 + left);\n  result[1] = calculateDiagonalAreaForPixel(a1X, a1Y, a2X, a2Y, 1 + left, 1 + left);\n  return result;\n}\n\nfunction calculateDiagonalAreaForPattern(pattern, left, right, offset, result) {\n  var a1 = area[0];\n  var a2 = area[1];\n  var d = left + right + 1;\n\n  switch (pattern) {\n    case 0:\n      {\n        calculateDiagonalArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n        calculateDiagonalArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n        result[0] = (a1[0] + a2[0]) / 2;\n        result[1] = (a1[1] + a2[1]) / 2;\n        break;\n      }\n\n    case 1:\n      {\n        calculateDiagonalArea(pattern, 1, 0, 0 + d, 0 + d, left, offset, a1);\n        calculateDiagonalArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n        result[0] = (a1[0] + a2[0]) / 2;\n        result[1] = (a1[1] + a2[1]) / 2;\n        break;\n      }\n\n    case 2:\n      {\n        calculateDiagonalArea(pattern, 0, 0, 1 + d, 0 + d, left, offset, a1);\n        calculateDiagonalArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n        result[0] = (a1[0] + a2[0]) / 2;\n        result[1] = (a1[1] + a2[1]) / 2;\n        break;\n      }\n\n    case 3:\n      {\n        calculateDiagonalArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, result);\n        break;\n      }\n\n    case 4:\n      {\n        calculateDiagonalArea(pattern, 1, 1, 0 + d, 0 + d, left, offset, a1);\n        calculateDiagonalArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a2);\n        result[0] = (a1[0] + a2[0]) / 2;\n        result[1] = (a1[1] + a2[1]) / 2;\n        break;\n      }\n\n    case 5:\n      {\n        calculateDiagonalArea(pattern, 1, 1, 0 + d, 0 + d, left, offset, a1);\n        calculateDiagonalArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n        result[0] = (a1[0] + a2[0]) / 2;\n        result[1] = (a1[1] + a2[1]) / 2;\n        break;\n      }\n\n    case 6:\n      {\n        calculateDiagonalArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, result);\n        break;\n      }\n\n    case 7:\n      {\n        calculateDiagonalArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a1);\n        calculateDiagonalArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n        result[0] = (a1[0] + a2[0]) / 2;\n        result[1] = (a1[1] + a2[1]) / 2;\n        break;\n      }\n\n    case 8:\n      {\n        calculateDiagonalArea(pattern, 0, 0, 1 + d, 1 + d, left, offset, a1);\n        calculateDiagonalArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a2);\n        result[0] = (a1[0] + a2[0]) / 2;\n        result[1] = (a1[1] + a2[1]) / 2;\n        break;\n      }\n\n    case 9:\n      {\n        calculateDiagonalArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, result);\n        calculateDiagonalArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, result);\n        break;\n      }\n\n    case 10:\n      {\n        calculateDiagonalArea(pattern, 0, 0, 1 + d, 1 + d, left, offset, a1);\n        calculateDiagonalArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n        result[0] = (a1[0] + a2[0]) / 2;\n        result[1] = (a1[1] + a2[1]) / 2;\n        break;\n      }\n\n    case 11:\n      {\n        calculateDiagonalArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a1);\n        calculateDiagonalArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n        result[0] = (a1[0] + a2[0]) / 2;\n        result[1] = (a1[1] + a2[1]) / 2;\n        break;\n      }\n\n    case 12:\n      {\n        calculateDiagonalArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, result);\n        break;\n      }\n\n    case 13:\n      {\n        calculateDiagonalArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n        calculateDiagonalArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a2);\n        result[0] = (a1[0] + a2[0]) / 2;\n        result[1] = (a1[1] + a2[1]) / 2;\n        break;\n      }\n\n    case 14:\n      {\n        calculateDiagonalArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n        calculateDiagonalArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a2);\n        result[0] = (a1[0] + a2[0]) / 2;\n        result[1] = (a1[1] + a2[1]) / 2;\n        break;\n      }\n\n    case 15:\n      {\n        calculateDiagonalArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n        calculateDiagonalArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n        result[0] = (a1[0] + a2[0]) / 2;\n        result[1] = (a1[1] + a2[1]) / 2;\n        break;\n      }\n  }\n\n  return result;\n}\n\nfunction generatePatterns(patterns, offset, orthogonal) {\n  var result = new Float32Array(2);\n\n  for (var i = 0, l = patterns.length; i < l; ++i) {\n    var pattern = patterns[i];\n    var data = pattern.data;\n    var size = pattern.width;\n\n    for (var y = 0; y < size; ++y) {\n      for (var x = 0; x < size; ++x) {\n        if (orthogonal) {\n          calculateOrthogonalAreaForPattern(i, x, y, offset, result);\n        } else {\n          calculateDiagonalAreaForPattern(i, x, y, offset, result);\n        }\n\n        var c2 = (y * size + x) * 2;\n        data[c2] = result[0] * 255;\n        data[c2 + 1] = result[1] * 255;\n      }\n    }\n  }\n}\n\nfunction assemble(baseX, baseY, patterns, edges2, size, orthogonal, target) {\n  var dstData = target.data;\n  var dstWidth = target.width;\n\n  for (var i = 0, l = patterns.length; i < l; ++i) {\n    var edge = edges2[i];\n    var pattern = patterns[i];\n    var srcData = pattern.data;\n    var srcWidth = pattern.width;\n\n    for (var y = 0; y < size; ++y) {\n      for (var x = 0; x < size; ++x) {\n        var pX = edge[0] * size + baseX + x;\n        var pY = edge[1] * size + baseY + y;\n        var c2 = (pY * dstWidth + pX) * 4;\n        var d = orthogonal ? (y * y * srcWidth + x * x) * 2 : (y * srcWidth + x) * 2;\n        dstData[c2] = srcData[d];\n        dstData[c2 + 1] = srcData[d + 1];\n        dstData[c2 + 2] = 0;\n        dstData[c2 + 3] = 255;\n      }\n    }\n  }\n}\n\nvar SMAAAreaImageData = /*#__PURE__*/function () {\n  function SMAAAreaImageData() {\n    _classCallCheck(this, SMAAAreaImageData);\n  }\n\n  _createClass(SMAAAreaImageData, null, [{\n    key: \"generate\",\n    value: function generate() {\n      var width = 2 * 5 * ORTHOGONAL_SIZE;\n      var height = orthogonalSubsamplingOffsets.length * 5 * ORTHOGONAL_SIZE;\n      var data = new Uint8ClampedArray(width * height * 4);\n      var result = new RawImageData(width, height, data);\n      var orthogonalPatternSize = Math.pow(ORTHOGONAL_SIZE - 1, 2) + 1;\n      var diagonalPatternSize = DIAGONAL_SIZE;\n      var orthogonalPatterns = [];\n      var diagonalPatterns = [];\n\n      for (var i = 3, l = data.length; i < l; i += 4) {\n        data[i] = 255;\n      }\n\n      for (var _i9 = 0; _i9 < 16; ++_i9) {\n        orthogonalPatterns.push(new RawImageData(orthogonalPatternSize, orthogonalPatternSize, new Uint8ClampedArray(orthogonalPatternSize * orthogonalPatternSize * 2), 2));\n        diagonalPatterns.push(new RawImageData(diagonalPatternSize, diagonalPatternSize, new Uint8ClampedArray(diagonalPatternSize * diagonalPatternSize * 2), 2));\n      }\n\n      for (var _i10 = 0, _l2 = orthogonalSubsamplingOffsets.length; _i10 < _l2; ++_i10) {\n        generatePatterns(orthogonalPatterns, orthogonalSubsamplingOffsets[_i10], true);\n        assemble(0, 5 * ORTHOGONAL_SIZE * _i10, orthogonalPatterns, orthogonalEdges, ORTHOGONAL_SIZE, true, result);\n      }\n\n      for (var _i11 = 0, _l3 = diagonalSubsamplingOffsets.length; _i11 < _l3; ++_i11) {\n        generatePatterns(diagonalPatterns, diagonalSubsamplingOffsets[_i11], false);\n        assemble(5 * ORTHOGONAL_SIZE, 4 * DIAGONAL_SIZE * _i11, diagonalPatterns, diagonalEdges, DIAGONAL_SIZE, false, result);\n      }\n\n      return result;\n    }\n  }]);\n\n  return SMAAAreaImageData;\n}(); // src/images/smaa/SMAAImageGenerator.js\n\n\nimport { LoadingManager } from \"three\"; // tmp/smaa.worker\n\nvar smaa_default = '(()=>{function _(t,a,s){let i=document.createElementNS(\"http://www.w3.org/1999/xhtml\",\"canvas\"),n=i.getContext(\"2d\");if(i.width=t,i.height=a,s instanceof Image)n.drawImage(s,0,0);else{let o=n.createImageData(t,a);o.data.set(s),n.putImageData(o,0,0)}return i}var k=class{constructor(a=0,s=0,i=null){this.width=a,this.height=s,this.data=i}toCanvas(){return typeof document==\"undefined\"?null:_(this.width,this.height,this.data)}static from(a){let{width:s,height:i}=a,n;if(a instanceof Image){let o=_(s,i,a);o!==null&&(n=o.getContext(\"2d\").getImageData(0,0,s,i).data)}else n=a.data;return new k(s,i,n)}};var F=[new Float32Array(2),new Float32Array(2)],I=16,P=20,x=30,z=32,E=new Float32Array([0,-.25,.25,-.125,.125,-.375,.375]),q=[new Float32Array([0,0]),new Float32Array([.25,-.25]),new Float32Array([-.25,.25]),new Float32Array([.125,-.125]),new Float32Array([-.125,.125])],B=[new Uint8Array([0,0]),new Uint8Array([3,0]),new Uint8Array([0,3]),new Uint8Array([3,3]),new Uint8Array([1,0]),new Uint8Array([4,0]),new Uint8Array([1,3]),new Uint8Array([4,3]),new Uint8Array([0,1]),new Uint8Array([3,1]),new Uint8Array([0,4]),new Uint8Array([3,4]),new Uint8Array([1,1]),new Uint8Array([4,1]),new Uint8Array([1,4]),new Uint8Array([4,4])],W=[new Uint8Array([0,0]),new Uint8Array([1,0]),new Uint8Array([0,2]),new Uint8Array([1,2]),new Uint8Array([2,0]),new Uint8Array([3,0]),new Uint8Array([2,2]),new Uint8Array([3,2]),new Uint8Array([0,1]),new Uint8Array([1,1]),new Uint8Array([0,3]),new Uint8Array([1,3]),new Uint8Array([2,1]),new Uint8Array([3,1]),new Uint8Array([2,3]),new Uint8Array([3,3])];function O(t,a,s){return t+(a-t)*s}function J(t){return Math.min(Math.max(t,0),1)}function G(t){let a=F[0],s=F[1],i=Math.sqrt(a[0]*2)*.5,n=Math.sqrt(a[1]*2)*.5,o=Math.sqrt(s[0]*2)*.5,r=Math.sqrt(s[1]*2)*.5,c=J(t/z);a[0]=O(i,a[0],c),a[1]=O(n,a[1],c),s[0]=O(o,s[0],c),s[1]=O(r,s[1],c)}function y(t,a,s,i,n,o){let r=s-t,c=i-a,w=n,e=n+1,A=a+c*(w-t)/r,g=a+c*(e-t)/r;if(w>=t&&w<s||e>t&&e<=s)if(Math.sign(A)===Math.sign(g)||Math.abs(A)<1e-4||Math.abs(g)<1e-4){let b=(A+g)/2;b<0?(o[0]=Math.abs(b),o[1]=0):(o[0]=0,o[1]=Math.abs(b))}else{let b=-a*r/c+t,M=Math.trunc(b),U=b>t?A*(b-M)/2:0,m=b<s?g*(1-(b-M))/2:0;(Math.abs(U)>Math.abs(m)?U:-m)<0?(o[0]=Math.abs(U),o[1]=Math.abs(m)):(o[0]=Math.abs(m),o[1]=Math.abs(U))}else o[0]=0,o[1]=0;return o}function K(t,a,s,i,n){let o=F[0],r=F[1],c=.5+i,w=.5+i-1,e=a+s+1;switch(t){case 0:{n[0]=0,n[1]=0;break}case 1:{a<=s?y(0,w,e/2,0,a,n):(n[0]=0,n[1]=0);break}case 2:{a>=s?y(e/2,0,e,w,a,n):(n[0]=0,n[1]=0);break}case 3:{y(0,w,e/2,0,a,o),y(e/2,0,e,w,a,r),G(e,F),n[0]=o[0]+r[0],n[1]=o[1]+r[1];break}case 4:{a<=s?y(0,c,e/2,0,a,n):(n[0]=0,n[1]=0);break}case 5:{n[0]=0,n[1]=0;break}case 6:{Math.abs(i)>0?(y(0,c,e,w,a,o),y(0,c,e/2,0,a,r),y(e/2,0,e,w,a,n),r[0]=r[0]+n[0],r[1]=r[1]+n[1],n[0]=(o[0]+r[0])/2,n[1]=(o[1]+r[1])/2):y(0,c,e,w,a,n);break}case 7:{y(0,c,e,w,a,n);break}case 8:{a>=s?y(e/2,0,e,c,a,n):(n[0]=0,n[1]=0);break}case 9:{Math.abs(i)>0?(y(0,w,e,c,a,o),y(0,w,e/2,0,a,r),y(e/2,0,e,c,a,n),r[0]=r[0]+n[0],r[1]=r[1]+n[1],n[0]=(o[0]+r[0])/2,n[1]=(o[1]+r[1])/2):y(0,w,e,c,a,n);break}case 10:{n[0]=0,n[1]=0;break}case 11:{y(0,w,e,c,a,n);break}case 12:{y(0,c,e/2,0,a,o),y(e/2,0,e,c,a,r),G(e,F),n[0]=o[0]+r[0],n[1]=o[1]+r[1];break}case 13:{y(0,w,e,c,a,n);break}case 14:{y(0,c,e,w,a,n);break}case 15:{n[0]=0,n[1]=0;break}}return n}function Q(t,a,s,i,n,o){let r=t===s&&a===i;if(!r){let c=(t+s)/2,w=(a+i)/2,e=i-a,A=t-s;r=e*(n-c)+A*(o-w)>0}return r}function H(t,a,s,i,n,o){let r=0;for(let c=0;c<x;++c)for(let w=0;w<x;++w){let e=w/(x-1),A=c/(x-1);Q(t,a,s,i,n+e,o+A)&&++r}return r/(x*x)}function h(t,a,s,i,n,o,r,c){let w=W[t],e=w[0],A=w[1];return e>0&&(a+=r[0],s+=r[1]),A>0&&(i+=r[0],n+=r[1]),c[0]=1-H(a,s,i,n,1+o,0+o),c[1]=H(a,s,i,n,1+o,1+o),c}function V(t,a,s,i,n){let o=F[0],r=F[1],c=a+s+1;switch(t){case 0:{h(t,1,1,1+c,1+c,a,i,o),h(t,1,0,1+c,0+c,a,i,r),n[0]=(o[0]+r[0])/2,n[1]=(o[1]+r[1])/2;break}case 1:{h(t,1,0,0+c,0+c,a,i,o),h(t,1,0,1+c,0+c,a,i,r),n[0]=(o[0]+r[0])/2,n[1]=(o[1]+r[1])/2;break}case 2:{h(t,0,0,1+c,0+c,a,i,o),h(t,1,0,1+c,0+c,a,i,r),n[0]=(o[0]+r[0])/2,n[1]=(o[1]+r[1])/2;break}case 3:{h(t,1,0,1+c,0+c,a,i,n);break}case 4:{h(t,1,1,0+c,0+c,a,i,o),h(t,1,1,1+c,0+c,a,i,r),n[0]=(o[0]+r[0])/2,n[1]=(o[1]+r[1])/2;break}case 5:{h(t,1,1,0+c,0+c,a,i,o),h(t,1,0,1+c,0+c,a,i,r),n[0]=(o[0]+r[0])/2,n[1]=(o[1]+r[1])/2;break}case 6:{h(t,1,1,1+c,0+c,a,i,n);break}case 7:{h(t,1,1,1+c,0+c,a,i,o),h(t,1,0,1+c,0+c,a,i,r),n[0]=(o[0]+r[0])/2,n[1]=(o[1]+r[1])/2;break}case 8:{h(t,0,0,1+c,1+c,a,i,o),h(t,1,0,1+c,1+c,a,i,r),n[0]=(o[0]+r[0])/2,n[1]=(o[1]+r[1])/2;break}case 9:{h(t,1,0,1+c,1+c,a,i,n),h(t,1,0,1+c,1+c,a,i,n);break}case 10:{h(t,0,0,1+c,1+c,a,i,o),h(t,1,0,1+c,0+c,a,i,r),n[0]=(o[0]+r[0])/2,n[1]=(o[1]+r[1])/2;break}case 11:{h(t,1,0,1+c,1+c,a,i,o),h(t,1,0,1+c,0+c,a,i,r),n[0]=(o[0]+r[0])/2,n[1]=(o[1]+r[1])/2;break}case 12:{h(t,1,1,1+c,1+c,a,i,n);break}case 13:{h(t,1,1,1+c,1+c,a,i,o),h(t,1,0,1+c,1+c,a,i,r),n[0]=(o[0]+r[0])/2,n[1]=(o[1]+r[1])/2;break}case 14:{h(t,1,1,1+c,1+c,a,i,o),h(t,1,1,1+c,0+c,a,i,r),n[0]=(o[0]+r[0])/2,n[1]=(o[1]+r[1])/2;break}case 15:{h(t,1,1,1+c,1+c,a,i,o),h(t,1,0,1+c,0+c,a,i,r),n[0]=(o[0]+r[0])/2,n[1]=(o[1]+r[1])/2;break}}return n}function T(t,a,s){let i=new Float32Array(2);for(let n=0,o=t.length;n<o;++n){let r=t[n],c=r.data,w=r.width;for(let e=0;e<w;++e)for(let A=0;A<w;++A){s?K(n,A,e,a,i):V(n,A,e,a,i);let g=(e*w+A)*2;c[g]=i[0]*255,c[g+1]=i[1]*255}}}function Z(t,a,s,i,n,o,r){let c=r.data,w=r.width;for(let e=0,A=s.length;e<A;++e){let g=i[e],b=s[e],M=b.data,U=b.width;for(let m=0;m<n;++m)for(let D=0;D<n;++D){let j=g[0]*n+t+D,S=((g[1]*n+a+m)*w+j)*4,R=o?(m*m*U+D*D)*2:(m*U+D)*2;c[S]=M[R],c[S+1]=M[R+1],c[S+2]=0,c[S+3]=255}}}var v=class{static generate(){let a=2*5*I,s=E.length*5*I,i=new Uint8ClampedArray(a*s*4),n=new k(a,s,i),o=Math.pow(I-1,2)+1,r=P,c=[],w=[];for(let e=3,A=i.length;e<A;e+=4)i[e]=255;for(let e=0;e<16;++e)c.push(new k(o,o,new Uint8ClampedArray(o*o*2),2)),w.push(new k(r,r,new Uint8ClampedArray(r*r*2),2));for(let e=0,A=E.length;e<A;++e)T(c,E[e],!0),Z(0,5*I*e,c,B,I,!0,n);for(let e=0,A=q.length;e<A;++e)T(w,q[e],!1),Z(5*I,4*P*e,w,W,P,!1,n);return n}};var C=new Map([[d(0,0,0,0),new Float32Array([0,0,0,0])],[d(0,0,0,1),new Float32Array([0,0,0,1])],[d(0,0,1,0),new Float32Array([0,0,1,0])],[d(0,0,1,1),new Float32Array([0,0,1,1])],[d(0,1,0,0),new Float32Array([0,1,0,0])],[d(0,1,0,1),new Float32Array([0,1,0,1])],[d(0,1,1,0),new Float32Array([0,1,1,0])],[d(0,1,1,1),new Float32Array([0,1,1,1])],[d(1,0,0,0),new Float32Array([1,0,0,0])],[d(1,0,0,1),new Float32Array([1,0,0,1])],[d(1,0,1,0),new Float32Array([1,0,1,0])],[d(1,0,1,1),new Float32Array([1,0,1,1])],[d(1,1,0,0),new Float32Array([1,1,0,0])],[d(1,1,0,1),new Float32Array([1,1,0,1])],[d(1,1,1,0),new Float32Array([1,1,1,0])],[d(1,1,1,1),new Float32Array([1,1,1,1])]]);function L(t,a,s){return t+(a-t)*s}function d(t,a,s,i){let n=L(t,a,1-.25),o=L(s,i,1-.25);return L(n,o,1-.125)}function $(t,a){let s=0;return a[3]===1&&(s+=1),s===1&&a[2]===1&&t[1]!==1&&t[3]!==1&&(s+=1),s}function Y(t,a){let s=0;return a[3]===1&&t[1]!==1&&t[3]!==1&&(s+=1),s===1&&a[2]===1&&t[0]!==1&&t[2]!==1&&(s+=1),s}var N=class{static generate(){let a=66,s=33,i=a/2,n=64,o=16,r=new Uint8ClampedArray(a*s),c=new Uint8ClampedArray(n*o*4);for(let w=0;w<s;++w)for(let e=0;e<a;++e){let A=.03125*e,g=.03125*w;if(C.has(A)&&C.has(g)){let b=C.get(A),M=C.get(g),U=w*a+e;r[U]=127*$(b,M),r[U+i]=127*Y(b,M)}}for(let w=0,e=s-o;e<s;++e)for(let A=0;A<n;++A,w+=4)c[w]=r[e*a+A],c[w+3]=255;return new k(n,o,c)}};self.addEventListener(\"message\",t=>{let a=v.generate(),s=N.generate();postMessage({areaImageData:a,searchImageData:s},[a.data.buffer,s.data.buffer]),close()});})();\\n'; // src/images/smaa/SMAAImageGenerator.js\n\nfunction _generate() {\n  var useCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var workerURL = URL.createObjectURL(new Blob([smaa_default], {\n    type: \"text/javascript\"\n  }));\n  var worker = new Worker(workerURL);\n  URL.revokeObjectURL(workerURL);\n  return new Promise(function (resolve, reject) {\n    worker.addEventListener(\"error\", function (event) {\n      return reject(event.error);\n    });\n    worker.addEventListener(\"message\", function (event) {\n      var searchImageData = RawImageData.from(event.data.searchImageData);\n      var areaImageData = RawImageData.from(event.data.areaImageData);\n      var urls = [searchImageData.toCanvas().toDataURL(\"image/png\", 1), areaImageData.toCanvas().toDataURL(\"image/png\", 1)];\n\n      if (useCache) {\n        localStorage.setItem(\"smaa-search\", urls[0]);\n        localStorage.setItem(\"smaa-area\", urls[1]);\n      }\n\n      resolve(urls);\n    });\n    worker.postMessage(null);\n  });\n}\n\nvar SMAAImageGenerator = /*#__PURE__*/function () {\n  function SMAAImageGenerator() {\n    _classCallCheck(this, SMAAImageGenerator);\n\n    this.disableCache = false;\n  }\n\n  _createClass(SMAAImageGenerator, [{\n    key: \"generate\",\n    value: function generate() {\n      var useCache = !this.disableCache && window.localStorage !== void 0;\n      var cachedURLs = useCache ? [localStorage.getItem(\"smaa-search\"), localStorage.getItem(\"smaa-area\")] : [null, null];\n      var promise = cachedURLs[0] !== null && cachedURLs[1] !== null ? Promise.resolve(cachedURLs) : _generate(useCache);\n      return promise.then(function (urls) {\n        return new Promise(function (resolve, reject) {\n          var searchImage = new Image();\n          var areaImage = new Image();\n          var manager = new LoadingManager();\n\n          manager.onLoad = function () {\n            return resolve([searchImage, areaImage]);\n          };\n\n          manager.onError = reject;\n          searchImage.addEventListener(\"error\", function (e) {\n            return manager.itemError(\"smaa-search\");\n          });\n          areaImage.addEventListener(\"error\", function (e) {\n            return manager.itemError(\"smaa-area\");\n          });\n          searchImage.addEventListener(\"load\", function () {\n            return manager.itemEnd(\"smaa-search\");\n          });\n          areaImage.addEventListener(\"load\", function () {\n            return manager.itemEnd(\"smaa-area\");\n          });\n          manager.itemStart(\"smaa-search\");\n          manager.itemStart(\"smaa-area\");\n          searchImage.src = urls[0];\n          areaImage.src = urls[1];\n        });\n      });\n    }\n  }]);\n\n  return SMAAImageGenerator;\n}(); // src/images/smaa/SMAASearchImageData.js\n\n\nvar edges = new Map([[bilinear(0, 0, 0, 0), new Float32Array([0, 0, 0, 0])], [bilinear(0, 0, 0, 1), new Float32Array([0, 0, 0, 1])], [bilinear(0, 0, 1, 0), new Float32Array([0, 0, 1, 0])], [bilinear(0, 0, 1, 1), new Float32Array([0, 0, 1, 1])], [bilinear(0, 1, 0, 0), new Float32Array([0, 1, 0, 0])], [bilinear(0, 1, 0, 1), new Float32Array([0, 1, 0, 1])], [bilinear(0, 1, 1, 0), new Float32Array([0, 1, 1, 0])], [bilinear(0, 1, 1, 1), new Float32Array([0, 1, 1, 1])], [bilinear(1, 0, 0, 0), new Float32Array([1, 0, 0, 0])], [bilinear(1, 0, 0, 1), new Float32Array([1, 0, 0, 1])], [bilinear(1, 0, 1, 0), new Float32Array([1, 0, 1, 0])], [bilinear(1, 0, 1, 1), new Float32Array([1, 0, 1, 1])], [bilinear(1, 1, 0, 0), new Float32Array([1, 1, 0, 0])], [bilinear(1, 1, 0, 1), new Float32Array([1, 1, 0, 1])], [bilinear(1, 1, 1, 0), new Float32Array([1, 1, 1, 0])], [bilinear(1, 1, 1, 1), new Float32Array([1, 1, 1, 1])]]);\n\nfunction lerp2(a, b, p) {\n  return a + (b - a) * p;\n}\n\nfunction bilinear(e0, e1, e2, e3) {\n  var a = lerp2(e0, e1, 1 - 0.25);\n  var b = lerp2(e2, e3, 1 - 0.25);\n  return lerp2(a, b, 1 - 0.125);\n}\n\nfunction deltaLeft(left, top) {\n  var d = 0;\n\n  if (top[3] === 1) {\n    d += 1;\n  }\n\n  if (d === 1 && top[2] === 1 && left[1] !== 1 && left[3] !== 1) {\n    d += 1;\n  }\n\n  return d;\n}\n\nfunction deltaRight(left, top) {\n  var d = 0;\n\n  if (top[3] === 1 && left[1] !== 1 && left[3] !== 1) {\n    d += 1;\n  }\n\n  if (d === 1 && top[2] === 1 && left[0] !== 1 && left[2] !== 1) {\n    d += 1;\n  }\n\n  return d;\n}\n\nvar SMAASearchImageData = /*#__PURE__*/function () {\n  function SMAASearchImageData() {\n    _classCallCheck(this, SMAASearchImageData);\n  }\n\n  _createClass(SMAASearchImageData, null, [{\n    key: \"generate\",\n    value: function generate() {\n      var width = 66;\n      var height = 33;\n      var halfWidth = width / 2;\n      var croppedWidth = 64;\n      var croppedHeight = 16;\n      var data = new Uint8ClampedArray(width * height);\n      var croppedData = new Uint8ClampedArray(croppedWidth * croppedHeight * 4);\n\n      for (var y = 0; y < height; ++y) {\n        for (var x = 0; x < width; ++x) {\n          var s = 0.03125 * x;\n          var t = 0.03125 * y;\n\n          if (edges.has(s) && edges.has(t)) {\n            var e1 = edges.get(s);\n            var e2 = edges.get(t);\n            var i = y * width + x;\n            data[i] = 127 * deltaLeft(e1, e2);\n            data[i + halfWidth] = 127 * deltaRight(e1, e2);\n          }\n        }\n      }\n\n      for (var _i12 = 0, _y = height - croppedHeight; _y < height; ++_y) {\n        for (var _x = 0; _x < croppedWidth; ++_x, _i12 += 4) {\n          croppedData[_i12] = data[_y * width + _x];\n          croppedData[_i12 + 3] = 255;\n        }\n      }\n\n      return new RawImageData(croppedWidth, croppedHeight, croppedData);\n    }\n  }]);\n\n  return SMAASearchImageData;\n}(); // src/loaders/LUT3dlLoader.js\n\n\nimport { FileLoader, Loader, LoadingManager as LoadingManager2, sRGBEncoding as sRGBEncoding4 } from \"three\";\n\nvar LUT3dlLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(LUT3dlLoader, _Loader);\n\n  var _super65 = _createSuper(LUT3dlLoader);\n\n  function LUT3dlLoader() {\n    _classCallCheck(this, LUT3dlLoader);\n\n    return _super65.apply(this, arguments);\n  }\n\n  _createClass(LUT3dlLoader, [{\n    key: \"load\",\n    value: function load(url) {\n      var _this61 = this;\n\n      var onLoad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n      var onProgress = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n      var onError = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var externalManager = this.manager;\n      var internalManager = new LoadingManager2();\n      var loader = new FileLoader(internalManager);\n      loader.setPath(this.path);\n      loader.setResponseType(\"text\");\n      return new Promise(function (resolve, reject) {\n        internalManager.onError = function (url2) {\n          externalManager.itemError(url2);\n\n          if (onError !== null) {\n            onError(\"Failed to load \".concat(url2));\n            resolve();\n          } else {\n            reject(\"Failed to load \".concat(url2));\n          }\n        };\n\n        externalManager.itemStart(url);\n        loader.load(url, function (data) {\n          try {\n            var result = _this61.parse(data);\n\n            externalManager.itemEnd(url);\n            onLoad(result);\n            resolve(result);\n          } catch (e) {\n            console.error(e);\n            internalManager.onError(url);\n          }\n        }, onProgress);\n      });\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(input) {\n      var regExpGridInfo = /^[\\d ]+$/m;\n      var regExpDataPoints = /^([\\d.]+) +([\\d.]+) +([\\d.]+) *$/gm;\n      var result = regExpGridInfo.exec(input);\n\n      if (result === null) {\n        throw new Error(\"Missing grid information\");\n      }\n\n      var gridLines = result[0].trim().split(/\\s+/g).map(function (n) {\n        return Number(n);\n      });\n      var gridStep = gridLines[1] - gridLines[0];\n      var size = gridLines.length;\n\n      for (var i = 1, l = gridLines.length; i < l; ++i) {\n        if (gridStep !== gridLines[i] - gridLines[i - 1]) {\n          throw new Error(\"Inconsistent grid size\");\n        }\n      }\n\n      var data = new Float32Array(Math.pow(size, 3) * 3);\n      var maxValue = 0;\n      var index = 0;\n\n      while ((result = regExpDataPoints.exec(input)) !== null) {\n        var r = Number(result[1]);\n        var g = Number(result[2]);\n        var b = Number(result[3]);\n        maxValue = Math.max(maxValue, r, g, b);\n        var bLayer = index % size;\n        var gLayer = Math.floor(index / size) % size;\n        var rLayer = Math.floor(index / (size * size)) % size;\n        var d3 = (bLayer * size * size + gLayer * size + rLayer) * 3;\n        data[d3 + 0] = r;\n        data[d3 + 1] = g;\n        data[d3 + 2] = b;\n        ++index;\n      }\n\n      var bits = Math.ceil(Math.log2(maxValue));\n      var maxBitValue = Math.pow(2, bits);\n\n      for (var _i13 = 0, _l4 = data.length; _i13 < _l4; ++_i13) {\n        data[_i13] /= maxBitValue;\n      }\n\n      var lut = new LookupTexture3D(data, size, size, size);\n      lut.encoding = sRGBEncoding4;\n      return lut;\n    }\n  }]);\n\n  return LUT3dlLoader;\n}(Loader); // src/loaders/LUTCubeLoader.js\n\n\nimport { FileLoader as FileLoader2, Loader as Loader2, LoadingManager as LoadingManager3, sRGBEncoding as sRGBEncoding5, Vector3 as Vector36 } from \"three\";\n\nvar LUTCubeLoader = /*#__PURE__*/function (_Loader2) {\n  _inherits(LUTCubeLoader, _Loader2);\n\n  var _super66 = _createSuper(LUTCubeLoader);\n\n  function LUTCubeLoader() {\n    _classCallCheck(this, LUTCubeLoader);\n\n    return _super66.apply(this, arguments);\n  }\n\n  _createClass(LUTCubeLoader, [{\n    key: \"load\",\n    value: function load(url) {\n      var _this62 = this;\n\n      var onLoad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n      var onProgress = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n      var onError = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var externalManager = this.manager;\n      var internalManager = new LoadingManager3();\n      var loader = new FileLoader2(internalManager);\n      loader.setPath(this.path);\n      loader.setResponseType(\"text\");\n      return new Promise(function (resolve, reject) {\n        internalManager.onError = function (url2) {\n          externalManager.itemError(url2);\n\n          if (onError !== null) {\n            onError(\"Failed to load \".concat(url2));\n            resolve();\n          } else {\n            reject(\"Failed to load \".concat(url2));\n          }\n        };\n\n        externalManager.itemStart(url);\n        loader.load(url, function (data) {\n          try {\n            var result = _this62.parse(data);\n\n            externalManager.itemEnd(url);\n            onLoad(result);\n            resolve(result);\n          } catch (e) {\n            console.error(e);\n            internalManager.onError(url);\n          }\n        }, onProgress);\n      });\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(input) {\n      var regExpTitle = /TITLE +\"([^\"]*)\"/;\n      var regExpSize = /LUT_3D_SIZE +(\\d+)/;\n      var regExpDomainMin = /DOMAIN_MIN +([\\d.]+) +([\\d.]+) +([\\d.]+)/;\n      var regExpDomainMax = /DOMAIN_MAX +([\\d.]+) +([\\d.]+) +([\\d.]+)/;\n      var regExpDataPoints = /^([\\d.]+) +([\\d.]+) +([\\d.]+) *$/gm;\n      var result = regExpTitle.exec(input);\n      var title = result !== null ? result[1] : null;\n      result = regExpSize.exec(input);\n\n      if (result === null) {\n        throw new Error(\"Missing LUT_3D_SIZE information\");\n      }\n\n      var size = Number(result[1]);\n      var data = new Float32Array(Math.pow(size, 3) * 3);\n      var domainMin = new Vector36(0, 0, 0);\n      var domainMax = new Vector36(1, 1, 1);\n      result = regExpDomainMin.exec(input);\n\n      if (result !== null) {\n        domainMin.set(Number(result[1]), Number(result[2]), Number(result[3]));\n      }\n\n      result = regExpDomainMax.exec(input);\n\n      if (result !== null) {\n        domainMax.set(Number(result[1]), Number(result[2]), Number(result[3]));\n      }\n\n      if (domainMin.x > domainMax.x || domainMin.y > domainMax.y || domainMin.z > domainMax.z) {\n        domainMin.set(0, 0, 0);\n        domainMax.set(1, 1, 1);\n        throw new Error(\"Invalid input domain\");\n      }\n\n      var i = 0;\n\n      while ((result = regExpDataPoints.exec(input)) !== null) {\n        data[i++] = Number(result[1]);\n        data[i++] = Number(result[2]);\n        data[i++] = Number(result[3]);\n      }\n\n      var lut = new LookupTexture3D(data, size, size, size);\n      lut.encoding = sRGBEncoding5;\n      lut.domainMin.copy(domainMin);\n      lut.domainMax.copy(domainMax);\n\n      if (title !== null) {\n        lut.name = title;\n      }\n\n      return lut;\n    }\n  }]);\n\n  return LUTCubeLoader;\n}(Loader2); // src/loaders/SMAAImageLoader.js\n\n\nimport { Loader as Loader3, LoadingManager as LoadingManager4 } from \"three\";\n\nvar SMAAImageLoader = /*#__PURE__*/function (_Loader3) {\n  _inherits(SMAAImageLoader, _Loader3);\n\n  var _super67 = _createSuper(SMAAImageLoader);\n\n  function SMAAImageLoader() {\n    _classCallCheck(this, SMAAImageLoader);\n\n    return _super67.apply(this, arguments);\n  }\n\n  _createClass(SMAAImageLoader, [{\n    key: \"load\",\n    value: function load() {\n      var onLoad = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n      var onError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (arguments.length === 4) {\n        onLoad = arguments[1];\n        onError = arguments[3];\n      } else if (arguments.length === 3 || typeof arguments[0] !== \"function\") {\n        onLoad = arguments[1];\n        onError = null;\n      }\n\n      var externalManager = this.manager;\n      var internalManager = new LoadingManager4();\n      return new Promise(function (resolve, reject) {\n        var searchImage = new Image();\n        var areaImage = new Image();\n\n        internalManager.onError = function (url) {\n          externalManager.itemError(url);\n\n          if (onError !== null) {\n            onError(\"Failed to load \".concat(url));\n            resolve();\n          } else {\n            reject(\"Failed to load \".concat(url));\n          }\n        };\n\n        internalManager.onLoad = function () {\n          var result = [searchImage, areaImage];\n          onLoad(result);\n          resolve(result);\n        };\n\n        searchImage.addEventListener(\"error\", function (e) {\n          internalManager.itemError(\"smaa-search\");\n        });\n        areaImage.addEventListener(\"error\", function (e) {\n          internalManager.itemError(\"smaa-area\");\n        });\n        searchImage.addEventListener(\"load\", function () {\n          externalManager.itemEnd(\"smaa-search\");\n          internalManager.itemEnd(\"smaa-search\");\n        });\n        areaImage.addEventListener(\"load\", function () {\n          externalManager.itemEnd(\"smaa-area\");\n          internalManager.itemEnd(\"smaa-area\");\n        });\n        externalManager.itemStart(\"smaa-search\");\n        externalManager.itemStart(\"smaa-area\");\n        internalManager.itemStart(\"smaa-search\");\n        internalManager.itemStart(\"smaa-area\");\n        searchImage.src = searchImageDataURL_default;\n        areaImage.src = areaImageDataURL_default;\n      });\n    }\n  }]);\n\n  return SMAAImageLoader;\n}(Loader3);\n\nexport { AdaptiveLuminanceMaterial, AdaptiveLuminancePass, BlendFunction, BlendMode, BloomEffect, BlurPass, BokehEffect, BokehMaterial, BrightnessContrastEffect, ChromaticAberrationEffect, CircleOfConfusionMaterial, ClearMaskPass, ClearPass, ColorAverageEffect, ColorChannel, ColorDepthEffect, ColorEdgesMaterial, ConvolutionMaterial, CopyMaterial, DepthComparisonMaterial, DepthDownsamplingMaterial, DepthDownsamplingPass, DepthEffect, DepthMaskMaterial, DepthOfFieldEffect, DepthPass, Disposable, DotScreenEffect, EdgeDetectionMaterial, EdgeDetectionMode, Effect, EffectAttribute, EffectComposer, EffectMaterial, EffectPass, GammaCorrectionEffect, GlitchEffect, GlitchMode, GodRaysEffect, GodRaysMaterial, GridEffect, HueSaturationEffect, Initializable, KernelSize, LUT3dlLoader, LUTCubeLoader, LUTEffect, LUTOperation, LambdaPass, LookupTexture3D, LuminanceMaterial, LuminancePass, MaskFunction, MaskMaterial, MaskPass, NoiseEffect, NoiseTexture, NormalPass, OutlineEdgesMaterial, OutlineEffect, OutlineMaterial, OverrideMaterialManager, Pass, PixelationEffect, PredicationMode, RawImageData, RealisticBokehEffect, RenderPass, Resizable, Resizer, SMAAAreaImageData, SMAAEffect, SMAAImageGenerator, SMAAImageLoader, SMAAPreset, SMAASearchImageData, SMAAWeightsMaterial, SSAOEffect, SSAOMaterial, SavePass, ScanlineEffect, Section, Selection, SelectiveBloomEffect, SepiaEffect, ShaderPass, ShockWaveEffect, TetrahedralUpscaler, TextureEffect, ToneMappingEffect, ToneMappingMode, VignetteEffect, WebGLExtension };"],"sourceRoot":""}